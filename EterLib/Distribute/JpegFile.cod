; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\GamePackages\Client\Tools\Patcher2017\EterLib\JpegFile.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?jpeg_save@@YAHPAEHHHPBD@Z			; jpeg_save
PUBLIC	?jpeg_save_to_file@@YAHPAEHHHPAU_iobuf@@@Z	; jpeg_save_to_file
PUBLIC	?jpeg_save_to_mem@@YAHPAEHHH0H@Z		; jpeg_save_to_mem
PUBLIC	?jpeg_load@@YAHPBDPAPAEPAH2@Z			; jpeg_load
PUBLIC	?jpeg_load_from_mem@@YAHPAEH0HH@Z		; jpeg_load_from_mem
PUBLIC	?mem_init_source@@YAXPAUjpeg_decompress_struct@@@Z ; mem_init_source
PUBLIC	?mem_fill_input_buffer@@YAEPAUjpeg_decompress_struct@@@Z ; mem_fill_input_buffer
PUBLIC	?mem_skip_input_data@@YAXPAUjpeg_decompress_struct@@J@Z ; mem_skip_input_data
PUBLIC	?mem_resync_to_restart@@YAEPAUjpeg_decompress_struct@@H@Z ; mem_resync_to_restart
PUBLIC	?mem_term_source@@YAXPAUjpeg_decompress_struct@@@Z ; mem_term_source
PUBLIC	??_C@_06GLDDLHNF@malloc?$AA@			; `string'
PUBLIC	??_C@_0BA@BLONFKFG@Out?5of?5memory?$CB?6?$AA@	; `string'
PUBLIC	??_C@_0BE@CJGMBEKG@jpeg?5mem?5overflow?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_08CJBHLKCB@fill?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0N@KMFLAFCK@skip?5?$CFd?5?$CL?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0L@MJDMKOIM@resync?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_0BH@FLHCPHLC@Couldn?8t?5open?5file?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0CD@HHOHJMLB@Error?3?5Can?8t?5convert?5YCCK?5to?5RGB@ ; `string'
EXTRN	_exit:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_perror:PROC
EXTRN	___iob_func:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fprintf:PROC
EXTRN	_fwrite:PROC
EXTRN	_printf:PROC
EXTRN	_jpeg_std_error:PROC
EXTRN	_jpeg_CreateCompress:PROC
EXTRN	_jpeg_CreateDecompress:PROC
EXTRN	_jpeg_destroy_compress:PROC
EXTRN	_jpeg_destroy_decompress:PROC
EXTRN	_jpeg_stdio_src:PROC
EXTRN	_jpeg_set_defaults:PROC
EXTRN	_jpeg_set_quality:PROC
EXTRN	_jpeg_start_compress:PROC
EXTRN	_jpeg_write_scanlines:PROC
EXTRN	_jpeg_finish_compress:PROC
EXTRN	_jpeg_read_header:PROC
EXTRN	_jpeg_start_decompress:PROC
EXTRN	_jpeg_read_scanlines:PROC
EXTRN	_jpeg_finish_decompress:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_fi	DD	01H DUP (?)
_buffer	DD	01H DUP (?)
_dest	DD	01H DUP (?)
_len	DD	01H DUP (?)
_destlen DD	01H DUP (?)
_data	DD	01H DUP (?)
_size	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CD@HHOHJMLB@Error?3?5Can?8t?5convert?5YCCK?5to?5RGB@
CONST	SEGMENT
??_C@_0CD@HHOHJMLB@Error?3?5Can?8t?5convert?5YCCK?5to?5RGB@ DB 'Error: Ca'
	DB	'n''t convert YCCK to RGB.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FLHCPHLC@Couldn?8t?5open?5file?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BH@FLHCPHLC@Couldn?8t?5open?5file?5?$CFs?6?$AA@ DB 'Couldn''t open'
	DB	' file %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MJDMKOIM@resync?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0L@MJDMKOIM@resync?5?$CFd?6?$AA@ DB 'resync %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KMFLAFCK@skip?5?$CFd?5?$CL?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0N@KMFLAFCK@skip?5?$CFd?5?$CL?$CFd?6?$AA@ DB 'skip %d +%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CJBHLKCB@fill?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_08CJBHLKCB@fill?5?$CFd?6?$AA@ DB 'fill %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CJGMBEKG@jpeg?5mem?5overflow?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BE@CJGMBEKG@jpeg?5mem?5overflow?$CB?6?$AA@ DB 'jpeg mem overflow!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BLONFKFG@Out?5of?5memory?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BA@BLONFKFG@Out?5of?5memory?$CB?6?$AA@ DB 'Out of memory!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLDDLHNF@malloc?$AA@
CONST	SEGMENT
??_C@_06GLDDLHNF@malloc?$AA@ DB 'malloc', 00H		; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\jpegfile.cpp
;	COMDAT ?mem_term_source@@YAXPAUjpeg_decompress_struct@@@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
?mem_term_source@@YAXPAUjpeg_decompress_struct@@@Z PROC	; mem_term_source, COMDAT

; 249  :     struct jpeg_source_mgr* mgr = cinfo->src;
; 250  :     //printf("term %d\n", size - mgr->bytes_in_buffer);
; 251  : }

  00000	c3		 ret	 0
?mem_term_source@@YAXPAUjpeg_decompress_struct@@@Z ENDP	; mem_term_source
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\jpegfile.cpp
;	COMDAT ?mem_resync_to_restart@@YAEPAUjpeg_decompress_struct@@H@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
_desired$ = 12						; size = 4
?mem_resync_to_restart@@YAEPAUjpeg_decompress_struct@@H@Z PROC ; mem_resync_to_restart, COMDAT

; 239  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 240  :     struct jpeg_source_mgr* mgr = cinfo->src;

  00003	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00006	56		 push	 esi
  00007	8b 70 18	 mov	 esi, DWORD PTR [eax+24]

; 241  :     printf("resync %d\n", size - mgr->bytes_in_buffer);

  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR _size
  0000f	2b 46 04	 sub	 eax, DWORD PTR [esi+4]
  00012	50		 push	 eax
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MJDMKOIM@resync?5?$CFd?6?$AA@
  00018	e8 00 00 00 00	 call	 _printf

; 242  :     mgr->next_input_byte = data;

  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR _data
  00022	83 c4 08	 add	 esp, 8
  00025	89 06		 mov	 DWORD PTR [esi], eax

; 243  :     mgr->bytes_in_buffer = size;

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR _size
  0002c	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 244  :     return 1;

  0002f	b0 01		 mov	 al, 1
  00031	5e		 pop	 esi

; 245  : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?mem_resync_to_restart@@YAEPAUjpeg_decompress_struct@@H@Z ENDP ; mem_resync_to_restart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\jpegfile.cpp
;	COMDAT ?mem_skip_input_data@@YAXPAUjpeg_decompress_struct@@J@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
_num_bytes$ = 12					; size = 4
?mem_skip_input_data@@YAXPAUjpeg_decompress_struct@@J@Z PROC ; mem_skip_input_data, COMDAT

; 229  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 230  :     struct jpeg_source_mgr* mgr = cinfo->src;

  00003	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi

; 231  :     printf("skip %d +%d\n", size - mgr->bytes_in_buffer, num_bytes);

  00008	8b 7d 0c	 mov	 edi, DWORD PTR _num_bytes$[ebp]
  0000b	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR _size
  00013	57		 push	 edi
  00014	2b 46 04	 sub	 eax, DWORD PTR [esi+4]
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KMFLAFCK@skip?5?$CFd?5?$CL?$CFd?6?$AA@
  0001d	e8 00 00 00 00	 call	 _printf
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 232  :     if(num_bytes<=0)

  00025	85 ff		 test	 edi, edi
  00027	7e 05		 jle	 SHORT $LN2@mem_skip_i

; 233  : 	return;
; 234  :     mgr->next_input_byte += num_bytes;

  00029	01 3e		 add	 DWORD PTR [esi], edi

; 235  :     mgr->bytes_in_buffer -= num_bytes;

  0002b	29 7e 04	 sub	 DWORD PTR [esi+4], edi
$LN2@mem_skip_i:
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 236  : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?mem_skip_input_data@@YAXPAUjpeg_decompress_struct@@J@Z ENDP ; mem_skip_input_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\jpegfile.cpp
;	COMDAT ?mem_fill_input_buffer@@YAEPAUjpeg_decompress_struct@@@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
?mem_fill_input_buffer@@YAEPAUjpeg_decompress_struct@@@Z PROC ; mem_fill_input_buffer, COMDAT

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 223  :     struct jpeg_source_mgr* mgr = cinfo->src;
; 224  :     printf("fill %d\n", size - mgr->bytes_in_buffer);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _size
  0000c	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000f	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_08CJBHLKCB@fill?5?$CFd?6?$AA@
  00018	e8 00 00 00 00	 call	 _printf
  0001d	83 c4 08	 add	 esp, 8

; 225  :     return 0;

  00020	32 c0		 xor	 al, al

; 226  : }

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?mem_fill_input_buffer@@YAEPAUjpeg_decompress_struct@@@Z ENDP ; mem_fill_input_buffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\jpegfile.cpp
;	COMDAT ?mem_init_source@@YAXPAUjpeg_decompress_struct@@@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
?mem_init_source@@YAXPAUjpeg_decompress_struct@@@Z PROC	; mem_init_source, COMDAT

; 214  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 215  :     struct jpeg_source_mgr* mgr = cinfo->src;

  00003	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00006	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]

; 216  :     mgr->next_input_byte = data;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _data
  0000e	89 01		 mov	 DWORD PTR [ecx], eax

; 217  :     mgr->bytes_in_buffer = size;

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR _size
  00015	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 218  :     //printf("init %d\n", size - mgr->bytes_in_buffer);
; 219  : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?mem_init_source@@YAXPAUjpeg_decompress_struct@@@Z ENDP	; mem_init_source
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\jpegfile.cpp
;	COMDAT ?mem_term_destination@@YAXPAUjpeg_compress_struct@@@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
?mem_term_destination@@YAXPAUjpeg_compress_struct@@@Z PROC ; mem_term_destination, COMDAT

; 71   : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :   struct jpeg_destination_mgr*dmgr = 
; 73   :       (struct jpeg_destination_mgr*)(cinfo->dest);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00006	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]

; 74   :   len = destlen - dmgr->free_in_buffer;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _destlen
  0000e	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00011	a3 00 00 00 00	 mov	 DWORD PTR _len, eax

; 75   :   dmgr->free_in_buffer = 0;

  00016	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 76   : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?mem_term_destination@@YAXPAUjpeg_compress_struct@@@Z ENDP ; mem_term_destination
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\jpegfile.cpp
;	COMDAT ?mem_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
?mem_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z PROC ; mem_empty_output_buffer, COMDAT

; 66   :     printf("jpeg mem overflow!\n");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CJGMBEKG@jpeg?5mem?5overflow?$CB?6?$AA@
  00005	e8 00 00 00 00	 call	 _printf
  0000a	83 c4 04	 add	 esp, 4

; 67   :     exit(1);

  0000d	6a 01		 push	 1
  0000f	e8 00 00 00 00	 call	 _exit
$LN4@mem_empty_:
$LN3@mem_empty_:
  00014	cc		 int	 3
?mem_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z ENDP ; mem_empty_output_buffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\jpegfile.cpp
;	COMDAT ?mem_init_destination@@YAXPAUjpeg_compress_struct@@@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
?mem_init_destination@@YAXPAUjpeg_compress_struct@@@Z PROC ; mem_init_destination, COMDAT

; 57   : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 58   :   struct jpeg_destination_mgr*dmgr = 
; 59   :       (struct jpeg_destination_mgr*)(cinfo->dest);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00006	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]

; 60   :   dmgr->next_output_byte = dest;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _dest
  0000e	89 01		 mov	 DWORD PTR [ecx], eax

; 61   :   dmgr->free_in_buffer = destlen;

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR _destlen
  00015	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 62   : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?mem_init_destination@@YAXPAUjpeg_compress_struct@@@Z ENDP ; mem_init_destination
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\jpegfile.cpp
;	COMDAT ?file_term_destination@@YAXPAUjpeg_compress_struct@@@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
?file_term_destination@@YAXPAUjpeg_compress_struct@@@Z PROC ; file_term_destination, COMDAT

; 47   : { struct jpeg_destination_mgr*dmgr = 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 48   :       (struct jpeg_destination_mgr*)(cinfo->dest);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00006	56		 push	 esi
  00007	8b 70 18	 mov	 esi, DWORD PTR [eax+24]

; 49   :   if(fi)

  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR _fi
  0000f	85 c0		 test	 eax, eax
  00011	74 1a		 je	 SHORT $LN1@file_term_

; 50   :     fwrite(buffer, OUTBUFFER_SIZE-dmgr->free_in_buffer, 1, fi);

  00013	50		 push	 eax
  00014	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00019	2b 46 04	 sub	 eax, DWORD PTR [esi+4]
  0001c	6a 01		 push	 1
  0001e	50		 push	 eax
  0001f	ff 35 00 00 00
	00		 push	 DWORD PTR _buffer
  00025	e8 00 00 00 00	 call	 _fwrite
  0002a	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@file_term_:

; 51   :   free(buffer);

  0002d	ff 35 00 00 00
	00		 push	 DWORD PTR _buffer
  00033	e8 00 00 00 00	 call	 _free
  00038	83 c4 04	 add	 esp, 4

; 52   :   buffer = 0;
; 53   :   dmgr->free_in_buffer = 0;

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00042	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _buffer, 0
  0004c	5e		 pop	 esi

; 54   : }

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?file_term_destination@@YAXPAUjpeg_compress_struct@@@Z ENDP ; file_term_destination
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\jpegfile.cpp
;	COMDAT ?file_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
?file_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z PROC ; file_empty_output_buffer, COMDAT

; 36   : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 37   :   struct jpeg_destination_mgr*dmgr = 
; 38   :       (struct jpeg_destination_mgr*)(cinfo->dest);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00006	56		 push	 esi
  00007	8b 70 18	 mov	 esi, DWORD PTR [eax+24]

; 39   :   if(fi)

  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR _fi
  0000f	85 c0		 test	 eax, eax
  00011	74 16		 je	 SHORT $LN1@file_empty

; 40   :     fwrite(buffer, OUTBUFFER_SIZE, 1, fi);

  00013	50		 push	 eax
  00014	6a 01		 push	 1
  00016	68 00 80 00 00	 push	 32768			; 00008000H
  0001b	ff 35 00 00 00
	00		 push	 DWORD PTR _buffer
  00021	e8 00 00 00 00	 call	 _fwrite
  00026	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@file_empty:

; 41   :   dmgr->next_output_byte = buffer;

  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR _buffer
  0002e	89 06		 mov	 DWORD PTR [esi], eax

; 42   :   dmgr->free_in_buffer = OUTBUFFER_SIZE;
; 43   :   return 1;

  00030	b0 01		 mov	 al, 1
  00032	c7 46 04 00 80
	00 00		 mov	 DWORD PTR [esi+4], 32768 ; 00008000H
  00039	5e		 pop	 esi

; 44   : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?file_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z ENDP ; file_empty_output_buffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\jpegfile.cpp
;	COMDAT ?file_init_destination@@YAXPAUjpeg_compress_struct@@@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
?file_init_destination@@YAXPAUjpeg_compress_struct@@@Z PROC ; file_init_destination, COMDAT

; 22   : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   :   struct jpeg_destination_mgr*dmgr = 
; 24   :       (struct jpeg_destination_mgr*)(cinfo->dest);

  00003	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00006	56		 push	 esi

; 25   :   buffer = (JOCTET*)malloc(OUTBUFFER_SIZE);

  00007	68 00 80 00 00	 push	 32768			; 00008000H
  0000c	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  0000f	e8 00 00 00 00	 call	 _malloc
  00014	83 c4 04	 add	 esp, 4
  00017	a3 00 00 00 00	 mov	 DWORD PTR _buffer, eax

; 26   :   if(!buffer) {

  0001c	85 c0		 test	 eax, eax
  0001e	74 0c		 je	 SHORT $LN5@file_init_

; 30   :   }
; 31   :   dmgr->next_output_byte = buffer;

  00020	89 06		 mov	 DWORD PTR [esi], eax

; 32   :   dmgr->free_in_buffer = OUTBUFFER_SIZE;

  00022	c7 46 04 00 80
	00 00		 mov	 DWORD PTR [esi+4], 32768 ; 00008000H
  00029	5e		 pop	 esi

; 33   : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN5@file_init_:

; 27   :       perror("malloc");

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_06GLDDLHNF@malloc?$AA@
  00031	e8 00 00 00 00	 call	 _perror

; 28   :       printf("Out of memory!\n");

  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@BLONFKFG@Out?5of?5memory?$CB?6?$AA@
  0003b	e8 00 00 00 00	 call	 _printf
  00040	83 c4 08	 add	 esp, 8

; 29   :       exit(1);

  00043	6a 01		 push	 1
  00045	e8 00 00 00 00	 call	 _exit
$LN7@file_init_:
$LN4@file_init_:
  0004a	cc		 int	 3
?file_init_destination@@YAXPAUjpeg_compress_struct@@@Z ENDP ; file_init_destination
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\jpegfile.cpp
;	COMDAT ?jpeg_load_from_mem@@YAHPAEH0HH@Z
_TEXT	SEGMENT
_mgr$ = -600						; size = 28
_j$1 = -572						; size = 4
_cinfo$ = -568						; size = 432
_jerr$ = -136						; size = 132
__$ArrayPad$ = -4					; size = 4
__data$ = 8						; size = 4
__size$ = 12						; size = 4
_dest$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
?jpeg_load_from_mem@@YAHPAEH0HH@Z PROC			; jpeg_load_from_mem, COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 58 02 00
	00		 sub	 esp, 600		; 00000258H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR __data$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 14	 mov	 ebx, DWORD PTR _width$[ebp]
  0001a	56		 push	 esi
  0001b	8b 75 10	 mov	 esi, DWORD PTR _dest$[ebp]
  0001e	57		 push	 edi

; 255  :     struct jpeg_decompress_struct cinfo;
; 256  :     struct jpeg_error_mgr jerr;
; 257  :     struct jpeg_source_mgr mgr;
; 258  :     int y;
; 259  : 	//int x;
; 260  : 
; 261  :     data = _data;

  0001f	a3 00 00 00 00	 mov	 DWORD PTR _data, eax

; 262  :     size = _size;

  00024	8b 45 0c	 mov	 eax, DWORD PTR __size$[ebp]

; 263  : 
; 264  :     jpeg_create_decompress(&cinfo); 

  00027	68 b0 01 00 00	 push	 432			; 000001b0H
  0002c	a3 00 00 00 00	 mov	 DWORD PTR _size, eax
  00031	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00037	6a 3e		 push	 62			; 0000003eH
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _jpeg_CreateDecompress

; 265  : 
; 266  :     mgr.next_input_byte = data;

  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR _data
  00044	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _mgr$[ebp], eax

; 267  :     mgr.bytes_in_buffer = size;

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR _size
  0004f	89 85 ac fd ff
	ff		 mov	 DWORD PTR _mgr$[ebp+4], eax

; 268  :     mgr.init_source        =mem_init_source ;
; 269  :     mgr.fill_input_buffer  =mem_fill_input_buffer ;
; 270  :     mgr.skip_input_data    =mem_skip_input_data ;
; 271  :     mgr.resync_to_restart  =mem_resync_to_restart ;
; 272  :     mgr.term_source        =mem_term_source ;
; 273  : 
; 274  :     cinfo.err = jpeg_std_error(&jerr);

  00055	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp]
  0005b	50		 push	 eax
  0005c	c7 85 b0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+8], OFFSET ?mem_init_source@@YAXPAUjpeg_decompress_struct@@@Z ; mem_init_source
  00066	c7 85 b4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+12], OFFSET ?mem_fill_input_buffer@@YAEPAUjpeg_decompress_struct@@@Z ; mem_fill_input_buffer
  00070	c7 85 b8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+16], OFFSET ?mem_skip_input_data@@YAXPAUjpeg_decompress_struct@@J@Z ; mem_skip_input_data
  0007a	c7 85 bc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+20], OFFSET ?mem_resync_to_restart@@YAEPAUjpeg_decompress_struct@@H@Z ; mem_resync_to_restart
  00084	c7 85 c0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+24], OFFSET ?mem_term_source@@YAXPAUjpeg_decompress_struct@@@Z ; mem_term_source
  0008e	e8 00 00 00 00	 call	 _jpeg_std_error
  00093	89 85 c8 fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp], eax

; 275  :     cinfo.src = &mgr;

  00099	8d 85 a8 fd ff
	ff		 lea	 eax, DWORD PTR _mgr$[ebp]
  0009f	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+24], eax

; 276  : 
; 277  :     jpeg_read_header(&cinfo, TRUE);

  000a5	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000ab	6a 01		 push	 1
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 _jpeg_read_header

; 278  :     jpeg_start_decompress(&cinfo);

  000b3	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 _jpeg_start_decompress

; 279  : 
; 280  :     for(y=0;y<height;y++) {

  000bf	8b 7d 18	 mov	 edi, DWORD PTR _height$[ebp]
  000c2	83 c4 1c	 add	 esp, 28			; 0000001cH
  000c5	85 ff		 test	 edi, edi
  000c7	7e 2a		 jle	 SHORT $LN1@jpeg_load_
  000c9	8d 1c 5b	 lea	 ebx, DWORD PTR [ebx+ebx*2]
  000cc	8d 64 24 00	 npad	 4
$LL3@jpeg_load_:

; 281  : 	unsigned char*j = &dest[width*y*3];
; 282  : 	jpeg_read_scanlines(&cinfo,&j,1);

  000d0	6a 01		 push	 1
  000d2	8d 85 c4 fd ff
	ff		 lea	 eax, DWORD PTR _j$1[ebp]
  000d8	89 b5 c4 fd ff
	ff		 mov	 DWORD PTR _j$1[ebp], esi
  000de	50		 push	 eax
  000df	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _jpeg_read_scanlines
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ee	03 f3		 add	 esi, ebx
  000f0	4f		 dec	 edi
  000f1	75 dd		 jne	 SHORT $LL3@jpeg_load_
$LN1@jpeg_load_:

; 283  :     }
; 284  : 
; 285  :     jpeg_finish_decompress(&cinfo);

  000f3	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 _jpeg_finish_decompress

; 286  :     jpeg_destroy_decompress(&cinfo);

  000ff	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 _jpeg_destroy_decompress

; 287  :     return 1;
; 288  : }

  0010b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010e	83 c4 08	 add	 esp, 8
  00111	33 cd		 xor	 ecx, ebp
  00113	b8 01 00 00 00	 mov	 eax, 1
  00118	5f		 pop	 edi
  00119	5e		 pop	 esi
  0011a	5b		 pop	 ebx
  0011b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c3		 ret	 0
?jpeg_load_from_mem@@YAHPAEH0HH@Z ENDP			; jpeg_load_from_mem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\jpegfile.cpp
;	COMDAT ?jpeg_load@@YAHPBDPAPAEPAH2@Z
_TEXT	SEGMENT
tv1089 = -608						; size = 4
_fi$1$ = -604						; size = 4
_width$1$ = -600					; size = 4
_height$1$ = -596					; size = 4
tv1085 = -592						; size = 4
_y$1$ = -588						; size = 4
_dest$GSCopy$1$ = -584					; size = 4
tv1081 = -580						; size = 4
__height$GSCopy$1$ = -580				; size = 4
_scanline$1$ = -576					; size = 4
_js$1 = -572						; size = 4
_cinfo$ = -568						; size = 432
_jerr$ = -136						; size = 132
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_dest$ = 12						; size = 4
__width$ = 16						; size = 4
__height$ = 20						; size = 4
?jpeg_load@@YAHPBDPAPAEPAH2@Z PROC			; jpeg_load, COMDAT

; 297  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 60 02 00
	00		 sub	 esp, 608		; 00000260H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 10	 mov	 ebx, DWORD PTR __width$[ebp]
  0001a	56		 push	 esi
  0001b	8b 75 08	 mov	 esi, DWORD PTR _filename$[ebp]
  0001e	57		 push	 edi
  0001f	89 85 b8 fd ff
	ff		 mov	 DWORD PTR _dest$GSCopy$1$[ebp], eax
  00025	8b 45 14	 mov	 eax, DWORD PTR __height$[ebp]

; 298  :     struct jpeg_decompress_struct cinfo;
; 299  :     struct jpeg_error_mgr jerr;
; 300  :     //struct jpeg_source_mgr mgr;
; 301  : 
; 302  :     FILE*fi = fopen(filename, "rb");

  00028	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  0002d	56		 push	 esi
  0002e	89 85 bc fd ff
	ff		 mov	 DWORD PTR __height$GSCopy$1$[ebp], eax
  00034	e8 00 00 00 00	 call	 _fopen
  00039	8b f8		 mov	 edi, eax
  0003b	83 c4 08	 add	 esp, 8
  0003e	89 bd a4 fd ff
	ff		 mov	 DWORD PTR _fi$1$[ebp], edi

; 303  :     if(!fi) {

  00044	85 ff		 test	 edi, edi
  00046	75 2a		 jne	 SHORT $LN25@jpeg_load

; 304  :         fprintf(stderr, "Couldn't open file %s\n", filename);

  00048	56		 push	 esi
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@FLHCPHLC@Couldn?8t?5open?5file?5?$CFs?6?$AA@
  0004e	e8 00 00 00 00	 call	 ___iob_func
  00053	83 c0 40	 add	 eax, 64			; 00000040H
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _fprintf
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 305  : 	return 0;

  0005f	33 c0		 xor	 eax, eax
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx

; 369  : }

  00064	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00067	33 cd		 xor	 ecx, ebp
  00069	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
$LN25@jpeg_load:

; 306  :     }
; 307  : 
; 308  :     cinfo.err = jpeg_std_error(&jerr);

  00072	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 _jpeg_std_error

; 309  :     jpeg_create_decompress(&cinfo); 

  0007e	68 b0 01 00 00	 push	 432			; 000001b0H
  00083	89 85 c8 fd ff
	ff		 mov	 DWORD PTR _cinfo$[ebp], eax
  00089	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0008f	6a 3e		 push	 62			; 0000003eH
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 _jpeg_CreateDecompress

; 310  :     jpeg_stdio_src(&cinfo, fi);

  00097	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0009d	57		 push	 edi
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 _jpeg_stdio_src

; 311  :     jpeg_read_header(&cinfo, TRUE);

  000a4	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000aa	6a 01		 push	 1
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 _jpeg_read_header

; 312  :     jpeg_start_decompress(&cinfo);

  000b2	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 _jpeg_start_decompress

; 313  :     
; 314  :     U8*scanline = (U8 *)malloc(4 * cinfo.output_width);

  000be	8b bd 24 fe ff
	ff		 mov	 edi, DWORD PTR _cinfo$[ebp+92]
  000c4	89 bd a8 fd ff
	ff		 mov	 DWORD PTR _width$1$[ebp], edi
  000ca	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 _malloc

; 315  : 
; 316  :     int width = *_width = cinfo.output_width;
; 317  :     int height = *_height = cinfo.output_height;

  000d7	8b 8d bc fd ff
	ff		 mov	 ecx, DWORD PTR __height$GSCopy$1$[ebp]
  000dd	8b f0		 mov	 esi, eax
  000df	89 3b		 mov	 DWORD PTR [ebx], edi
  000e1	8b 9d 28 fe ff
	ff		 mov	 ebx, DWORD PTR _cinfo$[ebp+96]
  000e7	89 b5 c0 fd ff
	ff		 mov	 DWORD PTR _scanline$1$[ebp], esi
  000ed	89 19		 mov	 DWORD PTR [ecx], ebx

; 318  :     *dest = (unsigned char*)malloc(width*height*4);

  000ef	8b cb		 mov	 ecx, ebx
  000f1	0f af cf	 imul	 ecx, edi
  000f4	89 9d ac fd ff
	ff		 mov	 DWORD PTR _height$1$[ebp], ebx
  000fa	c1 e1 02	 shl	 ecx, 2
  000fd	51		 push	 ecx
  000fe	e8 00 00 00 00	 call	 _malloc
  00103	8b 95 b8 fd ff
	ff		 mov	 edx, DWORD PTR _dest$GSCopy$1$[ebp]
  00109	83 c4 2c	 add	 esp, 44			; 0000002cH

; 319  : 
; 320  :     int y;
; 321  :     for (y=0;y<height;y++) {

  0010c	c7 85 b4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$1$[ebp], 0
  00116	89 02		 mov	 DWORD PTR [edx], eax
  00118	85 db		 test	 ebx, ebx
  0011a	0f 8e 1d 02 00
	00		 jle	 $LN22@jpeg_load

; 306  :     }
; 307  : 
; 308  :     cinfo.err = jpeg_std_error(&jerr);

  00120	33 c9		 xor	 ecx, ecx
  00122	89 8d bc fd ff
	ff		 mov	 DWORD PTR tv1081[ebp], ecx
  00128	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL24@jpeg_load:

; 322  : 	int x;
; 323  : 	U8 *js = scanline;
; 324  :         RGBA*line = &((RGBA*)(*dest))[y*width];

  00130	8b 1a		 mov	 ebx, DWORD PTR [edx]

; 325  : 
; 326  : 	jpeg_read_scanlines(&cinfo, &js, 1);

  00132	8d 85 c4 fd ff
	ff		 lea	 eax, DWORD PTR _js$1[ebp]
  00138	6a 01		 push	 1
  0013a	50		 push	 eax
  0013b	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00141	89 b5 c4 fd ff
	ff		 mov	 DWORD PTR _js$1[ebp], esi
  00147	50		 push	 eax
  00148	03 d9		 add	 ebx, ecx
  0014a	e8 00 00 00 00	 call	 _jpeg_read_scanlines

; 327  : 	if (cinfo.out_color_space == JCS_GRAYSCALE) {

  0014f	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _cinfo$[ebp+44]
  00155	83 c4 0c	 add	 esp, 12			; 0000000cH
  00158	83 f8 01	 cmp	 eax, 1
  0015b	75 36		 jne	 SHORT $LN21@jpeg_load

; 328  : 	    for (x = 0; x < width; x++) {

  0015d	33 d2		 xor	 edx, edx
  0015f	85 ff		 test	 edi, edi
  00161	0f 8e a2 01 00
	00		 jle	 $LN23@jpeg_load
  00167	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  0016a	8d 9b 00 00 00
	00		 npad	 6
$LL20@jpeg_load:

; 329  : 		line[x].a = 255;

  00170	c6 40 fe ff	 mov	 BYTE PTR [eax-2], 255	; 000000ffH
  00174	8d 40 04	 lea	 eax, DWORD PTR [eax+4]

; 330  : 		line[x].r = line[x].g = line[x].b = js[x];

  00177	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR _js$1[ebp]
  0017d	8a 0c 0a	 mov	 cl, BYTE PTR [edx+ecx]
  00180	42		 inc	 edx
  00181	88 48 fd	 mov	 BYTE PTR [eax-3], cl
  00184	88 48 fc	 mov	 BYTE PTR [eax-4], cl
  00187	88 48 fb	 mov	 BYTE PTR [eax-5], cl
  0018a	3b d7		 cmp	 edx, edi
  0018c	7c e2		 jl	 SHORT $LL20@jpeg_load

; 331  : 	    }

  0018e	e9 76 01 00 00	 jmp	 $LN23@jpeg_load
$LN21@jpeg_load:

; 332  : 	} else if (cinfo.out_color_space == JCS_RGB) {

  00193	83 f8 02	 cmp	 eax, 2
  00196	75 54		 jne	 SHORT $LN16@jpeg_load

; 333  : 	    for (x = width - 1; x >= 0; x--) {

  00198	8d 77 ff	 lea	 esi, DWORD PTR [edi-1]
  0019b	85 f6		 test	 esi, esi
  0019d	0f 88 60 01 00
	00		 js	 $LN50@jpeg_load
  001a3	8d 0c b5 02 00
	00 00		 lea	 ecx, DWORD PTR [esi*4+2]
  001aa	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]
  001ad	03 cb		 add	 ecx, ebx
  001af	90		 npad	 1
$LL15@jpeg_load:
  001b0	4e		 dec	 esi

; 334  : 		line[x].a = 255;

  001b1	c6 41 fe ff	 mov	 BYTE PTR [ecx-2], 255	; 000000ffH

; 335  : 		line[x].r = js[x*3+0];

  001b5	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _js$1[ebp]
  001bb	8d 52 fd	 lea	 edx, DWORD PTR [edx-3]
  001be	8d 49 fc	 lea	 ecx, DWORD PTR [ecx-4]
  001c1	0f b6 44 02 03	 movzx	 eax, BYTE PTR [edx+eax+3]
  001c6	88 41 03	 mov	 BYTE PTR [ecx+3], al

; 336  : 		line[x].g = js[x*3+1];

  001c9	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _js$1[ebp]
  001cf	0f b6 44 02 04	 movzx	 eax, BYTE PTR [edx+eax+4]
  001d4	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 337  : 		line[x].b = js[x*3+2];

  001d7	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _js$1[ebp]
  001dd	0f b6 44 02 05	 movzx	 eax, BYTE PTR [edx+eax+5]
  001e2	88 41 05	 mov	 BYTE PTR [ecx+5], al
  001e5	79 c9		 jns	 SHORT $LL15@jpeg_load

; 338  : 	    }

  001e7	e9 17 01 00 00	 jmp	 $LN50@jpeg_load
$LN16@jpeg_load:

; 339  : 	} else if (cinfo.out_color_space == JCS_YCCK) {

  001ec	83 f8 05	 cmp	 eax, 5
  001ef	0f 84 8a 01 00
	00		 je	 $LN33@jpeg_load

; 341  : 	    return 0;
; 342  : 	} else if (cinfo.out_color_space == JCS_YCbCr) {

  001f5	83 f8 03	 cmp	 eax, 3
  001f8	0f 85 89 00 00
	00		 jne	 $LN9@jpeg_load

; 343  : 	    for (x = 0; x < width; x++) {

  001fe	85 ff		 test	 edi, edi
  00200	0f 8e 03 01 00
	00		 jle	 $LN23@jpeg_load
  00206	c7 85 a0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1089[ebp], 0
  00210	8d 73 02	 lea	 esi, DWORD PTR [ebx+2]
  00213	89 bd b0 fd ff
	ff		 mov	 DWORD PTR tv1085[ebp], edi
  00219	8b bd a0 fd ff
	ff		 mov	 edi, DWORD PTR tv1089[ebp]
  0021f	90		 npad	 1
$LL8@jpeg_load:

; 344  : 		int y = js[x * 3 + 0];

  00220	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _js$1[ebp]
  00226	8d 7f 03	 lea	 edi, DWORD PTR [edi+3]
  00229	8d 76 04	 lea	 esi, DWORD PTR [esi+4]

; 345  : 		int u = js[x * 3 + 1];

  0022c	0f b6 54 07 fe	 movzx	 edx, BYTE PTR [edi+eax-2]
  00231	0f b6 5c 07 fd	 movzx	 ebx, BYTE PTR [edi+eax-3]

; 346  : 		int v = js[x * 3 + 1];
; 347  : 		line[x].a = 255;
; 348  : 		line[x].r = y + ((360 * (v - 128)) >> 8);
; 349  : 		line[x].g = y - ((88 * (u - 128) + 183 * (v - 128)) >> 8);

  00236	69 ca b7 00 00
	00		 imul	 ecx, edx, 183
  0023c	c6 46 fa ff	 mov	 BYTE PTR [esi-6], 255	; 000000ffH
  00240	8d 42 80	 lea	 eax, DWORD PTR [edx-128]
  00243	69 c0 68 01 00
	00		 imul	 eax, eax, 360
  00249	81 c1 80 78 ff
	ff		 add	 ecx, -34688		; ffff7880H
  0024f	c1 f8 08	 sar	 eax, 8
  00252	02 c3		 add	 al, bl
  00254	88 46 fb	 mov	 BYTE PTR [esi-5], al
  00257	6b c2 58	 imul	 eax, edx, 88
  0025a	03 c8		 add	 ecx, eax
  0025c	8a c3		 mov	 al, bl
  0025e	c1 f9 08	 sar	 ecx, 8
  00261	2a c1		 sub	 al, cl
  00263	88 46 fc	 mov	 BYTE PTR [esi-4], al

; 350  : 		line[x].b = y + ((455 * (u - 128)) >> 8);

  00266	8d 42 80	 lea	 eax, DWORD PTR [edx-128]
  00269	69 c0 c7 01 00
	00		 imul	 eax, eax, 455
  0026f	c1 f8 08	 sar	 eax, 8
  00272	02 c3		 add	 al, bl
  00274	ff 8d b0 fd ff
	ff		 dec	 DWORD PTR tv1085[ebp]
  0027a	88 46 fd	 mov	 BYTE PTR [esi-3], al
  0027d	75 a1		 jne	 SHORT $LL8@jpeg_load

; 351  : 	    }

  0027f	8b bd a8 fd ff
	ff		 mov	 edi, DWORD PTR _width$1$[ebp]
  00285	eb 7c		 jmp	 SHORT $LN50@jpeg_load
$LN9@jpeg_load:

; 352  : 	} else if (cinfo.out_color_space == JCS_CMYK) {

  00287	83 f8 04	 cmp	 eax, 4
  0028a	75 7d		 jne	 SHORT $LN23@jpeg_load

; 353  : 	    for (x = 0; x < width; x++) {

  0028c	33 f6		 xor	 esi, esi
  0028e	85 ff		 test	 edi, edi
  00290	7e 71		 jle	 SHORT $LN50@jpeg_load
  00292	eb 0c 8d a4 24
	00 00 00 00 eb
	03 8d 49 00	 npad	 14
$LL3@jpeg_load:

; 354  : 		int white = 255 - js[x * 4 + 3];

  002a0	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _js$1[ebp]
  002a6	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  002ab	0f b6 44 b0 03	 movzx	 eax, BYTE PTR [eax+esi*4+3]
  002b0	2b d0		 sub	 edx, eax

; 355  : 		line[x].a = 255;

  002b2	c6 04 b3 ff	 mov	 BYTE PTR [ebx+esi*4], 255 ; 000000ffH

; 356  : 		line[x].r = white - ((js[x * 4] * white) >> 8);

  002b6	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _js$1[ebp]
  002bc	0f b6 0c b0	 movzx	 ecx, BYTE PTR [eax+esi*4]
  002c0	8a c2		 mov	 al, dl
  002c2	0f af ca	 imul	 ecx, edx
  002c5	c1 f9 08	 sar	 ecx, 8
  002c8	2a c1		 sub	 al, cl
  002ca	88 44 b3 01	 mov	 BYTE PTR [ebx+esi*4+1], al

; 357  : 		line[x].g = white - ((js[x * 4 + 1] * white) >> 8);

  002ce	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _js$1[ebp]
  002d4	0f b6 4c b0 01	 movzx	 ecx, BYTE PTR [eax+esi*4+1]
  002d9	8a c2		 mov	 al, dl
  002db	0f af ca	 imul	 ecx, edx
  002de	c1 f9 08	 sar	 ecx, 8
  002e1	2a c1		 sub	 al, cl
  002e3	88 44 b3 02	 mov	 BYTE PTR [ebx+esi*4+2], al

; 358  : 		line[x].b = white - ((js[x * 4 + 2] * white) >> 8);

  002e7	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _js$1[ebp]
  002ed	0f b6 44 b0 02	 movzx	 eax, BYTE PTR [eax+esi*4+2]
  002f2	0f af c2	 imul	 eax, edx
  002f5	c1 f8 08	 sar	 eax, 8
  002f8	2a d0		 sub	 dl, al
  002fa	88 54 b3 03	 mov	 BYTE PTR [ebx+esi*4+3], dl
  002fe	46		 inc	 esi
  002ff	3b f7		 cmp	 esi, edi
  00301	7c 9d		 jl	 SHORT $LL3@jpeg_load
$LN50@jpeg_load:
  00303	8b b5 c0 fd ff
	ff		 mov	 esi, DWORD PTR _scanline$1$[ebp]
$LN23@jpeg_load:

; 319  : 
; 320  :     int y;
; 321  :     for (y=0;y<height;y++) {

  00309	8b 85 b4 fd ff
	ff		 mov	 eax, DWORD PTR _y$1$[ebp]
  0030f	8d 14 bd 00 00
	00 00		 lea	 edx, DWORD PTR [edi*4]
  00316	8b 8d bc fd ff
	ff		 mov	 ecx, DWORD PTR tv1081[ebp]
  0031c	40		 inc	 eax
  0031d	03 ca		 add	 ecx, edx
  0031f	89 85 b4 fd ff
	ff		 mov	 DWORD PTR _y$1$[ebp], eax
  00325	8b 95 b8 fd ff
	ff		 mov	 edx, DWORD PTR _dest$GSCopy$1$[ebp]
  0032b	89 8d bc fd ff
	ff		 mov	 DWORD PTR tv1081[ebp], ecx
  00331	3b 85 ac fd ff
	ff		 cmp	 eax, DWORD PTR _height$1$[ebp]
  00337	0f 8c f3 fd ff
	ff		 jl	 $LL24@jpeg_load
$LN22@jpeg_load:

; 359  : 	    }
; 360  : 	}
; 361  :     }
; 362  : 
; 363  :     free(scanline);

  0033d	56		 push	 esi
  0033e	e8 00 00 00 00	 call	 _free

; 364  : 
; 365  :     jpeg_finish_decompress(&cinfo);

  00343	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00349	50		 push	 eax
  0034a	e8 00 00 00 00	 call	 _jpeg_finish_decompress

; 366  :     jpeg_destroy_decompress(&cinfo);

  0034f	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00355	50		 push	 eax
  00356	e8 00 00 00 00	 call	 _jpeg_destroy_decompress

; 367  :     fclose(fi);

  0035b	ff b5 a4 fd ff
	ff		 push	 DWORD PTR _fi$1$[ebp]
  00361	e8 00 00 00 00	 call	 _fclose
  00366	83 c4 10	 add	 esp, 16			; 00000010H

; 368  :     return 1;

  00369	b8 01 00 00 00	 mov	 eax, 1
  0036e	5f		 pop	 edi
  0036f	5e		 pop	 esi
  00370	5b		 pop	 ebx

; 369  : }

  00371	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00374	33 cd		 xor	 ecx, ebp
  00376	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0037b	8b e5		 mov	 esp, ebp
  0037d	5d		 pop	 ebp
  0037e	c3		 ret	 0
$LN33@jpeg_load:

; 340  : 	    fprintf(stderr, "Error: Can't convert YCCK to RGB.\n");

  0037f	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@HHOHJMLB@Error?3?5Can?8t?5convert?5YCCK?5to?5RGB@
  00384	e8 00 00 00 00	 call	 ___iob_func
  00389	83 c0 40	 add	 eax, 64			; 00000040H
  0038c	50		 push	 eax
  0038d	e8 00 00 00 00	 call	 _fprintf

; 369  : }

  00392	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00395	83 c4 08	 add	 esp, 8
  00398	33 cd		 xor	 ecx, ebp
  0039a	33 c0		 xor	 eax, eax
  0039c	5f		 pop	 edi
  0039d	5e		 pop	 esi
  0039e	5b		 pop	 ebx
  0039f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003a4	8b e5		 mov	 esp, ebp
  003a6	5d		 pop	 ebp
  003a7	c3		 ret	 0
?jpeg_load@@YAHPBDPAPAEPAH2@Z ENDP			; jpeg_load
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\jpegfile.cpp
;	COMDAT ?jpeg_save_to_mem@@YAHPAEHHH0H@Z
_TEXT	SEGMENT
_mgr$ = -520						; size = 20
_data2$1 = -500						; size = 4
_cinfo$ = -496						; size = 360
_jerr$ = -136						; size = 132
__$ArrayPad$ = -4					; size = 4
_data$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_quality$ = 20						; size = 4
__dest$ = 24						; size = 4
__destlen$ = 28						; size = 4
?jpeg_save_to_mem@@YAHPAEHHH0H@Z PROC			; jpeg_save_to_mem, COMDAT

; 172  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 02 00
	00		 sub	 esp, 520		; 00000208H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _width$[ebp]

; 173  :   struct jpeg_destination_mgr mgr;
; 174  :   struct jpeg_compress_struct cinfo;
; 175  :   struct jpeg_error_mgr jerr;
; 176  :   int t;
; 177  : 
; 178  :   memset(&cinfo, 0, sizeof(cinfo));

  00017	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0001d	56		 push	 esi
  0001e	8b 75 08	 mov	 esi, DWORD PTR _data$[ebp]
  00021	57		 push	 edi
  00022	68 68 01 00 00	 push	 360			; 00000168H
  00027	6a 00		 push	 0
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _memset

; 179  :   memset(&jerr, 0, sizeof(jerr));

  0002f	68 84 00 00 00	 push	 132			; 00000084H
  00034	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp]
  0003a	6a 00		 push	 0
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _memset

; 180  :   memset(&mgr, 0, sizeof(mgr));
; 181  :   cinfo.err = jpeg_std_error(&jerr);

  00042	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp]
  00048	c7 85 08 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+16], 0
  00052	0f 57 c0	 xorps	 xmm0, xmm0
  00055	50		 push	 eax
  00056	f3 0f 7f 85 f8
	fd ff ff	 movdqu	 XMMWORD PTR _mgr$[ebp], xmm0
  0005e	e8 00 00 00 00	 call	 _jpeg_std_error

; 182  :   jpeg_create_compress(&cinfo);

  00063	68 68 01 00 00	 push	 360			; 00000168H
  00068	89 85 10 fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp], eax
  0006e	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00074	6a 3e		 push	 62			; 0000003eH
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _jpeg_CreateCompress

; 183  : 
; 184  :   dest = _dest;

  0007c	8b 45 18	 mov	 eax, DWORD PTR __dest$[ebp]

; 185  :   len = 0;
; 186  :   destlen = _destlen;
; 187  : 
; 188  :   mgr.init_destination = mem_init_destination;
; 189  :   mgr.empty_output_buffer = mem_empty_output_buffer;
; 190  :   mgr.term_destination = mem_term_destination;
; 191  :   cinfo.dest = &mgr;
; 192  : 
; 193  :   // init compression
; 194  :   
; 195  :   cinfo.image_width  = width;
; 196  :   cinfo.image_height = height;

  0007f	8b 7d 10	 mov	 edi, DWORD PTR _height$[ebp]
  00082	a3 00 00 00 00	 mov	 DWORD PTR _dest, eax
  00087	8b 45 1c	 mov	 eax, DWORD PTR __destlen$[ebp]
  0008a	a3 00 00 00 00	 mov	 DWORD PTR _destlen, eax
  0008f	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _mgr$[ebp]
  00095	89 85 28 fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+24], eax

; 197  :   cinfo.input_components = 3;
; 198  :   cinfo.in_color_space = JCS_RGB;
; 199  :   jpeg_set_defaults(&cinfo);

  0009b	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000a1	50		 push	 eax
  000a2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _len, 0
  000ac	c7 85 00 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+8], OFFSET ?mem_init_destination@@YAXPAUjpeg_compress_struct@@@Z ; mem_init_destination
  000b6	c7 85 04 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+12], OFFSET ?mem_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z ; mem_empty_output_buffer
  000c0	c7 85 08 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+16], OFFSET ?mem_term_destination@@YAXPAUjpeg_compress_struct@@@Z ; mem_term_destination
  000ca	89 9d 2c fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+28], ebx
  000d0	89 bd 30 fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+32], edi
  000d6	c7 85 34 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+36], 3
  000e0	c7 85 38 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+40], 2
  000ea	e8 00 00 00 00	 call	 _jpeg_set_defaults

; 200  :   cinfo.dct_method = JDCT_IFAST;
; 201  :   jpeg_set_quality(&cinfo,quality,TRUE);

  000ef	6a 01		 push	 1
  000f1	ff 75 14	 push	 DWORD PTR _quality$[ebp]
  000f4	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000fa	c7 85 c8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+184], 1
  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 _jpeg_set_quality

; 202  : 
; 203  :   jpeg_start_compress(&cinfo, FALSE);

  0010a	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00110	6a 00		 push	 0
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 _jpeg_start_compress
  00118	83 c4 40	 add	 esp, 64			; 00000040H

; 204  :   for(t=0;t<height;t++) {

  0011b	85 ff		 test	 edi, edi
  0011d	7e 26		 jle	 SHORT $LN1@jpeg_save_
  0011f	8d 1c 5b	 lea	 ebx, DWORD PTR [ebx+ebx*2]
$LL3@jpeg_save_:

; 205  :     unsigned char*data2 = &data[width*3*t];
; 206  :     jpeg_write_scanlines(&cinfo, &data2, 1);

  00122	6a 01		 push	 1
  00124	8d 85 0c fe ff
	ff		 lea	 eax, DWORD PTR _data2$1[ebp]
  0012a	89 b5 0c fe ff
	ff		 mov	 DWORD PTR _data2$1[ebp], esi
  00130	50		 push	 eax
  00131	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 _jpeg_write_scanlines
  0013d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00140	03 f3		 add	 esi, ebx
  00142	4f		 dec	 edi
  00143	75 dd		 jne	 SHORT $LL3@jpeg_save_
$LN1@jpeg_save_:

; 207  :   }
; 208  :   jpeg_finish_compress(&cinfo);

  00145	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0014b	50		 push	 eax
  0014c	e8 00 00 00 00	 call	 _jpeg_finish_compress

; 209  :   jpeg_destroy_compress(&cinfo);

  00151	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00157	50		 push	 eax
  00158	e8 00 00 00 00	 call	 _jpeg_destroy_compress

; 210  :   return len;
; 211  : }

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	83 c4 08	 add	 esp, 8
  00163	a1 00 00 00 00	 mov	 eax, DWORD PTR _len
  00168	33 cd		 xor	 ecx, ebp
  0016a	5f		 pop	 edi
  0016b	5e		 pop	 esi
  0016c	5b		 pop	 ebx
  0016d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c3		 ret	 0
?jpeg_save_to_mem@@YAHPAEHHH0H@Z ENDP			; jpeg_save_to_mem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\jpegfile.cpp
;	COMDAT ?jpeg_save_to_file@@YAHPAEHHHPAU_iobuf@@@Z
_TEXT	SEGMENT
_mgr$ = -520						; size = 20
_data2$1 = -500						; size = 4
_cinfo$ = -496						; size = 360
_jerr$ = -136						; size = 132
__$ArrayPad$ = -4					; size = 4
_data$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_quality$ = 20						; size = 4
__fi$ = 24						; size = 4
?jpeg_save_to_file@@YAHPAEHHHPAU_iobuf@@@Z PROC		; jpeg_save_to_file, COMDAT

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 02 00
	00		 sub	 esp, 520		; 00000208H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 130  :   struct jpeg_destination_mgr mgr;
; 131  :   struct jpeg_compress_struct cinfo;
; 132  :   struct jpeg_error_mgr jerr;
; 133  :   int t;
; 134  : 
; 135  :   fi = _fi;

  00013	8b 45 18	 mov	 eax, DWORD PTR __fi$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _width$[ebp]
  0001a	56		 push	 esi
  0001b	8b 75 08	 mov	 esi, DWORD PTR _data$[ebp]
  0001e	57		 push	 edi

; 136  : 
; 137  :   memset(&cinfo, 0, sizeof(cinfo));

  0001f	68 68 01 00 00	 push	 360			; 00000168H
  00024	a3 00 00 00 00	 mov	 DWORD PTR _fi, eax
  00029	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0002f	6a 00		 push	 0
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _memset

; 138  :   memset(&jerr, 0, sizeof(jerr));

  00037	68 84 00 00 00	 push	 132			; 00000084H
  0003c	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp]
  00042	6a 00		 push	 0
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _memset

; 139  :   memset(&mgr, 0, sizeof(mgr));
; 140  :   cinfo.err = jpeg_std_error(&jerr);

  0004a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp]
  00050	c7 85 08 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+16], 0
  0005a	0f 57 c0	 xorps	 xmm0, xmm0
  0005d	50		 push	 eax
  0005e	f3 0f 7f 85 f8
	fd ff ff	 movdqu	 XMMWORD PTR _mgr$[ebp], xmm0
  00066	e8 00 00 00 00	 call	 _jpeg_std_error

; 141  :   jpeg_create_compress(&cinfo);

  0006b	68 68 01 00 00	 push	 360			; 00000168H
  00070	89 85 10 fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp], eax
  00076	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0007c	6a 3e		 push	 62			; 0000003eH
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _jpeg_CreateCompress

; 142  : 
; 143  :   mgr.init_destination = file_init_destination;
; 144  :   mgr.empty_output_buffer = file_empty_output_buffer;
; 145  :   mgr.term_destination = file_term_destination;
; 146  :   cinfo.dest = &mgr;
; 147  : 
; 148  :   // init compression
; 149  :   
; 150  :   cinfo.image_width  = width;
; 151  :   cinfo.image_height = height;

  00084	8b 7d 10	 mov	 edi, DWORD PTR _height$[ebp]
  00087	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _mgr$[ebp]
  0008d	89 85 28 fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+24], eax

; 152  :   cinfo.input_components = 3;
; 153  :   cinfo.in_color_space = JCS_RGB;
; 154  :   jpeg_set_defaults(&cinfo);

  00093	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00099	50		 push	 eax
  0009a	c7 85 00 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+8], OFFSET ?file_init_destination@@YAXPAUjpeg_compress_struct@@@Z ; file_init_destination
  000a4	c7 85 04 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+12], OFFSET ?file_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z ; file_empty_output_buffer
  000ae	c7 85 08 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+16], OFFSET ?file_term_destination@@YAXPAUjpeg_compress_struct@@@Z ; file_term_destination
  000b8	89 9d 2c fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+28], ebx
  000be	89 bd 30 fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+32], edi
  000c4	c7 85 34 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+36], 3
  000ce	c7 85 38 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+40], 2
  000d8	e8 00 00 00 00	 call	 _jpeg_set_defaults

; 155  :   cinfo.dct_method = JDCT_IFAST;
; 156  :   jpeg_set_quality(&cinfo,quality,TRUE);

  000dd	6a 01		 push	 1
  000df	ff 75 14	 push	 DWORD PTR _quality$[ebp]
  000e2	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000e8	c7 85 c8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+184], 1
  000f2	50		 push	 eax
  000f3	e8 00 00 00 00	 call	 _jpeg_set_quality

; 157  : 
; 158  :   //jpeg_write_tables(&cinfo);
; 159  :   //jpeg_suppress_tables(&cinfo, TRUE);
; 160  :   jpeg_start_compress(&cinfo, FALSE);

  000f8	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000fe	6a 00		 push	 0
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 _jpeg_start_compress
  00106	83 c4 40	 add	 esp, 64			; 00000040H

; 161  :   
; 162  :   for(t=0;t<height;t++) {

  00109	85 ff		 test	 edi, edi
  0010b	7e 26		 jle	 SHORT $LN1@jpeg_save_
  0010d	8d 1c 5b	 lea	 ebx, DWORD PTR [ebx+ebx*2]
$LL3@jpeg_save_:

; 163  :     unsigned char*data2 = &data[width*3*t];
; 164  :     jpeg_write_scanlines(&cinfo, &data2, 1);

  00110	6a 01		 push	 1
  00112	8d 85 0c fe ff
	ff		 lea	 eax, DWORD PTR _data2$1[ebp]
  00118	89 b5 0c fe ff
	ff		 mov	 DWORD PTR _data2$1[ebp], esi
  0011e	50		 push	 eax
  0011f	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 _jpeg_write_scanlines
  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012e	03 f3		 add	 esi, ebx
  00130	4f		 dec	 edi
  00131	75 dd		 jne	 SHORT $LL3@jpeg_save_
$LN1@jpeg_save_:

; 165  :   }
; 166  :   jpeg_finish_compress(&cinfo);

  00133	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00139	50		 push	 eax
  0013a	e8 00 00 00 00	 call	 _jpeg_finish_compress

; 167  :   jpeg_destroy_compress(&cinfo);

  0013f	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 _jpeg_destroy_compress

; 168  :   return 1;
; 169  : }

  0014b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014e	83 c4 08	 add	 esp, 8
  00151	33 cd		 xor	 ecx, ebp
  00153	b8 01 00 00 00	 mov	 eax, 1
  00158	5f		 pop	 edi
  00159	5e		 pop	 esi
  0015a	5b		 pop	 ebx
  0015b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c3		 ret	 0
?jpeg_save_to_file@@YAHPAEHHHPAU_iobuf@@@Z ENDP		; jpeg_save_to_file
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\jpegfile.cpp
;	COMDAT ?jpeg_save@@YAHPAEHHHPBD@Z
_TEXT	SEGMENT
_mgr$ = -520						; size = 20
_data2$1 = -500						; size = 4
_cinfo$ = -496						; size = 360
_jerr$ = -136						; size = 132
__$ArrayPad$ = -4					; size = 4
_data$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_quality$ = 20						; size = 4
_filename$ = 24						; size = 4
?jpeg_save@@YAHPAEHHHPBD@Z PROC				; jpeg_save, COMDAT

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 02 00
	00		 sub	 esp, 520		; 00000208H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 18	 mov	 eax, DWORD PTR _filename$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _width$[ebp]
  0001a	56		 push	 esi
  0001b	8b 75 08	 mov	 esi, DWORD PTR _data$[ebp]

; 80   :   struct jpeg_destination_mgr mgr;
; 81   :   struct jpeg_compress_struct cinfo;
; 82   :   struct jpeg_error_mgr jerr;
; 83   :   int t;
; 84   : 
; 85   :   if(filename) {

  0001e	85 c0		 test	 eax, eax
  00020	74 27		 je	 SHORT $LN7@jpeg_save

; 86   :     fi = fopen(filename, "wb");

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb?$AA@
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _fopen
  0002d	83 c4 08	 add	 esp, 8
  00030	a3 00 00 00 00	 mov	 DWORD PTR _fi, eax

; 87   : 	if(fi == NULL)

  00035	85 c0		 test	 eax, eax
  00037	75 1a		 jne	 SHORT $LN5@jpeg_save
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx

; 125  :   return 1;
; 126  : }

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003e	33 cd		 xor	 ecx, ebp
  00040	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
$LN7@jpeg_save:

; 88   : 		return 0;
; 89   :   } else
; 90   :     fi = NULL;

  00049	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _fi, 0
$LN5@jpeg_save:
  00053	57		 push	 edi

; 91   : 
; 92   :   memset(&cinfo, 0, sizeof(cinfo));

  00054	68 68 01 00 00	 push	 360			; 00000168H
  00059	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0005f	6a 00		 push	 0
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _memset

; 93   :   memset(&jerr, 0, sizeof(jerr));

  00067	68 84 00 00 00	 push	 132			; 00000084H
  0006c	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp]
  00072	6a 00		 push	 0
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 _memset

; 94   :   memset(&mgr, 0, sizeof(mgr));
; 95   :   cinfo.err = jpeg_std_error(&jerr);

  0007a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _jerr$[ebp]
  00080	c7 85 08 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+16], 0
  0008a	0f 57 c0	 xorps	 xmm0, xmm0
  0008d	50		 push	 eax
  0008e	f3 0f 7f 85 f8
	fd ff ff	 movdqu	 XMMWORD PTR _mgr$[ebp], xmm0
  00096	e8 00 00 00 00	 call	 _jpeg_std_error

; 96   :   jpeg_create_compress(&cinfo);

  0009b	68 68 01 00 00	 push	 360			; 00000168H
  000a0	89 85 10 fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp], eax
  000a6	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000ac	6a 3e		 push	 62			; 0000003eH
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 _jpeg_CreateCompress

; 97   : 
; 98   :   mgr.init_destination = file_init_destination;
; 99   :   mgr.empty_output_buffer = file_empty_output_buffer;
; 100  :   mgr.term_destination = file_term_destination;
; 101  :   cinfo.dest = &mgr;
; 102  : 
; 103  :   // init compression
; 104  :   
; 105  :   cinfo.image_width  = width;
; 106  :   cinfo.image_height = height;

  000b4	8b 7d 10	 mov	 edi, DWORD PTR _height$[ebp]
  000b7	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _mgr$[ebp]
  000bd	89 85 28 fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+24], eax

; 107  :   cinfo.input_components = 3;
; 108  :   cinfo.in_color_space = JCS_RGB;
; 109  :   jpeg_set_defaults(&cinfo);

  000c3	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000c9	50		 push	 eax
  000ca	c7 85 00 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+8], OFFSET ?file_init_destination@@YAXPAUjpeg_compress_struct@@@Z ; file_init_destination
  000d4	c7 85 04 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+12], OFFSET ?file_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z ; file_empty_output_buffer
  000de	c7 85 08 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+16], OFFSET ?file_term_destination@@YAXPAUjpeg_compress_struct@@@Z ; file_term_destination
  000e8	89 9d 2c fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+28], ebx
  000ee	89 bd 30 fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+32], edi
  000f4	c7 85 34 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+36], 3
  000fe	c7 85 38 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+40], 2
  00108	e8 00 00 00 00	 call	 _jpeg_set_defaults

; 110  :   jpeg_set_quality(&cinfo,quality,TRUE);

  0010d	6a 01		 push	 1
  0010f	ff 75 14	 push	 DWORD PTR _quality$[ebp]
  00112	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 _jpeg_set_quality

; 111  : 
; 112  :   //jpeg_write_tables(&cinfo);
; 113  :   //jpeg_suppress_tables(&cinfo, TRUE);
; 114  :   jpeg_start_compress(&cinfo, FALSE);

  0011e	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00124	6a 00		 push	 0
  00126	50		 push	 eax
  00127	e8 00 00 00 00	 call	 _jpeg_start_compress
  0012c	83 c4 40	 add	 esp, 64			; 00000040H

; 115  :   
; 116  :   for(t=0;t<height;t++) {

  0012f	85 ff		 test	 edi, edi
  00131	7e 30		 jle	 SHORT $LN2@jpeg_save

; 91   : 
; 92   :   memset(&cinfo, 0, sizeof(cinfo));

  00133	8d 1c 5b	 lea	 ebx, DWORD PTR [ebx+ebx*2]
  00136	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL4@jpeg_save:

; 117  :     unsigned char*data2 = &data[width*3*t];
; 118  :     jpeg_write_scanlines(&cinfo, &data2, 1);

  00140	6a 01		 push	 1
  00142	8d 85 0c fe ff
	ff		 lea	 eax, DWORD PTR _data2$1[ebp]
  00148	89 b5 0c fe ff
	ff		 mov	 DWORD PTR _data2$1[ebp], esi
  0014e	50		 push	 eax
  0014f	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 _jpeg_write_scanlines
  0015b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015e	03 f3		 add	 esi, ebx
  00160	4f		 dec	 edi
  00161	75 dd		 jne	 SHORT $LL4@jpeg_save
$LN2@jpeg_save:

; 119  :   }
; 120  :   jpeg_finish_compress(&cinfo);

  00163	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00169	50		 push	 eax
  0016a	e8 00 00 00 00	 call	 _jpeg_finish_compress

; 121  : 
; 122  :   if(fi)

  0016f	a1 00 00 00 00	 mov	 eax, DWORD PTR _fi
  00174	83 c4 04	 add	 esp, 4
  00177	5f		 pop	 edi
  00178	85 c0		 test	 eax, eax
  0017a	74 09		 je	 SHORT $LN1@jpeg_save

; 123  :     fclose(fi);

  0017c	50		 push	 eax
  0017d	e8 00 00 00 00	 call	 _fclose
  00182	83 c4 04	 add	 esp, 4
$LN1@jpeg_save:

; 124  :   jpeg_destroy_compress(&cinfo);

  00185	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0018b	50		 push	 eax
  0018c	e8 00 00 00 00	 call	 _jpeg_destroy_compress

; 125  :   return 1;
; 126  : }

  00191	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00194	83 c4 04	 add	 esp, 4
  00197	33 cd		 xor	 ecx, ebp
  00199	b8 01 00 00 00	 mov	 eax, 1
  0019e	5e		 pop	 esi
  0019f	5b		 pop	 ebx
  001a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a5	8b e5		 mov	 esp, ebp
  001a7	5d		 pop	 ebp
  001a8	c3		 ret	 0
?jpeg_save@@YAHPAEHHHPBD@Z ENDP				; jpeg_save
_TEXT	ENDS
END
