; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\GamePackages\Client\Tools\Patcher2017\EterLib\CollisionData.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_gc_fReduceMove DD 03f000000r			; 0.5
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	_fabsf
PUBLIC	_sqrtf
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z			; D3DXVECTOR3::operator+=
PUBLIC	??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator+
PUBLIC	??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator-
PUBLIC	??DD3DXVECTOR3@@QBE?AU0@M@Z			; D3DXVECTOR3::operator*
PUBLIC	??KD3DXVECTOR3@@QBE?AU0@M@Z			; D3DXVECTOR3::operator/
PUBLIC	??D@YA?AUD3DXVECTOR3@@MABU0@@Z			; operator*
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
PUBLIC	??DD3DXMATRIX@@QBE?AU0@ABU0@@Z			; D3DXMATRIX::operator*
PUBLIC	?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z		; D3DXVec3Length
PUBLIC	?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z	; D3DXVec3LengthSq
PUBLIC	?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z		; D3DXVec3Dot
PUBLIC	?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z	; D3DXVec3Cross
PUBLIC	?D3DXMatrixIdentity@@YAPAUD3DXMATRIX@@PAU1@@Z	; D3DXMatrixIdentity
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	??0SSphereData@@QAE@XZ				; SSphereData::SSphereData
PUBLIC	??0SPlaneData@@QAE@XZ				; SPlaneData::SPlaneData
PUBLIC	??0SAABBData@@QAE@XZ				; SAABBData::SAABBData
PUBLIC	??0SOBBData@@QAE@XZ				; SOBBData::SOBBData
PUBLIC	??0SCylinderData@@QAE@XZ			; SCylinderData::SCylinderData
PUBLIC	?DestroyCollisionInstanceSystem@@YAXXZ		; DestroyCollisionInstanceSystem
PUBLIC	?Destroy@CBaseCollisionInstance@@QAEXXZ		; CBaseCollisionInstance::Destroy
PUBLIC	?BuildCollisionInstance@CBaseCollisionInstance@@SAPAV1@PBVCStaticCollisionData@@PBUD3DXMATRIX@@@Z ; CBaseCollisionInstance::BuildCollisionInstance
PUBLIC	??0CBaseCollisionInstance@@QAE@XZ		; CBaseCollisionInstance::CBaseCollisionInstance
PUBLIC	?GetAttribute@CSphereCollisionInstance@@QAEAAUSSphereData@@XZ ; CSphereCollisionInstance::GetAttribute
PUBLIC	?GetAttribute@CSphereCollisionInstance@@QBEABUSSphereData@@XZ ; CSphereCollisionInstance::GetAttribute
PUBLIC	?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ; CSphereCollisionInstance::Render
PUBLIC	?OnDestroy@CSphereCollisionInstance@@MAEXXZ	; CSphereCollisionInstance::OnDestroy
PUBLIC	?OnMovementCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CSphereCollisionInstance::OnMovementCollisionDynamicSphere
PUBLIC	?OnCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CSphereCollisionInstance::OnCollisionDynamicSphere
PUBLIC	?OnGetCollisionMovementAdjust@CSphereCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ; CSphereCollisionInstance::OnGetCollisionMovementAdjust
PUBLIC	??0CSphereCollisionInstance@@QAE@XZ		; CSphereCollisionInstance::CSphereCollisionInstance
PUBLIC	?GetAttribute@CPlaneCollisionInstance@@QAEAAUSPlaneData@@XZ ; CPlaneCollisionInstance::GetAttribute
PUBLIC	?GetAttribute@CPlaneCollisionInstance@@QBEABUSPlaneData@@XZ ; CPlaneCollisionInstance::GetAttribute
PUBLIC	?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ; CPlaneCollisionInstance::Render
PUBLIC	?OnDestroy@CPlaneCollisionInstance@@MAEXXZ	; CPlaneCollisionInstance::OnDestroy
PUBLIC	?OnMovementCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CPlaneCollisionInstance::OnMovementCollisionDynamicSphere
PUBLIC	?OnCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CPlaneCollisionInstance::OnCollisionDynamicSphere
PUBLIC	?OnGetCollisionMovementAdjust@CPlaneCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ; CPlaneCollisionInstance::OnGetCollisionMovementAdjust
PUBLIC	??0CPlaneCollisionInstance@@QAE@XZ		; CPlaneCollisionInstance::CPlaneCollisionInstance
PUBLIC	?GetAttribute@CAABBCollisionInstance@@QAEAAUSAABBData@@XZ ; CAABBCollisionInstance::GetAttribute
PUBLIC	?GetAttribute@CAABBCollisionInstance@@QBEABUSAABBData@@XZ ; CAABBCollisionInstance::GetAttribute
PUBLIC	?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ; CAABBCollisionInstance::Render
PUBLIC	?OnDestroy@CAABBCollisionInstance@@MAEXXZ	; CAABBCollisionInstance::OnDestroy
PUBLIC	?OnMovementCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CAABBCollisionInstance::OnMovementCollisionDynamicSphere
PUBLIC	?OnCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CAABBCollisionInstance::OnCollisionDynamicSphere
PUBLIC	?OnGetCollisionMovementAdjust@CAABBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ; CAABBCollisionInstance::OnGetCollisionMovementAdjust
PUBLIC	??0CAABBCollisionInstance@@QAE@XZ		; CAABBCollisionInstance::CAABBCollisionInstance
PUBLIC	?GetAttribute@COBBCollisionInstance@@QAEAAUSOBBData@@XZ ; COBBCollisionInstance::GetAttribute
PUBLIC	?GetAttribute@COBBCollisionInstance@@QBEABUSOBBData@@XZ ; COBBCollisionInstance::GetAttribute
PUBLIC	?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ; COBBCollisionInstance::Render
PUBLIC	?OnDestroy@COBBCollisionInstance@@MAEXXZ	; COBBCollisionInstance::OnDestroy
PUBLIC	?OnMovementCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; COBBCollisionInstance::OnMovementCollisionDynamicSphere
PUBLIC	?OnCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; COBBCollisionInstance::OnCollisionDynamicSphere
PUBLIC	?OnGetCollisionMovementAdjust@COBBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ; COBBCollisionInstance::OnGetCollisionMovementAdjust
PUBLIC	??0COBBCollisionInstance@@QAE@XZ		; COBBCollisionInstance::COBBCollisionInstance
PUBLIC	?GetAttribute@CCylinderCollisionInstance@@QAEAAUSCylinderData@@XZ ; CCylinderCollisionInstance::GetAttribute
PUBLIC	?GetAttribute@CCylinderCollisionInstance@@QBEABUSCylinderData@@XZ ; CCylinderCollisionInstance::GetAttribute
PUBLIC	?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ; CCylinderCollisionInstance::Render
PUBLIC	?OnDestroy@CCylinderCollisionInstance@@MAEXXZ	; CCylinderCollisionInstance::OnDestroy
PUBLIC	?OnMovementCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CCylinderCollisionInstance::OnMovementCollisionDynamicSphere
PUBLIC	?OnCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CCylinderCollisionInstance::OnCollisionDynamicSphere
PUBLIC	?OnGetCollisionMovementAdjust@CCylinderCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ; CCylinderCollisionInstance::OnGetCollisionMovementAdjust
PUBLIC	?CollideCylinderVSDynamicSphere@CCylinderCollisionInstance@@IBE_NABUSCylinderData@@ABUCDynamicSphereInstance@@@Z ; CCylinderCollisionInstance::CollideCylinderVSDynamicSphere
PUBLIC	??0CCylinderCollisionInstance@@QAE@XZ		; CCylinderCollisionInstance::CCylinderCollisionInstance
PUBLIC	?GetVector3Distance@@YAMABUD3DXVECTOR3@@0@Z	; GetVector3Distance
PUBLIC	?square_distance_between_linesegment_and_point@@YAMABUD3DXVECTOR3@@00@Z ; square_distance_between_linesegment_and_point
PUBLIC	?Instance@?$CSingleton@VCStateManager@@@@SAAAVCStateManager@@XZ ; CSingleton<CStateManager>::Instance
PUBLIC	??0?$CDynamicPool@VCSphereCollisionInstance@@@@QAE@XZ ; CDynamicPool<CSphereCollisionInstance>::CDynamicPool<CSphereCollisionInstance>
PUBLIC	??1?$CDynamicPool@VCSphereCollisionInstance@@@@UAE@XZ ; CDynamicPool<CSphereCollisionInstance>::~CDynamicPool<CSphereCollisionInstance>
PUBLIC	?Destroy@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEXXZ ; CDynamicPool<CSphereCollisionInstance>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEPAVCSphereCollisionInstance@@XZ ; CDynamicPool<CSphereCollisionInstance>::Alloc
PUBLIC	?Free@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEXPAVCSphereCollisionInstance@@@Z ; CDynamicPool<CSphereCollisionInstance>::Free
PUBLIC	?Delete@?$CDynamicPool@VCSphereCollisionInstance@@@@KAXPAVCSphereCollisionInstance@@@Z ; CDynamicPool<CSphereCollisionInstance>::Delete
PUBLIC	??0?$allocator@PAVCSphereCollisionInstance@@@std@@QAE@XZ ; std::allocator<CSphereCollisionInstance *>::allocator<CSphereCollisionInstance *>
PUBLIC	?deallocate@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEXPAPAVCSphereCollisionInstance@@I@Z ; std::allocator<CSphereCollisionInstance *>::deallocate
PUBLIC	?allocate@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEPAPAVCSphereCollisionInstance@@I@Z ; std::allocator<CSphereCollisionInstance *>::allocate
PUBLIC	?construct@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEXPAPAVCSphereCollisionInstance@@ABQAV3@@Z ; std::allocator<CSphereCollisionInstance *>::construct
PUBLIC	?max_size@?$allocator@PAVCSphereCollisionInstance@@@std@@QBEIXZ ; std::allocator<CSphereCollisionInstance *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@SAIABV?$allocator@PAVCSphereCollisionInstance@@@2@@Z ; std::allocator_traits<std::allocator<CSphereCollisionInstance *> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@I@Z ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXPAPAVCSphereCollisionInstance@@I@Z ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> >::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCSphereCollisionInstance@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> > >::_Getal
PUBLIC	??0?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE@XZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >
PUBLIC	??1?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE@XZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::~vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >
PUBLIC	?capacity@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBEIXZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::capacity
PUBLIC	?_Unused_capacity@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBEIXZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Unused_capacity
PUBLIC	?begin@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@2@XZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::begin
PUBLIC	?end@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@2@XZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::end
PUBLIC	?size@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBEIXZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::size
PUBLIC	?max_size@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBEIXZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::max_size
PUBLIC	?empty@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBE_NXZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::empty
PUBLIC	?back@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEAAPAVCSphereCollisionInstance@@XZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::back
PUBLIC	?push_back@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXABQAVCSphereCollisionInstance@@@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::push_back
PUBLIC	?pop_back@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::pop_back
PUBLIC	?clear@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXPAPAVCSphereCollisionInstance@@0@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IBEII@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Grow_to
PUBLIC	?_Inside@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IBE_NPBQAVCSphereCollisionInstance@@@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Inside
PUBLIC	?_Reallocate@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Reserve
PUBLIC	?_Tidy@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXXZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Tidy
PUBLIC	?_Xlen@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IBEXXZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IBEXPAPAVCSphereCollisionInstance@@0@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Orphan_range
PUBLIC	??_G?$CDynamicPool@VCSphereCollisionInstance@@@@UAEPAXI@Z ; CDynamicPool<CSphereCollisionInstance>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPool@VCCylinderCollisionInstance@@@@QAE@XZ ; CDynamicPool<CCylinderCollisionInstance>::CDynamicPool<CCylinderCollisionInstance>
PUBLIC	??1?$CDynamicPool@VCCylinderCollisionInstance@@@@UAE@XZ ; CDynamicPool<CCylinderCollisionInstance>::~CDynamicPool<CCylinderCollisionInstance>
PUBLIC	?Destroy@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEXXZ ; CDynamicPool<CCylinderCollisionInstance>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEPAVCCylinderCollisionInstance@@XZ ; CDynamicPool<CCylinderCollisionInstance>::Alloc
PUBLIC	?Free@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEXPAVCCylinderCollisionInstance@@@Z ; CDynamicPool<CCylinderCollisionInstance>::Free
PUBLIC	?Delete@?$CDynamicPool@VCCylinderCollisionInstance@@@@KAXPAVCCylinderCollisionInstance@@@Z ; CDynamicPool<CCylinderCollisionInstance>::Delete
PUBLIC	??0?$allocator@PAVCCylinderCollisionInstance@@@std@@QAE@XZ ; std::allocator<CCylinderCollisionInstance *>::allocator<CCylinderCollisionInstance *>
PUBLIC	?deallocate@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEXPAPAVCCylinderCollisionInstance@@I@Z ; std::allocator<CCylinderCollisionInstance *>::deallocate
PUBLIC	?allocate@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEPAPAVCCylinderCollisionInstance@@I@Z ; std::allocator<CCylinderCollisionInstance *>::allocate
PUBLIC	?construct@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEXPAPAVCCylinderCollisionInstance@@ABQAV3@@Z ; std::allocator<CCylinderCollisionInstance *>::construct
PUBLIC	?max_size@?$allocator@PAVCCylinderCollisionInstance@@@std@@QBEIXZ ; std::allocator<CCylinderCollisionInstance *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@SAIABV?$allocator@PAVCCylinderCollisionInstance@@@2@@Z ; std::allocator_traits<std::allocator<CCylinderCollisionInstance *> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@I@Z ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXPAPAVCCylinderCollisionInstance@@I@Z ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> >::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCCylinderCollisionInstance@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> > >::_Getal
PUBLIC	??0?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE@XZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >
PUBLIC	??1?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE@XZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::~vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >
PUBLIC	?capacity@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBEIXZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::capacity
PUBLIC	?_Unused_capacity@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBEIXZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Unused_capacity
PUBLIC	?begin@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@2@XZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::begin
PUBLIC	?end@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@2@XZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::end
PUBLIC	?size@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBEIXZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::size
PUBLIC	?max_size@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBEIXZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::max_size
PUBLIC	?empty@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBE_NXZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::empty
PUBLIC	?back@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEAAPAVCCylinderCollisionInstance@@XZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::back
PUBLIC	?push_back@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXABQAVCCylinderCollisionInstance@@@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::push_back
PUBLIC	?pop_back@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::pop_back
PUBLIC	?clear@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXPAPAVCCylinderCollisionInstance@@0@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IBEII@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Grow_to
PUBLIC	?_Inside@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IBE_NPBQAVCCylinderCollisionInstance@@@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Inside
PUBLIC	?_Reallocate@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Reserve
PUBLIC	?_Tidy@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXXZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Tidy
PUBLIC	?_Xlen@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IBEXXZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IBEXPAPAVCCylinderCollisionInstance@@0@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Orphan_range
PUBLIC	??_G?$CDynamicPool@VCCylinderCollisionInstance@@@@UAEPAXI@Z ; CDynamicPool<CCylinderCollisionInstance>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPool@VCPlaneCollisionInstance@@@@QAE@XZ ; CDynamicPool<CPlaneCollisionInstance>::CDynamicPool<CPlaneCollisionInstance>
PUBLIC	??1?$CDynamicPool@VCPlaneCollisionInstance@@@@UAE@XZ ; CDynamicPool<CPlaneCollisionInstance>::~CDynamicPool<CPlaneCollisionInstance>
PUBLIC	?Destroy@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEXXZ ; CDynamicPool<CPlaneCollisionInstance>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEPAVCPlaneCollisionInstance@@XZ ; CDynamicPool<CPlaneCollisionInstance>::Alloc
PUBLIC	?Free@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEXPAVCPlaneCollisionInstance@@@Z ; CDynamicPool<CPlaneCollisionInstance>::Free
PUBLIC	?Delete@?$CDynamicPool@VCPlaneCollisionInstance@@@@KAXPAVCPlaneCollisionInstance@@@Z ; CDynamicPool<CPlaneCollisionInstance>::Delete
PUBLIC	??0?$allocator@PAVCPlaneCollisionInstance@@@std@@QAE@XZ ; std::allocator<CPlaneCollisionInstance *>::allocator<CPlaneCollisionInstance *>
PUBLIC	?deallocate@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEXPAPAVCPlaneCollisionInstance@@I@Z ; std::allocator<CPlaneCollisionInstance *>::deallocate
PUBLIC	?allocate@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEPAPAVCPlaneCollisionInstance@@I@Z ; std::allocator<CPlaneCollisionInstance *>::allocate
PUBLIC	?construct@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEXPAPAVCPlaneCollisionInstance@@ABQAV3@@Z ; std::allocator<CPlaneCollisionInstance *>::construct
PUBLIC	?max_size@?$allocator@PAVCPlaneCollisionInstance@@@std@@QBEIXZ ; std::allocator<CPlaneCollisionInstance *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@SAIABV?$allocator@PAVCPlaneCollisionInstance@@@2@@Z ; std::allocator_traits<std::allocator<CPlaneCollisionInstance *> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@I@Z ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXPAPAVCPlaneCollisionInstance@@I@Z ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> >::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCPlaneCollisionInstance@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> > >::_Getal
PUBLIC	??0?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE@XZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >
PUBLIC	??1?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE@XZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::~vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >
PUBLIC	?capacity@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBEIXZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::capacity
PUBLIC	?_Unused_capacity@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBEIXZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Unused_capacity
PUBLIC	?begin@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@2@XZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::begin
PUBLIC	?end@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@2@XZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::end
PUBLIC	?size@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBEIXZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::size
PUBLIC	?max_size@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBEIXZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::max_size
PUBLIC	?empty@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBE_NXZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::empty
PUBLIC	?back@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEAAPAVCPlaneCollisionInstance@@XZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::back
PUBLIC	?push_back@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXABQAVCPlaneCollisionInstance@@@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::push_back
PUBLIC	?pop_back@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::pop_back
PUBLIC	?clear@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXPAPAVCPlaneCollisionInstance@@0@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IBEII@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Grow_to
PUBLIC	?_Inside@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IBE_NPBQAVCPlaneCollisionInstance@@@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Inside
PUBLIC	?_Reallocate@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Reserve
PUBLIC	?_Tidy@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXXZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Tidy
PUBLIC	?_Xlen@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IBEXXZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IBEXPAPAVCPlaneCollisionInstance@@0@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Orphan_range
PUBLIC	??_G?$CDynamicPool@VCPlaneCollisionInstance@@@@UAEPAXI@Z ; CDynamicPool<CPlaneCollisionInstance>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPool@VCAABBCollisionInstance@@@@QAE@XZ ; CDynamicPool<CAABBCollisionInstance>::CDynamicPool<CAABBCollisionInstance>
PUBLIC	??1?$CDynamicPool@VCAABBCollisionInstance@@@@UAE@XZ ; CDynamicPool<CAABBCollisionInstance>::~CDynamicPool<CAABBCollisionInstance>
PUBLIC	?Destroy@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEXXZ ; CDynamicPool<CAABBCollisionInstance>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEPAVCAABBCollisionInstance@@XZ ; CDynamicPool<CAABBCollisionInstance>::Alloc
PUBLIC	?Free@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEXPAVCAABBCollisionInstance@@@Z ; CDynamicPool<CAABBCollisionInstance>::Free
PUBLIC	?Delete@?$CDynamicPool@VCAABBCollisionInstance@@@@KAXPAVCAABBCollisionInstance@@@Z ; CDynamicPool<CAABBCollisionInstance>::Delete
PUBLIC	??0?$allocator@PAVCAABBCollisionInstance@@@std@@QAE@XZ ; std::allocator<CAABBCollisionInstance *>::allocator<CAABBCollisionInstance *>
PUBLIC	?deallocate@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEXPAPAVCAABBCollisionInstance@@I@Z ; std::allocator<CAABBCollisionInstance *>::deallocate
PUBLIC	?allocate@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEPAPAVCAABBCollisionInstance@@I@Z ; std::allocator<CAABBCollisionInstance *>::allocate
PUBLIC	?construct@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEXPAPAVCAABBCollisionInstance@@ABQAV3@@Z ; std::allocator<CAABBCollisionInstance *>::construct
PUBLIC	?max_size@?$allocator@PAVCAABBCollisionInstance@@@std@@QBEIXZ ; std::allocator<CAABBCollisionInstance *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@SAIABV?$allocator@PAVCAABBCollisionInstance@@@2@@Z ; std::allocator_traits<std::allocator<CAABBCollisionInstance *> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@I@Z ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXPAPAVCAABBCollisionInstance@@I@Z ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> >::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCAABBCollisionInstance@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> > >::_Getal
PUBLIC	??0?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE@XZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >
PUBLIC	??1?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE@XZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::~vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >
PUBLIC	?capacity@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBEIXZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::capacity
PUBLIC	?_Unused_capacity@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBEIXZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Unused_capacity
PUBLIC	?begin@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@2@XZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::begin
PUBLIC	?end@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@2@XZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::end
PUBLIC	?size@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBEIXZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::size
PUBLIC	?max_size@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBEIXZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::max_size
PUBLIC	?empty@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBE_NXZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::empty
PUBLIC	?back@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEAAPAVCAABBCollisionInstance@@XZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::back
PUBLIC	?push_back@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXABQAVCAABBCollisionInstance@@@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::push_back
PUBLIC	?pop_back@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::pop_back
PUBLIC	?clear@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXPAPAVCAABBCollisionInstance@@0@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IBEII@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Grow_to
PUBLIC	?_Inside@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IBE_NPBQAVCAABBCollisionInstance@@@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Inside
PUBLIC	?_Reallocate@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Reserve
PUBLIC	?_Tidy@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXXZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Tidy
PUBLIC	?_Xlen@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IBEXXZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IBEXPAPAVCAABBCollisionInstance@@0@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Orphan_range
PUBLIC	??_G?$CDynamicPool@VCAABBCollisionInstance@@@@UAEPAXI@Z ; CDynamicPool<CAABBCollisionInstance>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPool@VCOBBCollisionInstance@@@@QAE@XZ ; CDynamicPool<COBBCollisionInstance>::CDynamicPool<COBBCollisionInstance>
PUBLIC	??1?$CDynamicPool@VCOBBCollisionInstance@@@@UAE@XZ ; CDynamicPool<COBBCollisionInstance>::~CDynamicPool<COBBCollisionInstance>
PUBLIC	?Destroy@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEXXZ ; CDynamicPool<COBBCollisionInstance>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEPAVCOBBCollisionInstance@@XZ ; CDynamicPool<COBBCollisionInstance>::Alloc
PUBLIC	?Free@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEXPAVCOBBCollisionInstance@@@Z ; CDynamicPool<COBBCollisionInstance>::Free
PUBLIC	?Delete@?$CDynamicPool@VCOBBCollisionInstance@@@@KAXPAVCOBBCollisionInstance@@@Z ; CDynamicPool<COBBCollisionInstance>::Delete
PUBLIC	??0?$allocator@PAVCOBBCollisionInstance@@@std@@QAE@XZ ; std::allocator<COBBCollisionInstance *>::allocator<COBBCollisionInstance *>
PUBLIC	?deallocate@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEXPAPAVCOBBCollisionInstance@@I@Z ; std::allocator<COBBCollisionInstance *>::deallocate
PUBLIC	?allocate@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEPAPAVCOBBCollisionInstance@@I@Z ; std::allocator<COBBCollisionInstance *>::allocate
PUBLIC	?construct@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEXPAPAVCOBBCollisionInstance@@ABQAV3@@Z ; std::allocator<COBBCollisionInstance *>::construct
PUBLIC	?max_size@?$allocator@PAVCOBBCollisionInstance@@@std@@QBEIXZ ; std::allocator<COBBCollisionInstance *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@SAIABV?$allocator@PAVCOBBCollisionInstance@@@2@@Z ; std::allocator_traits<std::allocator<COBBCollisionInstance *> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@I@Z ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXPAPAVCOBBCollisionInstance@@I@Z ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> >::_Vector_val<std::_Simple_types<COBBCollisionInstance *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCOBBCollisionInstance@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> > >::_Getal
PUBLIC	??0?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE@XZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >
PUBLIC	??1?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE@XZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::~vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >
PUBLIC	?capacity@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBEIXZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::capacity
PUBLIC	?_Unused_capacity@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBEIXZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Unused_capacity
PUBLIC	?begin@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@2@XZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::begin
PUBLIC	?end@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@2@XZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::end
PUBLIC	?size@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBEIXZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::size
PUBLIC	?max_size@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBEIXZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::max_size
PUBLIC	?empty@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBE_NXZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::empty
PUBLIC	?back@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEAAPAVCOBBCollisionInstance@@XZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::back
PUBLIC	?push_back@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXABQAVCOBBCollisionInstance@@@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::push_back
PUBLIC	?pop_back@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::pop_back
PUBLIC	?clear@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXPAPAVCOBBCollisionInstance@@0@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IBEII@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Grow_to
PUBLIC	?_Inside@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IBE_NPBQAVCOBBCollisionInstance@@@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Inside
PUBLIC	?_Reallocate@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Reserve
PUBLIC	?_Tidy@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXXZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Tidy
PUBLIC	?_Xlen@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IBEXXZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IBEXPAPAVCOBBCollisionInstance@@0@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Orphan_range
PUBLIC	??_G?$CDynamicPool@VCOBBCollisionInstance@@@@UAEPAXI@Z ; CDynamicPool<COBBCollisionInstance>::`scalar deleting destructor'
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCSphereCollisionInstance@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QBEABQAVCSphereCollisionInstance@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::operator*
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::operator+=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCSphereCollisionInstance@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QBEPAPAVCSphereCollisionInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::_Unchecked
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QBEAAPAVCSphereCollisionInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::operator+=
PUBLIC	??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::operator-=
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::operator-
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@P6AXPAVCSphereCollisionInstance@@@Z@std@@YAP6AXPAVCSphereCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >,void (__cdecl*)(CSphereCollisionInstance *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCCylinderCollisionInstance@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QBEABQAVCCylinderCollisionInstance@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::operator*
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::operator+=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCCylinderCollisionInstance@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QBEPAPAVCCylinderCollisionInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::_Unchecked
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QBEAAPAVCCylinderCollisionInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::operator+=
PUBLIC	??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::operator-=
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::operator-
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@P6AXPAVCCylinderCollisionInstance@@@Z@std@@YAP6AXPAVCCylinderCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >,void (__cdecl*)(CCylinderCollisionInstance *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCPlaneCollisionInstance@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QBEABQAVCPlaneCollisionInstance@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::operator*
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::operator+=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCPlaneCollisionInstance@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QBEPAPAVCPlaneCollisionInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::_Unchecked
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QBEAAPAVCPlaneCollisionInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::operator+=
PUBLIC	??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::operator-=
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::operator-
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@P6AXPAVCPlaneCollisionInstance@@@Z@std@@YAP6AXPAVCPlaneCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >,void (__cdecl*)(CPlaneCollisionInstance *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCAABBCollisionInstance@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QBEABQAVCAABBCollisionInstance@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::operator*
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::operator+=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCAABBCollisionInstance@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QBEPAPAVCAABBCollisionInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::_Unchecked
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QBEAAPAVCAABBCollisionInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::operator+=
PUBLIC	??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::operator-=
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::operator-
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@P6AXPAVCAABBCollisionInstance@@@Z@std@@YAP6AXPAVCAABBCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >,void (__cdecl*)(CAABBCollisionInstance *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCOBBCollisionInstance@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QBEABQAVCOBBCollisionInstance@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::operator*
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::operator+=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCOBBCollisionInstance@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QBEPAPAVCOBBCollisionInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::_Unchecked
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QBEAAPAVCOBBCollisionInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::operator+=
PUBLIC	??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::operator-=
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::operator-
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@P6AXPAVCOBBCollisionInstance@@@Z@std@@YAP6AXPAVCOBBCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >,void (__cdecl*)(COBBCollisionInstance *)>
PUBLIC	??$addressof@QAVCSphereCollisionInstance@@@std@@YAPBQAVCSphereCollisionInstance@@ABQAV1@@Z ; std::addressof<CSphereCollisionInstance * const>
PUBLIC	??$construct@PAVCSphereCollisionInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXPAPAVCSphereCollisionInstance@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::construct<CSphereCollisionInstance *,CSphereCollisionInstance * &>
PUBLIC	??$construct@PAVCSphereCollisionInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXPAPAVCSphereCollisionInstance@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::construct<CSphereCollisionInstance *,CSphereCollisionInstance * const &>
PUBLIC	??$destroy@PAVCSphereCollisionInstance@@@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXPAPAVCSphereCollisionInstance@@@Z ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::destroy<CSphereCollisionInstance *>
PUBLIC	??$addressof@QAVCCylinderCollisionInstance@@@std@@YAPBQAVCCylinderCollisionInstance@@ABQAV1@@Z ; std::addressof<CCylinderCollisionInstance * const>
PUBLIC	??$construct@PAVCCylinderCollisionInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXPAPAVCCylinderCollisionInstance@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::construct<CCylinderCollisionInstance *,CCylinderCollisionInstance * &>
PUBLIC	??$construct@PAVCCylinderCollisionInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXPAPAVCCylinderCollisionInstance@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::construct<CCylinderCollisionInstance *,CCylinderCollisionInstance * const &>
PUBLIC	??$destroy@PAVCCylinderCollisionInstance@@@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXPAPAVCCylinderCollisionInstance@@@Z ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::destroy<CCylinderCollisionInstance *>
PUBLIC	??$addressof@QAVCPlaneCollisionInstance@@@std@@YAPBQAVCPlaneCollisionInstance@@ABQAV1@@Z ; std::addressof<CPlaneCollisionInstance * const>
PUBLIC	??$construct@PAVCPlaneCollisionInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXPAPAVCPlaneCollisionInstance@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::construct<CPlaneCollisionInstance *,CPlaneCollisionInstance * &>
PUBLIC	??$construct@PAVCPlaneCollisionInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXPAPAVCPlaneCollisionInstance@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::construct<CPlaneCollisionInstance *,CPlaneCollisionInstance * const &>
PUBLIC	??$destroy@PAVCPlaneCollisionInstance@@@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXPAPAVCPlaneCollisionInstance@@@Z ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::destroy<CPlaneCollisionInstance *>
PUBLIC	??$addressof@QAVCAABBCollisionInstance@@@std@@YAPBQAVCAABBCollisionInstance@@ABQAV1@@Z ; std::addressof<CAABBCollisionInstance * const>
PUBLIC	??$construct@PAVCAABBCollisionInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXPAPAVCAABBCollisionInstance@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::construct<CAABBCollisionInstance *,CAABBCollisionInstance * &>
PUBLIC	??$construct@PAVCAABBCollisionInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXPAPAVCAABBCollisionInstance@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::construct<CAABBCollisionInstance *,CAABBCollisionInstance * const &>
PUBLIC	??$destroy@PAVCAABBCollisionInstance@@@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXPAPAVCAABBCollisionInstance@@@Z ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::destroy<CAABBCollisionInstance *>
PUBLIC	??$addressof@QAVCOBBCollisionInstance@@@std@@YAPBQAVCOBBCollisionInstance@@ABQAV1@@Z ; std::addressof<COBBCollisionInstance * const>
PUBLIC	??$construct@PAVCOBBCollisionInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXPAPAVCOBBCollisionInstance@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::construct<COBBCollisionInstance *,COBBCollisionInstance * &>
PUBLIC	??$construct@PAVCOBBCollisionInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXPAPAVCOBBCollisionInstance@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::construct<COBBCollisionInstance *,COBBCollisionInstance * const &>
PUBLIC	??$destroy@PAVCOBBCollisionInstance@@@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXPAPAVCOBBCollisionInstance@@@Z ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::destroy<COBBCollisionInstance *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCSphereCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCCylinderCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCPlaneCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCAABBCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCOBBCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> > >
PUBLIC	??$_Umove@PAPAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEPAPAVCSphereCollisionInstance@@PAPAV2@00@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Umove<CSphereCollisionInstance * *>
PUBLIC	??$_Umove@PAPAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEPAPAVCCylinderCollisionInstance@@PAPAV2@00@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Umove<CCylinderCollisionInstance * *>
PUBLIC	??$_Umove@PAPAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEPAPAVCPlaneCollisionInstance@@PAPAV2@00@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Umove<CPlaneCollisionInstance * *>
PUBLIC	??$_Umove@PAPAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEPAPAVCAABBCollisionInstance@@PAPAV2@00@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Umove<CAABBCollisionInstance * *>
PUBLIC	??$_Umove@PAPAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEPAPAVCOBBCollisionInstance@@PAPAV2@00@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Umove<COBBCollisionInstance * *>
PUBLIC	??$_Allocate@PAVCSphereCollisionInstance@@@std@@YAPAPAVCSphereCollisionInstance@@IPAPAV1@@Z ; std::_Allocate<CSphereCollisionInstance *>
PUBLIC	??$_Allocate@PAVCCylinderCollisionInstance@@@std@@YAPAPAVCCylinderCollisionInstance@@IPAPAV1@@Z ; std::_Allocate<CCylinderCollisionInstance *>
PUBLIC	??$_Allocate@PAVCPlaneCollisionInstance@@@std@@YAPAPAVCPlaneCollisionInstance@@IPAPAV1@@Z ; std::_Allocate<CPlaneCollisionInstance *>
PUBLIC	??$_Allocate@PAVCAABBCollisionInstance@@@std@@YAPAPAVCAABBCollisionInstance@@IPAPAV1@@Z ; std::_Allocate<CAABBCollisionInstance *>
PUBLIC	??$_Allocate@PAVCOBBCollisionInstance@@@std@@YAPAPAVCOBBCollisionInstance@@IPAPAV1@@Z ; std::_Allocate<COBBCollisionInstance *>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@YAPAPAVCSphereCollisionInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >
PUBLIC	??$_For_each@PAPAVCSphereCollisionInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCSphereCollisionInstance@@0AAP6AXPAV1@@Z@Z ; std::_For_each<CSphereCollisionInstance * *,void (__cdecl*)(CSphereCollisionInstance *)>
PUBLIC	??$move@AAP6AXPAVCSphereCollisionInstance@@@Z@std@@YA$$QAP6AXPAVCSphereCollisionInstance@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(CSphereCollisionInstance *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@YAPAPAVCCylinderCollisionInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >
PUBLIC	??$_For_each@PAPAVCCylinderCollisionInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCCylinderCollisionInstance@@0AAP6AXPAV1@@Z@Z ; std::_For_each<CCylinderCollisionInstance * *,void (__cdecl*)(CCylinderCollisionInstance *)>
PUBLIC	??$move@AAP6AXPAVCCylinderCollisionInstance@@@Z@std@@YA$$QAP6AXPAVCCylinderCollisionInstance@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(CCylinderCollisionInstance *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@YAPAPAVCPlaneCollisionInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >
PUBLIC	??$_For_each@PAPAVCPlaneCollisionInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCPlaneCollisionInstance@@0AAP6AXPAV1@@Z@Z ; std::_For_each<CPlaneCollisionInstance * *,void (__cdecl*)(CPlaneCollisionInstance *)>
PUBLIC	??$move@AAP6AXPAVCPlaneCollisionInstance@@@Z@std@@YA$$QAP6AXPAVCPlaneCollisionInstance@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(CPlaneCollisionInstance *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCAABBCollisionInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >
PUBLIC	??$_For_each@PAPAVCAABBCollisionInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCAABBCollisionInstance@@0AAP6AXPAV1@@Z@Z ; std::_For_each<CAABBCollisionInstance * *,void (__cdecl*)(CAABBCollisionInstance *)>
PUBLIC	??$move@AAP6AXPAVCAABBCollisionInstance@@@Z@std@@YA$$QAP6AXPAVCAABBCollisionInstance@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(CAABBCollisionInstance *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCOBBCollisionInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >
PUBLIC	??$_For_each@PAPAVCOBBCollisionInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCOBBCollisionInstance@@0AAP6AXPAV1@@Z@Z ; std::_For_each<COBBCollisionInstance * *,void (__cdecl*)(COBBCollisionInstance *)>
PUBLIC	??$move@AAP6AXPAVCOBBCollisionInstance@@@Z@std@@YA$$QAP6AXPAVCOBBCollisionInstance@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(COBBCollisionInstance *)>
PUBLIC	??$forward@AAPAVCSphereCollisionInstance@@@std@@YAAAPAVCSphereCollisionInstance@@AAPAV1@@Z ; std::forward<CSphereCollisionInstance * &>
PUBLIC	??$construct@PAVCSphereCollisionInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCSphereCollisionInstance@@@1@PAPAVCSphereCollisionInstance@@AAPAV3@@Z ; std::allocator_traits<std::allocator<CSphereCollisionInstance *> >::construct<CSphereCollisionInstance *,CSphereCollisionInstance * &>
PUBLIC	??$forward@ABQAVCSphereCollisionInstance@@@std@@YAABQAVCSphereCollisionInstance@@ABQAV1@@Z ; std::forward<CSphereCollisionInstance * const &>
PUBLIC	??$construct@PAVCSphereCollisionInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCSphereCollisionInstance@@@1@PAPAVCSphereCollisionInstance@@ABQAV3@@Z ; std::allocator_traits<std::allocator<CSphereCollisionInstance *> >::construct<CSphereCollisionInstance *,CSphereCollisionInstance * const &>
PUBLIC	??$destroy@PAVCSphereCollisionInstance@@@?$allocator_traits@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCSphereCollisionInstance@@@1@PAPAVCSphereCollisionInstance@@@Z ; std::allocator_traits<std::allocator<CSphereCollisionInstance *> >::destroy<CSphereCollisionInstance *>
PUBLIC	??$forward@AAPAVCCylinderCollisionInstance@@@std@@YAAAPAVCCylinderCollisionInstance@@AAPAV1@@Z ; std::forward<CCylinderCollisionInstance * &>
PUBLIC	??$construct@PAVCCylinderCollisionInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCCylinderCollisionInstance@@@1@PAPAVCCylinderCollisionInstance@@AAPAV3@@Z ; std::allocator_traits<std::allocator<CCylinderCollisionInstance *> >::construct<CCylinderCollisionInstance *,CCylinderCollisionInstance * &>
PUBLIC	??$forward@ABQAVCCylinderCollisionInstance@@@std@@YAABQAVCCylinderCollisionInstance@@ABQAV1@@Z ; std::forward<CCylinderCollisionInstance * const &>
PUBLIC	??$construct@PAVCCylinderCollisionInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCCylinderCollisionInstance@@@1@PAPAVCCylinderCollisionInstance@@ABQAV3@@Z ; std::allocator_traits<std::allocator<CCylinderCollisionInstance *> >::construct<CCylinderCollisionInstance *,CCylinderCollisionInstance * const &>
PUBLIC	??$destroy@PAVCCylinderCollisionInstance@@@?$allocator_traits@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCCylinderCollisionInstance@@@1@PAPAVCCylinderCollisionInstance@@@Z ; std::allocator_traits<std::allocator<CCylinderCollisionInstance *> >::destroy<CCylinderCollisionInstance *>
PUBLIC	??$forward@AAPAVCPlaneCollisionInstance@@@std@@YAAAPAVCPlaneCollisionInstance@@AAPAV1@@Z ; std::forward<CPlaneCollisionInstance * &>
PUBLIC	??$construct@PAVCPlaneCollisionInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCPlaneCollisionInstance@@@1@PAPAVCPlaneCollisionInstance@@AAPAV3@@Z ; std::allocator_traits<std::allocator<CPlaneCollisionInstance *> >::construct<CPlaneCollisionInstance *,CPlaneCollisionInstance * &>
PUBLIC	??$forward@ABQAVCPlaneCollisionInstance@@@std@@YAABQAVCPlaneCollisionInstance@@ABQAV1@@Z ; std::forward<CPlaneCollisionInstance * const &>
PUBLIC	??$construct@PAVCPlaneCollisionInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCPlaneCollisionInstance@@@1@PAPAVCPlaneCollisionInstance@@ABQAV3@@Z ; std::allocator_traits<std::allocator<CPlaneCollisionInstance *> >::construct<CPlaneCollisionInstance *,CPlaneCollisionInstance * const &>
PUBLIC	??$destroy@PAVCPlaneCollisionInstance@@@?$allocator_traits@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCPlaneCollisionInstance@@@1@PAPAVCPlaneCollisionInstance@@@Z ; std::allocator_traits<std::allocator<CPlaneCollisionInstance *> >::destroy<CPlaneCollisionInstance *>
PUBLIC	??$forward@AAPAVCAABBCollisionInstance@@@std@@YAAAPAVCAABBCollisionInstance@@AAPAV1@@Z ; std::forward<CAABBCollisionInstance * &>
PUBLIC	??$construct@PAVCAABBCollisionInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCAABBCollisionInstance@@@1@PAPAVCAABBCollisionInstance@@AAPAV3@@Z ; std::allocator_traits<std::allocator<CAABBCollisionInstance *> >::construct<CAABBCollisionInstance *,CAABBCollisionInstance * &>
PUBLIC	??$forward@ABQAVCAABBCollisionInstance@@@std@@YAABQAVCAABBCollisionInstance@@ABQAV1@@Z ; std::forward<CAABBCollisionInstance * const &>
PUBLIC	??$construct@PAVCAABBCollisionInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCAABBCollisionInstance@@@1@PAPAVCAABBCollisionInstance@@ABQAV3@@Z ; std::allocator_traits<std::allocator<CAABBCollisionInstance *> >::construct<CAABBCollisionInstance *,CAABBCollisionInstance * const &>
PUBLIC	??$destroy@PAVCAABBCollisionInstance@@@?$allocator_traits@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCAABBCollisionInstance@@@1@PAPAVCAABBCollisionInstance@@@Z ; std::allocator_traits<std::allocator<CAABBCollisionInstance *> >::destroy<CAABBCollisionInstance *>
PUBLIC	??$forward@AAPAVCOBBCollisionInstance@@@std@@YAAAPAVCOBBCollisionInstance@@AAPAV1@@Z ; std::forward<COBBCollisionInstance * &>
PUBLIC	??$construct@PAVCOBBCollisionInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCOBBCollisionInstance@@@1@PAPAVCOBBCollisionInstance@@AAPAV3@@Z ; std::allocator_traits<std::allocator<COBBCollisionInstance *> >::construct<COBBCollisionInstance *,COBBCollisionInstance * &>
PUBLIC	??$forward@ABQAVCOBBCollisionInstance@@@std@@YAABQAVCOBBCollisionInstance@@ABQAV1@@Z ; std::forward<COBBCollisionInstance * const &>
PUBLIC	??$construct@PAVCOBBCollisionInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCOBBCollisionInstance@@@1@PAPAVCOBBCollisionInstance@@ABQAV3@@Z ; std::allocator_traits<std::allocator<COBBCollisionInstance *> >::construct<COBBCollisionInstance *,COBBCollisionInstance * const &>
PUBLIC	??$destroy@PAVCOBBCollisionInstance@@@?$allocator_traits@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCOBBCollisionInstance@@@1@PAPAVCOBBCollisionInstance@@@Z ; std::allocator_traits<std::allocator<COBBCollisionInstance *> >::destroy<COBBCollisionInstance *>
PUBLIC	??$_Ptr_cat@PAVCSphereCollisionInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCSphereCollisionInstance@@0@Z ; std::_Ptr_cat<CSphereCollisionInstance *,CSphereCollisionInstance *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCSphereCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> > >
PUBLIC	??$_Ptr_cat@PAVCCylinderCollisionInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCCylinderCollisionInstance@@0@Z ; std::_Ptr_cat<CCylinderCollisionInstance *,CCylinderCollisionInstance *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCCylinderCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> > >
PUBLIC	??$_Ptr_cat@PAVCPlaneCollisionInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCPlaneCollisionInstance@@0@Z ; std::_Ptr_cat<CPlaneCollisionInstance *,CPlaneCollisionInstance *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCPlaneCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> > >
PUBLIC	??$_Ptr_cat@PAVCAABBCollisionInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCAABBCollisionInstance@@0@Z ; std::_Ptr_cat<CAABBCollisionInstance *,CAABBCollisionInstance *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCAABBCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> > >
PUBLIC	??$_Ptr_cat@PAVCOBBCollisionInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCOBBCollisionInstance@@0@Z ; std::_Ptr_cat<COBBCollisionInstance *,COBBCollisionInstance *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCOBBCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> > >
PUBLIC	??$_Uninitialized_move@PAPAVCSphereCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@0@@Z ; std::_Uninitialized_move<CSphereCollisionInstance * *,CSphereCollisionInstance * *,std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> > >
PUBLIC	??$_Uninitialized_move@PAPAVCCylinderCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@0@@Z ; std::_Uninitialized_move<CCylinderCollisionInstance * *,CCylinderCollisionInstance * *,std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> > >
PUBLIC	??$_Uninitialized_move@PAPAVCPlaneCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@0@@Z ; std::_Uninitialized_move<CPlaneCollisionInstance * *,CPlaneCollisionInstance * *,std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> > >
PUBLIC	??$_Uninitialized_move@PAPAVCAABBCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@0@@Z ; std::_Uninitialized_move<CAABBCollisionInstance * *,CAABBCollisionInstance * *,std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> > >
PUBLIC	??$_Uninitialized_move@PAPAVCOBBCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@0@@Z ; std::_Uninitialized_move<COBBCollisionInstance * *,COBBCollisionInstance * *,std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> > >
PUBLIC	??$construct@PAVCSphereCollisionInstance@@AAPAV1@@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEXPAPAVCSphereCollisionInstance@@AAPAV2@@Z ; std::allocator<CSphereCollisionInstance *>::construct<CSphereCollisionInstance *,CSphereCollisionInstance * &>
PUBLIC	??$destroy@PAVCSphereCollisionInstance@@@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEXPAPAVCSphereCollisionInstance@@@Z ; std::allocator<CSphereCollisionInstance *>::destroy<CSphereCollisionInstance *>
PUBLIC	??$construct@PAVCCylinderCollisionInstance@@AAPAV1@@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEXPAPAVCCylinderCollisionInstance@@AAPAV2@@Z ; std::allocator<CCylinderCollisionInstance *>::construct<CCylinderCollisionInstance *,CCylinderCollisionInstance * &>
PUBLIC	??$destroy@PAVCCylinderCollisionInstance@@@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEXPAPAVCCylinderCollisionInstance@@@Z ; std::allocator<CCylinderCollisionInstance *>::destroy<CCylinderCollisionInstance *>
PUBLIC	??$construct@PAVCPlaneCollisionInstance@@AAPAV1@@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEXPAPAVCPlaneCollisionInstance@@AAPAV2@@Z ; std::allocator<CPlaneCollisionInstance *>::construct<CPlaneCollisionInstance *,CPlaneCollisionInstance * &>
PUBLIC	??$destroy@PAVCPlaneCollisionInstance@@@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEXPAPAVCPlaneCollisionInstance@@@Z ; std::allocator<CPlaneCollisionInstance *>::destroy<CPlaneCollisionInstance *>
PUBLIC	??$construct@PAVCAABBCollisionInstance@@AAPAV1@@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEXPAPAVCAABBCollisionInstance@@AAPAV2@@Z ; std::allocator<CAABBCollisionInstance *>::construct<CAABBCollisionInstance *,CAABBCollisionInstance * &>
PUBLIC	??$destroy@PAVCAABBCollisionInstance@@@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEXPAPAVCAABBCollisionInstance@@@Z ; std::allocator<CAABBCollisionInstance *>::destroy<CAABBCollisionInstance *>
PUBLIC	??$construct@PAVCOBBCollisionInstance@@AAPAV1@@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEXPAPAVCOBBCollisionInstance@@AAPAV2@@Z ; std::allocator<COBBCollisionInstance *>::construct<COBBCollisionInstance *,COBBCollisionInstance * &>
PUBLIC	??$destroy@PAVCOBBCollisionInstance@@@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEXPAPAVCOBBCollisionInstance@@@Z ; std::allocator<COBBCollisionInstance *>::destroy<COBBCollisionInstance *>
PUBLIC	??$_Unchecked@PAPAVCSphereCollisionInstance@@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@@Z ; std::_Unchecked<CSphereCollisionInstance * *>
PUBLIC	??$_Uninit_move@PAPAVCSphereCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@0@@Z ; std::_Uninit_move<CSphereCollisionInstance * *,CSphereCollisionInstance * *,std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> > >
PUBLIC	??$_Rechecked@PAPAVCSphereCollisionInstance@@PAPAV1@@std@@YAAAPAPAVCSphereCollisionInstance@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<CSphereCollisionInstance * *,CSphereCollisionInstance * *>
PUBLIC	??$_Unchecked@PAPAVCCylinderCollisionInstance@@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@@Z ; std::_Unchecked<CCylinderCollisionInstance * *>
PUBLIC	??$_Uninit_move@PAPAVCCylinderCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@0@@Z ; std::_Uninit_move<CCylinderCollisionInstance * *,CCylinderCollisionInstance * *,std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> > >
PUBLIC	??$_Rechecked@PAPAVCCylinderCollisionInstance@@PAPAV1@@std@@YAAAPAPAVCCylinderCollisionInstance@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<CCylinderCollisionInstance * *,CCylinderCollisionInstance * *>
PUBLIC	??$_Unchecked@PAPAVCPlaneCollisionInstance@@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@@Z ; std::_Unchecked<CPlaneCollisionInstance * *>
PUBLIC	??$_Uninit_move@PAPAVCPlaneCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@0@@Z ; std::_Uninit_move<CPlaneCollisionInstance * *,CPlaneCollisionInstance * *,std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> > >
PUBLIC	??$_Rechecked@PAPAVCPlaneCollisionInstance@@PAPAV1@@std@@YAAAPAPAVCPlaneCollisionInstance@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<CPlaneCollisionInstance * *,CPlaneCollisionInstance * *>
PUBLIC	??$_Unchecked@PAPAVCAABBCollisionInstance@@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@@Z ; std::_Unchecked<CAABBCollisionInstance * *>
PUBLIC	??$_Uninit_move@PAPAVCAABBCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@0@@Z ; std::_Uninit_move<CAABBCollisionInstance * *,CAABBCollisionInstance * *,std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> > >
PUBLIC	??$_Rechecked@PAPAVCAABBCollisionInstance@@PAPAV1@@std@@YAAAPAPAVCAABBCollisionInstance@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<CAABBCollisionInstance * *,CAABBCollisionInstance * *>
PUBLIC	??$_Unchecked@PAPAVCOBBCollisionInstance@@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@@Z ; std::_Unchecked<COBBCollisionInstance * *>
PUBLIC	??$_Uninit_move@PAPAVCOBBCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@0@@Z ; std::_Uninit_move<COBBCollisionInstance * *,COBBCollisionInstance * *,std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> > >
PUBLIC	??$_Rechecked@PAPAVCOBBCollisionInstance@@PAPAV1@@std@@YAAAPAPAVCOBBCollisionInstance@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<COBBCollisionInstance * *,COBBCollisionInstance * *>
PUBLIC	??$_Val_type@PAPAVCSphereCollisionInstance@@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@@Z ; std::_Val_type<CSphereCollisionInstance * *>
PUBLIC	??$_Uninit_move@PAVCSphereCollisionInstance@@PAV1@PAV1@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CSphereCollisionInstance *,CSphereCollisionInstance *,CSphereCollisionInstance *>
PUBLIC	??$_Val_type@PAPAVCCylinderCollisionInstance@@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@@Z ; std::_Val_type<CCylinderCollisionInstance * *>
PUBLIC	??$_Uninit_move@PAVCCylinderCollisionInstance@@PAV1@PAV1@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CCylinderCollisionInstance *,CCylinderCollisionInstance *,CCylinderCollisionInstance *>
PUBLIC	??$_Val_type@PAPAVCPlaneCollisionInstance@@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@@Z ; std::_Val_type<CPlaneCollisionInstance * *>
PUBLIC	??$_Uninit_move@PAVCPlaneCollisionInstance@@PAV1@PAV1@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CPlaneCollisionInstance *,CPlaneCollisionInstance *,CPlaneCollisionInstance *>
PUBLIC	??$_Val_type@PAPAVCAABBCollisionInstance@@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@@Z ; std::_Val_type<CAABBCollisionInstance * *>
PUBLIC	??$_Uninit_move@PAVCAABBCollisionInstance@@PAV1@PAV1@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CAABBCollisionInstance *,CAABBCollisionInstance *,CAABBCollisionInstance *>
PUBLIC	??$_Val_type@PAPAVCOBBCollisionInstance@@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@@Z ; std::_Val_type<COBBCollisionInstance * *>
PUBLIC	??$_Uninit_move@PAVCOBBCollisionInstance@@PAV1@PAV1@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<COBBCollisionInstance *,COBBCollisionInstance *,COBBCollisionInstance *>
PUBLIC	??_7CBaseCollisionInstance@@6B@			; CBaseCollisionInstance::`vftable'
PUBLIC	??_7CSphereCollisionInstance@@6B@		; CSphereCollisionInstance::`vftable'
PUBLIC	??_7CPlaneCollisionInstance@@6B@		; CPlaneCollisionInstance::`vftable'
PUBLIC	??_7CAABBCollisionInstance@@6B@			; CAABBCollisionInstance::`vftable'
PUBLIC	??_7COBBCollisionInstance@@6B@			; COBBCollisionInstance::`vftable'
PUBLIC	??_7CCylinderCollisionInstance@@6B@		; CCylinderCollisionInstance::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	??_7?$CDynamicPool@VCSphereCollisionInstance@@@@6B@ ; CDynamicPool<CSphereCollisionInstance>::`vftable'
PUBLIC	?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A ; gs_sci
PUBLIC	??_7?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@ ; CDynamicPool<CCylinderCollisionInstance>::`vftable'
PUBLIC	?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A ; gs_cci
PUBLIC	??_7?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@ ; CDynamicPool<CPlaneCollisionInstance>::`vftable'
PUBLIC	?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A ; gs_pci
PUBLIC	??_7?$CDynamicPool@VCAABBCollisionInstance@@@@6B@ ; CDynamicPool<CAABBCollisionInstance>::`vftable'
PUBLIC	?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A ; gs_aci
PUBLIC	??_7?$CDynamicPool@VCOBBCollisionInstance@@@@6B@ ; CDynamicPool<COBBCollisionInstance>::`vftable'
PUBLIC	?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A ; gs_oci
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R4CBaseCollisionInstance@@6B@		; CBaseCollisionInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCBaseCollisionInstance@@@8		; CBaseCollisionInstance `RTTI Type Descriptor'
PUBLIC	??_R3CBaseCollisionInstance@@8			; CBaseCollisionInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CBaseCollisionInstance@@8			; CBaseCollisionInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CBaseCollisionInstance@@8		; CBaseCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CSphereCollisionInstance@@6B@		; CSphereCollisionInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCSphereCollisionInstance@@@8		; CSphereCollisionInstance `RTTI Type Descriptor'
PUBLIC	??_R3CSphereCollisionInstance@@8		; CSphereCollisionInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CSphereCollisionInstance@@8		; CSphereCollisionInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CSphereCollisionInstance@@8	; CSphereCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CPlaneCollisionInstance@@6B@		; CPlaneCollisionInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCPlaneCollisionInstance@@@8		; CPlaneCollisionInstance `RTTI Type Descriptor'
PUBLIC	??_R3CPlaneCollisionInstance@@8			; CPlaneCollisionInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CPlaneCollisionInstance@@8			; CPlaneCollisionInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CPlaneCollisionInstance@@8	; CPlaneCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CAABBCollisionInstance@@6B@		; CAABBCollisionInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCAABBCollisionInstance@@@8		; CAABBCollisionInstance `RTTI Type Descriptor'
PUBLIC	??_R3CAABBCollisionInstance@@8			; CAABBCollisionInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CAABBCollisionInstance@@8			; CAABBCollisionInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CAABBCollisionInstance@@8		; CAABBCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4COBBCollisionInstance@@6B@			; COBBCollisionInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCOBBCollisionInstance@@@8		; COBBCollisionInstance `RTTI Type Descriptor'
PUBLIC	??_R3COBBCollisionInstance@@8			; COBBCollisionInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2COBBCollisionInstance@@8			; COBBCollisionInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@COBBCollisionInstance@@8		; COBBCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CCylinderCollisionInstance@@6B@		; CCylinderCollisionInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCCylinderCollisionInstance@@@8		; CCylinderCollisionInstance `RTTI Type Descriptor'
PUBLIC	??_R3CCylinderCollisionInstance@@8		; CCylinderCollisionInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CCylinderCollisionInstance@@8		; CCylinderCollisionInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CCylinderCollisionInstance@@8	; CCylinderCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCSphereCollisionInstance@@@@6B@ ; CDynamicPool<CSphereCollisionInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCSphereCollisionInstance@@@@@8 ; CDynamicPool<CSphereCollisionInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCSphereCollisionInstance@@@@8 ; CDynamicPool<CSphereCollisionInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCSphereCollisionInstance@@@@8 ; CDynamicPool<CSphereCollisionInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCSphereCollisionInstance@@@@8 ; CDynamicPool<CSphereCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@ ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCCylinderCollisionInstance@@@@@8 ; CDynamicPool<CCylinderCollisionInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCCylinderCollisionInstance@@@@8 ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCCylinderCollisionInstance@@@@8 ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCCylinderCollisionInstance@@@@8 ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@ ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCPlaneCollisionInstance@@@@@8 ; CDynamicPool<CPlaneCollisionInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCPlaneCollisionInstance@@@@8 ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCPlaneCollisionInstance@@@@8 ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCPlaneCollisionInstance@@@@8 ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCAABBCollisionInstance@@@@6B@ ; CDynamicPool<CAABBCollisionInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCAABBCollisionInstance@@@@@8 ; CDynamicPool<CAABBCollisionInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCAABBCollisionInstance@@@@8 ; CDynamicPool<CAABBCollisionInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCAABBCollisionInstance@@@@8 ; CDynamicPool<CAABBCollisionInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCAABBCollisionInstance@@@@8 ; CDynamicPool<CAABBCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCOBBCollisionInstance@@@@6B@ ; CDynamicPool<COBBCollisionInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCOBBCollisionInstance@@@@@8 ; CDynamicPool<COBBCollisionInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCOBBCollisionInstance@@@@8	; CDynamicPool<COBBCollisionInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCOBBCollisionInstance@@@@8	; CDynamicPool<COBBCollisionInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCOBBCollisionInstance@@@@8 ; CDynamicPool<COBBCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@38d1b717
PUBLIC	__real@3f000000
PUBLIC	__real@3f1a36e2eb1c432d
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@40800000
PUBLIC	__real@bf1a36e2eb1c432d
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_memmove:PROC
EXTRN	_D3DXVec3Normalize@8:PROC
EXTRN	_D3DXVec3TransformCoord@12:PROC
EXTRN	_D3DXMatrixMultiply@12:PROC
EXTRN	_D3DXMatrixTranslation@16:PROC
EXTRN	_D3DXMatrixRotationQuaternion@8:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	??0CScreen@@QAE@XZ:PROC				; CScreen::CScreen
EXTRN	??1CScreen@@UAE@XZ:PROC				; CScreen::~CScreen
EXTRN	?RenderBar3d@CScreen@@QAEXPBUD3DXVECTOR3@@@Z:PROC ; CScreen::RenderBar3d
EXTRN	?RenderCube@CScreen@@QAEXMMMMMM@Z:PROC		; CScreen::RenderCube
EXTRN	?RenderCube@CScreen@@QAEXMMMMMMUD3DXMATRIX@@@Z:PROC ; CScreen::RenderCube
EXTRN	?RenderSphere@CScreen@@QAEXPBUD3DXMATRIX@@MMMMW4_D3DFILLMODE@@@Z:PROC ; CScreen::RenderSphere
EXTRN	?RenderCylinder@CScreen@@QAEXPBUD3DXMATRIX@@MMMMMW4_D3DFILLMODE@@@Z:PROC ; CScreen::RenderCylinder
EXTRN	?IntersectLineSegments@@YAXABUD3DXVECTOR3@@000AAU1@1@Z:PROC ; IntersectLineSegments
EXTRN	?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SetRenderState
EXTRN	??_E?$CDynamicPool@VCSphereCollisionInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CSphereCollisionInstance>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPool@VCCylinderCollisionInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CCylinderCollisionInstance>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPool@VCPlaneCollisionInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CPlaneCollisionInstance>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPool@VCAABBCollisionInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CAABBCollisionInstance>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPool@VCOBBCollisionInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<COBBCollisionInstance>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?s@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
_BSS	SEGMENT
?s@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A DD 01H DUP (?) ; `CSphereCollisionInstance::Render'::`2'::s
_BSS	ENDS
;	COMDAT ?$S1@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA
_BSS	SEGMENT
?$S1@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA DD 01H DUP (?) ; S1<`template-parameter-2',CSphereCollisionInstance::der,AEXW4_D3DFILLMODE>
_BSS	ENDS
;	COMDAT ?s@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
_BSS	SEGMENT
?s@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A DD 01H DUP (?) ; `CPlaneCollisionInstance::Render'::`2'::s
_BSS	ENDS
;	COMDAT ?$S2@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA
_BSS	SEGMENT
?$S2@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA DD 01H DUP (?) ; S2<`template-parameter-2',CPlaneCollisionInstance::der,AEXW4_D3DFILLMODE>
_BSS	ENDS
;	COMDAT ?s@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
_BSS	SEGMENT
?s@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A DD 01H DUP (?) ; `CCylinderCollisionInstance::Render'::`2'::s
_BSS	ENDS
;	COMDAT ?$S3@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA
_BSS	SEGMENT
?$S3@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA DD 01H DUP (?) ; S3<`template-parameter-2',CCylinderCollisionInstance::der,AEXW4_D3DFILLMODE>
_BSS	ENDS
;	COMDAT ?s@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
_BSS	SEGMENT
?s@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A DD 01H DUP (?) ; `CAABBCollisionInstance::Render'::`2'::s
_BSS	ENDS
;	COMDAT ?$S4@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA
_BSS	SEGMENT
?$S4@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA DD 01H DUP (?) ; S4<`template-parameter-2',CAABBCollisionInstance::der,AEXW4_D3DFILLMODE>
_BSS	ENDS
;	COMDAT ?s@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
_BSS	SEGMENT
?s@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A DD 01H DUP (?) ; `COBBCollisionInstance::Render'::`2'::s
_BSS	ENDS
;	COMDAT ?$S5@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA
_BSS	SEGMENT
?$S5@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA DD 01H DUP (?) ; S5<`template-parameter-2',COBBCollisionInstance::der,AEXW4_D3DFILLMODE>
_BSS	ENDS
CRT$XCU	SEGMENT
_gs_sci$initializer$ DD FLAT:??__Egs_sci@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@bf1a36e2eb1c432d
CONST	SEGMENT
__real@bf1a36e2eb1c432d DQ 0bf1a36e2eb1c432dr	; -0.0001
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f1a36e2eb1c432d
CONST	SEGMENT
__real@3f1a36e2eb1c432d DQ 03f1a36e2eb1c432dr	; 0.0001
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCOBBCollisionInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCOBBCollisionInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCOBBCollisionInstance@@@@@8 ; CDynamicPool<COBBCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCOBBCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCOBBCollisionInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCOBBCollisionInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCOBBCollisionInstance@@@@8 ; CDynamicPool<COBBCollisionInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCOBBCollisionInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCOBBCollisionInstance@@@@8 DD 00H	; CDynamicPool<COBBCollisionInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCOBBCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCOBBCollisionInstance@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPool@VCOBBCollisionInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<COBBCollisionInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCOBBCollisionInstance@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCOBBCollisionInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCOBBCollisionInstance@@@@6B@ DD 00H ; CDynamicPool<COBBCollisionInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCOBBCollisionInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCOBBCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCAABBCollisionInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCAABBCollisionInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCAABBCollisionInstance@@@@@8 ; CDynamicPool<CAABBCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCAABBCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCAABBCollisionInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCAABBCollisionInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCAABBCollisionInstance@@@@8 ; CDynamicPool<CAABBCollisionInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCAABBCollisionInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCAABBCollisionInstance@@@@8 DD 00H	; CDynamicPool<CAABBCollisionInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCAABBCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCAABBCollisionInstance@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPool@VCAABBCollisionInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CAABBCollisionInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCAABBCollisionInstance@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCAABBCollisionInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCAABBCollisionInstance@@@@6B@ DD 00H ; CDynamicPool<CAABBCollisionInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCAABBCollisionInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCAABBCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCPlaneCollisionInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCPlaneCollisionInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCPlaneCollisionInstance@@@@@8 ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCPlaneCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCPlaneCollisionInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCPlaneCollisionInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCPlaneCollisionInstance@@@@8 ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCPlaneCollisionInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCPlaneCollisionInstance@@@@8 DD 00H ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCPlaneCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCPlaneCollisionInstance@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPool@VCPlaneCollisionInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CPlaneCollisionInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCPlaneCollisionInstance@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@ DD 00H ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCPlaneCollisionInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCPlaneCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCCylinderCollisionInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCCylinderCollisionInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCCylinderCollisionInstance@@@@@8 ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCCylinderCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCCylinderCollisionInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCCylinderCollisionInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCCylinderCollisionInstance@@@@8 ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCCylinderCollisionInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCCylinderCollisionInstance@@@@8 DD 00H ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCCylinderCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCCylinderCollisionInstance@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPool@VCCylinderCollisionInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CCylinderCollisionInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCCylinderCollisionInstance@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@ DD 00H ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCCylinderCollisionInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCCylinderCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCSphereCollisionInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCSphereCollisionInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCSphereCollisionInstance@@@@@8 ; CDynamicPool<CSphereCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCSphereCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCSphereCollisionInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCSphereCollisionInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCSphereCollisionInstance@@@@8 ; CDynamicPool<CSphereCollisionInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCSphereCollisionInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCSphereCollisionInstance@@@@8 DD 00H ; CDynamicPool<CSphereCollisionInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCSphereCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCSphereCollisionInstance@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPool@VCSphereCollisionInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CSphereCollisionInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCSphereCollisionInstance@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCSphereCollisionInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCSphereCollisionInstance@@@@6B@ DD 00H ; CDynamicPool<CSphereCollisionInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCSphereCollisionInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCSphereCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CCylinderCollisionInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CCylinderCollisionInstance@@8 DD FLAT:??_R0?AVCCylinderCollisionInstance@@@8 ; CCylinderCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CCylinderCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CCylinderCollisionInstance@@8
rdata$r	SEGMENT
??_R2CCylinderCollisionInstance@@8 DD FLAT:??_R1A@?0A@EA@CCylinderCollisionInstance@@8 ; CCylinderCollisionInstance::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R3CCylinderCollisionInstance@@8
rdata$r	SEGMENT
??_R3CCylinderCollisionInstance@@8 DD 00H		; CCylinderCollisionInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CCylinderCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCCylinderCollisionInstance@@@8
data$r	SEGMENT
??_R0?AVCCylinderCollisionInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CCylinderCollisionInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCCylinderCollisionInstance@@', 00H
data$r	ENDS
;	COMDAT ??_R4CCylinderCollisionInstance@@6B@
rdata$r	SEGMENT
??_R4CCylinderCollisionInstance@@6B@ DD 00H		; CCylinderCollisionInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCCylinderCollisionInstance@@@8
	DD	FLAT:??_R3CCylinderCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@COBBCollisionInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@COBBCollisionInstance@@8 DD FLAT:??_R0?AVCOBBCollisionInstance@@@8 ; COBBCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3COBBCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2COBBCollisionInstance@@8
rdata$r	SEGMENT
??_R2COBBCollisionInstance@@8 DD FLAT:??_R1A@?0A@EA@COBBCollisionInstance@@8 ; COBBCollisionInstance::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R3COBBCollisionInstance@@8
rdata$r	SEGMENT
??_R3COBBCollisionInstance@@8 DD 00H			; COBBCollisionInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2COBBCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCOBBCollisionInstance@@@8
data$r	SEGMENT
??_R0?AVCOBBCollisionInstance@@@8 DD FLAT:??_7type_info@@6B@ ; COBBCollisionInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCOBBCollisionInstance@@', 00H
data$r	ENDS
;	COMDAT ??_R4COBBCollisionInstance@@6B@
rdata$r	SEGMENT
??_R4COBBCollisionInstance@@6B@ DD 00H			; COBBCollisionInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCOBBCollisionInstance@@@8
	DD	FLAT:??_R3COBBCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CAABBCollisionInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CAABBCollisionInstance@@8 DD FLAT:??_R0?AVCAABBCollisionInstance@@@8 ; CAABBCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CAABBCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CAABBCollisionInstance@@8
rdata$r	SEGMENT
??_R2CAABBCollisionInstance@@8 DD FLAT:??_R1A@?0A@EA@CAABBCollisionInstance@@8 ; CAABBCollisionInstance::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R3CAABBCollisionInstance@@8
rdata$r	SEGMENT
??_R3CAABBCollisionInstance@@8 DD 00H			; CAABBCollisionInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CAABBCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCAABBCollisionInstance@@@8
data$r	SEGMENT
??_R0?AVCAABBCollisionInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CAABBCollisionInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAABBCollisionInstance@@', 00H
data$r	ENDS
;	COMDAT ??_R4CAABBCollisionInstance@@6B@
rdata$r	SEGMENT
??_R4CAABBCollisionInstance@@6B@ DD 00H			; CAABBCollisionInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCAABBCollisionInstance@@@8
	DD	FLAT:??_R3CAABBCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CPlaneCollisionInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CPlaneCollisionInstance@@8 DD FLAT:??_R0?AVCPlaneCollisionInstance@@@8 ; CPlaneCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CPlaneCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CPlaneCollisionInstance@@8
rdata$r	SEGMENT
??_R2CPlaneCollisionInstance@@8 DD FLAT:??_R1A@?0A@EA@CPlaneCollisionInstance@@8 ; CPlaneCollisionInstance::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R3CPlaneCollisionInstance@@8
rdata$r	SEGMENT
??_R3CPlaneCollisionInstance@@8 DD 00H			; CPlaneCollisionInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CPlaneCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPlaneCollisionInstance@@@8
data$r	SEGMENT
??_R0?AVCPlaneCollisionInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CPlaneCollisionInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPlaneCollisionInstance@@', 00H
data$r	ENDS
;	COMDAT ??_R4CPlaneCollisionInstance@@6B@
rdata$r	SEGMENT
??_R4CPlaneCollisionInstance@@6B@ DD 00H		; CPlaneCollisionInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCPlaneCollisionInstance@@@8
	DD	FLAT:??_R3CPlaneCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CSphereCollisionInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CSphereCollisionInstance@@8 DD FLAT:??_R0?AVCSphereCollisionInstance@@@8 ; CSphereCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CSphereCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CSphereCollisionInstance@@8
rdata$r	SEGMENT
??_R2CSphereCollisionInstance@@8 DD FLAT:??_R1A@?0A@EA@CSphereCollisionInstance@@8 ; CSphereCollisionInstance::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R3CSphereCollisionInstance@@8
rdata$r	SEGMENT
??_R3CSphereCollisionInstance@@8 DD 00H			; CSphereCollisionInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CSphereCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCSphereCollisionInstance@@@8
data$r	SEGMENT
??_R0?AVCSphereCollisionInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CSphereCollisionInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCSphereCollisionInstance@@', 00H
data$r	ENDS
;	COMDAT ??_R4CSphereCollisionInstance@@6B@
rdata$r	SEGMENT
??_R4CSphereCollisionInstance@@6B@ DD 00H		; CSphereCollisionInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCSphereCollisionInstance@@@8
	DD	FLAT:??_R3CSphereCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CBaseCollisionInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CBaseCollisionInstance@@8 DD FLAT:??_R0?AVCBaseCollisionInstance@@@8 ; CBaseCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CBaseCollisionInstance@@8
rdata$r	SEGMENT
??_R2CBaseCollisionInstance@@8 DD FLAT:??_R1A@?0A@EA@CBaseCollisionInstance@@8 ; CBaseCollisionInstance::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CBaseCollisionInstance@@8
rdata$r	SEGMENT
??_R3CBaseCollisionInstance@@8 DD 00H			; CBaseCollisionInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCBaseCollisionInstance@@@8
data$r	SEGMENT
??_R0?AVCBaseCollisionInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CBaseCollisionInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCBaseCollisionInstance@@', 00H
data$r	ENDS
;	COMDAT ??_R4CBaseCollisionInstance@@6B@
rdata$r	SEGMENT
??_R4CBaseCollisionInstance@@6B@ DD 00H			; CBaseCollisionInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCBaseCollisionInstance@@@8
	DD	FLAT:??_R3CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCOBBCollisionInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCOBBCollisionInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCOBBCollisionInstance@@@@6B@ ; CDynamicPool<COBBCollisionInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCOBBCollisionInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCAABBCollisionInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCAABBCollisionInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCAABBCollisionInstance@@@@6B@ ; CDynamicPool<CAABBCollisionInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCAABBCollisionInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@ ; CDynamicPool<CPlaneCollisionInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCPlaneCollisionInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@ ; CDynamicPool<CCylinderCollisionInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCCylinderCollisionInstance@@@@UAEPAXI@Z
CONST	ENDS
_DATA	SEGMENT
?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A DD FLAT:??_7?$CDynamicPool@VCSphereCollisionInstance@@@@6B@ ; gs_sci
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A DD FLAT:??_7?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@ ; gs_cci
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A DD FLAT:??_7?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@ ; gs_pci
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A DD FLAT:??_7?$CDynamicPool@VCAABBCollisionInstance@@@@6B@ ; gs_aci
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A DD FLAT:??_7?$CDynamicPool@VCOBBCollisionInstance@@@@6B@ ; gs_oci
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPool@VCSphereCollisionInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCSphereCollisionInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCSphereCollisionInstance@@@@6B@ ; CDynamicPool<CSphereCollisionInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCSphereCollisionInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CCylinderCollisionInstance@@6B@
CONST	SEGMENT
??_7CCylinderCollisionInstance@@6B@ DD FLAT:??_R4CCylinderCollisionInstance@@6B@ ; CCylinderCollisionInstance::`vftable'
	DD	FLAT:?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	FLAT:?OnGetCollisionMovementAdjust@CCylinderCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnMovementCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnDestroy@CCylinderCollisionInstance@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7COBBCollisionInstance@@6B@
CONST	SEGMENT
??_7COBBCollisionInstance@@6B@ DD FLAT:??_R4COBBCollisionInstance@@6B@ ; COBBCollisionInstance::`vftable'
	DD	FLAT:?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	FLAT:?OnGetCollisionMovementAdjust@COBBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnMovementCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnDestroy@COBBCollisionInstance@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7CAABBCollisionInstance@@6B@
CONST	SEGMENT
??_7CAABBCollisionInstance@@6B@ DD FLAT:??_R4CAABBCollisionInstance@@6B@ ; CAABBCollisionInstance::`vftable'
	DD	FLAT:?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	FLAT:?OnGetCollisionMovementAdjust@CAABBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnMovementCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnDestroy@CAABBCollisionInstance@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7CPlaneCollisionInstance@@6B@
CONST	SEGMENT
??_7CPlaneCollisionInstance@@6B@ DD FLAT:??_R4CPlaneCollisionInstance@@6B@ ; CPlaneCollisionInstance::`vftable'
	DD	FLAT:?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	FLAT:?OnGetCollisionMovementAdjust@CPlaneCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnMovementCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnDestroy@CPlaneCollisionInstance@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7CSphereCollisionInstance@@6B@
CONST	SEGMENT
??_7CSphereCollisionInstance@@6B@ DD FLAT:??_R4CSphereCollisionInstance@@6B@ ; CSphereCollisionInstance::`vftable'
	DD	FLAT:?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	FLAT:?OnGetCollisionMovementAdjust@CSphereCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnMovementCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnDestroy@CSphereCollisionInstance@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7CBaseCollisionInstance@@6B@
CONST	SEGMENT
??_7CBaseCollisionInstance@@6B@ DD FLAT:??_R4CBaseCollisionInstance@@6B@ ; CBaseCollisionInstance::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0
__ehfuncinfo$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0
__ehfuncinfo$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0
__ehfuncinfo$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0
__ehfuncinfo$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0
__ehfuncinfo$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
_gs_cci$initializer$ DD FLAT:??__Egs_cci@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_gs_pci$initializer$ DD FLAT:??__Egs_pci@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_gs_aci$initializer$ DD FLAT:??__Egs_aci@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_gs_oci$initializer$ DD FLAT:??__Egs_oci@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVCOBBCollisionInstance@@PAV1@PAV1@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCOBBCollisionInstance@@PAV1@PAV1@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<COBBCollisionInstance *,COBBCollisionInstance *,COBBCollisionInstance *>, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 470  : 	_DEBUG_RANGE(_First, _Last);
; 471  : 	_DEBUG_POINTER(_Dest);
; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 475  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAVCOBBCollisionInstance@@PAV1@PAV1@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<COBBCollisionInstance *,COBBCollisionInstance *,COBBCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVCOBBCollisionInstance@@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVCOBBCollisionInstance@@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@@Z PROC ; std::_Val_type<COBBCollisionInstance * *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAVCOBBCollisionInstance@@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@@Z ENDP ; std::_Val_type<COBBCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVCAABBCollisionInstance@@PAV1@PAV1@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCAABBCollisionInstance@@PAV1@PAV1@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CAABBCollisionInstance *,CAABBCollisionInstance *,CAABBCollisionInstance *>, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 470  : 	_DEBUG_RANGE(_First, _Last);
; 471  : 	_DEBUG_POINTER(_Dest);
; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 475  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAVCAABBCollisionInstance@@PAV1@PAV1@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CAABBCollisionInstance *,CAABBCollisionInstance *,CAABBCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVCAABBCollisionInstance@@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVCAABBCollisionInstance@@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@@Z PROC ; std::_Val_type<CAABBCollisionInstance * *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAVCAABBCollisionInstance@@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@@Z ENDP ; std::_Val_type<CAABBCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVCPlaneCollisionInstance@@PAV1@PAV1@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCPlaneCollisionInstance@@PAV1@PAV1@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CPlaneCollisionInstance *,CPlaneCollisionInstance *,CPlaneCollisionInstance *>, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 470  : 	_DEBUG_RANGE(_First, _Last);
; 471  : 	_DEBUG_POINTER(_Dest);
; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 475  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAVCPlaneCollisionInstance@@PAV1@PAV1@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CPlaneCollisionInstance *,CPlaneCollisionInstance *,CPlaneCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVCPlaneCollisionInstance@@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVCPlaneCollisionInstance@@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@@Z PROC ; std::_Val_type<CPlaneCollisionInstance * *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAVCPlaneCollisionInstance@@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@@Z ENDP ; std::_Val_type<CPlaneCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVCCylinderCollisionInstance@@PAV1@PAV1@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCCylinderCollisionInstance@@PAV1@PAV1@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CCylinderCollisionInstance *,CCylinderCollisionInstance *,CCylinderCollisionInstance *>, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 470  : 	_DEBUG_RANGE(_First, _Last);
; 471  : 	_DEBUG_POINTER(_Dest);
; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 475  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAVCCylinderCollisionInstance@@PAV1@PAV1@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CCylinderCollisionInstance *,CCylinderCollisionInstance *,CCylinderCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVCCylinderCollisionInstance@@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVCCylinderCollisionInstance@@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@@Z PROC ; std::_Val_type<CCylinderCollisionInstance * *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAVCCylinderCollisionInstance@@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@@Z ENDP ; std::_Val_type<CCylinderCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVCSphereCollisionInstance@@PAV1@PAV1@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCSphereCollisionInstance@@PAV1@PAV1@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CSphereCollisionInstance *,CSphereCollisionInstance *,CSphereCollisionInstance *>, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 470  : 	_DEBUG_RANGE(_First, _Last);
; 471  : 	_DEBUG_POINTER(_Dest);
; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 475  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAVCSphereCollisionInstance@@PAV1@PAV1@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CSphereCollisionInstance *,CSphereCollisionInstance *,CSphereCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVCSphereCollisionInstance@@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVCSphereCollisionInstance@@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@@Z PROC ; std::_Val_type<CSphereCollisionInstance * *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAVCSphereCollisionInstance@@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@@Z ENDP ; std::_Val_type<CSphereCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAVCOBBCollisionInstance@@PAPAV1@@std@@YAAAPAPAVCOBBCollisionInstance@@AAPAPAV1@PAPAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAVCOBBCollisionInstance@@PAPAV1@@std@@YAAAPAPAVCOBBCollisionInstance@@AAPAPAV1@PAPAV1@@Z PROC ; std::_Rechecked<COBBCollisionInstance * *,COBBCollisionInstance * *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAPAVCOBBCollisionInstance@@PAPAV1@@std@@YAAAPAPAVCOBBCollisionInstance@@AAPAPAV1@PAPAV1@@Z ENDP ; std::_Rechecked<COBBCollisionInstance * *,COBBCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAPAVCOBBCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAPAVCOBBCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@0@@Z PROC ; std::_Uninit_move<COBBCollisionInstance * *,COBBCollisionInstance * *,std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAPAVCOBBCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@0@@Z ENDP ; std::_Uninit_move<COBBCollisionInstance * *,COBBCollisionInstance * *,std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAVCOBBCollisionInstance@@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAVCOBBCollisionInstance@@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@@Z PROC ; std::_Unchecked<COBBCollisionInstance * *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAPAVCOBBCollisionInstance@@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@@Z ENDP ; std::_Unchecked<COBBCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAVCAABBCollisionInstance@@PAPAV1@@std@@YAAAPAPAVCAABBCollisionInstance@@AAPAPAV1@PAPAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAVCAABBCollisionInstance@@PAPAV1@@std@@YAAAPAPAVCAABBCollisionInstance@@AAPAPAV1@PAPAV1@@Z PROC ; std::_Rechecked<CAABBCollisionInstance * *,CAABBCollisionInstance * *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAPAVCAABBCollisionInstance@@PAPAV1@@std@@YAAAPAPAVCAABBCollisionInstance@@AAPAPAV1@PAPAV1@@Z ENDP ; std::_Rechecked<CAABBCollisionInstance * *,CAABBCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAPAVCAABBCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAPAVCAABBCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@0@@Z PROC ; std::_Uninit_move<CAABBCollisionInstance * *,CAABBCollisionInstance * *,std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAPAVCAABBCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@0@@Z ENDP ; std::_Uninit_move<CAABBCollisionInstance * *,CAABBCollisionInstance * *,std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAVCAABBCollisionInstance@@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAVCAABBCollisionInstance@@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@@Z PROC ; std::_Unchecked<CAABBCollisionInstance * *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAPAVCAABBCollisionInstance@@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@@Z ENDP ; std::_Unchecked<CAABBCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAVCPlaneCollisionInstance@@PAPAV1@@std@@YAAAPAPAVCPlaneCollisionInstance@@AAPAPAV1@PAPAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAVCPlaneCollisionInstance@@PAPAV1@@std@@YAAAPAPAVCPlaneCollisionInstance@@AAPAPAV1@PAPAV1@@Z PROC ; std::_Rechecked<CPlaneCollisionInstance * *,CPlaneCollisionInstance * *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAPAVCPlaneCollisionInstance@@PAPAV1@@std@@YAAAPAPAVCPlaneCollisionInstance@@AAPAPAV1@PAPAV1@@Z ENDP ; std::_Rechecked<CPlaneCollisionInstance * *,CPlaneCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAPAVCPlaneCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAPAVCPlaneCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@0@@Z PROC ; std::_Uninit_move<CPlaneCollisionInstance * *,CPlaneCollisionInstance * *,std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAPAVCPlaneCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@0@@Z ENDP ; std::_Uninit_move<CPlaneCollisionInstance * *,CPlaneCollisionInstance * *,std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAVCPlaneCollisionInstance@@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAVCPlaneCollisionInstance@@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@@Z PROC ; std::_Unchecked<CPlaneCollisionInstance * *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAPAVCPlaneCollisionInstance@@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@@Z ENDP ; std::_Unchecked<CPlaneCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAVCCylinderCollisionInstance@@PAPAV1@@std@@YAAAPAPAVCCylinderCollisionInstance@@AAPAPAV1@PAPAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAVCCylinderCollisionInstance@@PAPAV1@@std@@YAAAPAPAVCCylinderCollisionInstance@@AAPAPAV1@PAPAV1@@Z PROC ; std::_Rechecked<CCylinderCollisionInstance * *,CCylinderCollisionInstance * *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAPAVCCylinderCollisionInstance@@PAPAV1@@std@@YAAAPAPAVCCylinderCollisionInstance@@AAPAPAV1@PAPAV1@@Z ENDP ; std::_Rechecked<CCylinderCollisionInstance * *,CCylinderCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAPAVCCylinderCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAPAVCCylinderCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@0@@Z PROC ; std::_Uninit_move<CCylinderCollisionInstance * *,CCylinderCollisionInstance * *,std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAPAVCCylinderCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@0@@Z ENDP ; std::_Uninit_move<CCylinderCollisionInstance * *,CCylinderCollisionInstance * *,std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAVCCylinderCollisionInstance@@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAVCCylinderCollisionInstance@@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@@Z PROC ; std::_Unchecked<CCylinderCollisionInstance * *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAPAVCCylinderCollisionInstance@@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@@Z ENDP ; std::_Unchecked<CCylinderCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAVCSphereCollisionInstance@@PAPAV1@@std@@YAAAPAPAVCSphereCollisionInstance@@AAPAPAV1@PAPAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAVCSphereCollisionInstance@@PAPAV1@@std@@YAAAPAPAVCSphereCollisionInstance@@AAPAPAV1@PAPAV1@@Z PROC ; std::_Rechecked<CSphereCollisionInstance * *,CSphereCollisionInstance * *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAPAVCSphereCollisionInstance@@PAPAV1@@std@@YAAAPAPAVCSphereCollisionInstance@@AAPAPAV1@PAPAV1@@Z ENDP ; std::_Rechecked<CSphereCollisionInstance * *,CSphereCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAPAVCSphereCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAPAVCSphereCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@0@@Z PROC ; std::_Uninit_move<CSphereCollisionInstance * *,CSphereCollisionInstance * *,std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAPAVCSphereCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@0@@Z ENDP ; std::_Uninit_move<CSphereCollisionInstance * *,CSphereCollisionInstance * *,std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAVCSphereCollisionInstance@@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAVCSphereCollisionInstance@@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@@Z PROC ; std::_Unchecked<CSphereCollisionInstance * *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAPAVCSphereCollisionInstance@@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@@Z ENDP ; std::_Unchecked<CSphereCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCOBBCollisionInstance@@@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEXPAPAVCOBBCollisionInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVCOBBCollisionInstance@@@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEXPAPAVCOBBCollisionInstance@@@Z PROC ; std::allocator<COBBCollisionInstance *>::destroy<COBBCollisionInstance *>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAVCOBBCollisionInstance@@@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEXPAPAVCOBBCollisionInstance@@@Z ENDP ; std::allocator<COBBCollisionInstance *>::destroy<COBBCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCOBBCollisionInstance@@AAPAV1@@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEXPAPAVCOBBCollisionInstance@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCOBBCollisionInstance@@AAPAV1@@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEXPAPAVCOBBCollisionInstance@@AAPAV2@@Z PROC ; std::allocator<COBBCollisionInstance *>::construct<COBBCollisionInstance *,COBBCollisionInstance * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCOBBCollisionInstance@@AAPAV1@@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEXPAPAVCOBBCollisionInstance@@AAPAV2@@Z ENDP ; std::allocator<COBBCollisionInstance *>::construct<COBBCollisionInstance *,COBBCollisionInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCAABBCollisionInstance@@@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEXPAPAVCAABBCollisionInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVCAABBCollisionInstance@@@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEXPAPAVCAABBCollisionInstance@@@Z PROC ; std::allocator<CAABBCollisionInstance *>::destroy<CAABBCollisionInstance *>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAVCAABBCollisionInstance@@@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEXPAPAVCAABBCollisionInstance@@@Z ENDP ; std::allocator<CAABBCollisionInstance *>::destroy<CAABBCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCAABBCollisionInstance@@AAPAV1@@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEXPAPAVCAABBCollisionInstance@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCAABBCollisionInstance@@AAPAV1@@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEXPAPAVCAABBCollisionInstance@@AAPAV2@@Z PROC ; std::allocator<CAABBCollisionInstance *>::construct<CAABBCollisionInstance *,CAABBCollisionInstance * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCAABBCollisionInstance@@AAPAV1@@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEXPAPAVCAABBCollisionInstance@@AAPAV2@@Z ENDP ; std::allocator<CAABBCollisionInstance *>::construct<CAABBCollisionInstance *,CAABBCollisionInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCPlaneCollisionInstance@@@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEXPAPAVCPlaneCollisionInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVCPlaneCollisionInstance@@@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEXPAPAVCPlaneCollisionInstance@@@Z PROC ; std::allocator<CPlaneCollisionInstance *>::destroy<CPlaneCollisionInstance *>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAVCPlaneCollisionInstance@@@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEXPAPAVCPlaneCollisionInstance@@@Z ENDP ; std::allocator<CPlaneCollisionInstance *>::destroy<CPlaneCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCPlaneCollisionInstance@@AAPAV1@@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEXPAPAVCPlaneCollisionInstance@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCPlaneCollisionInstance@@AAPAV1@@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEXPAPAVCPlaneCollisionInstance@@AAPAV2@@Z PROC ; std::allocator<CPlaneCollisionInstance *>::construct<CPlaneCollisionInstance *,CPlaneCollisionInstance * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCPlaneCollisionInstance@@AAPAV1@@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEXPAPAVCPlaneCollisionInstance@@AAPAV2@@Z ENDP ; std::allocator<CPlaneCollisionInstance *>::construct<CPlaneCollisionInstance *,CPlaneCollisionInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCCylinderCollisionInstance@@@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEXPAPAVCCylinderCollisionInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVCCylinderCollisionInstance@@@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEXPAPAVCCylinderCollisionInstance@@@Z PROC ; std::allocator<CCylinderCollisionInstance *>::destroy<CCylinderCollisionInstance *>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAVCCylinderCollisionInstance@@@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEXPAPAVCCylinderCollisionInstance@@@Z ENDP ; std::allocator<CCylinderCollisionInstance *>::destroy<CCylinderCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCCylinderCollisionInstance@@AAPAV1@@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEXPAPAVCCylinderCollisionInstance@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCCylinderCollisionInstance@@AAPAV1@@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEXPAPAVCCylinderCollisionInstance@@AAPAV2@@Z PROC ; std::allocator<CCylinderCollisionInstance *>::construct<CCylinderCollisionInstance *,CCylinderCollisionInstance * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCCylinderCollisionInstance@@AAPAV1@@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEXPAPAVCCylinderCollisionInstance@@AAPAV2@@Z ENDP ; std::allocator<CCylinderCollisionInstance *>::construct<CCylinderCollisionInstance *,CCylinderCollisionInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCSphereCollisionInstance@@@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEXPAPAVCSphereCollisionInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVCSphereCollisionInstance@@@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEXPAPAVCSphereCollisionInstance@@@Z PROC ; std::allocator<CSphereCollisionInstance *>::destroy<CSphereCollisionInstance *>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAVCSphereCollisionInstance@@@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEXPAPAVCSphereCollisionInstance@@@Z ENDP ; std::allocator<CSphereCollisionInstance *>::destroy<CSphereCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCSphereCollisionInstance@@AAPAV1@@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEXPAPAVCSphereCollisionInstance@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCSphereCollisionInstance@@AAPAV1@@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEXPAPAVCSphereCollisionInstance@@AAPAV2@@Z PROC ; std::allocator<CSphereCollisionInstance *>::construct<CSphereCollisionInstance *,CSphereCollisionInstance * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCSphereCollisionInstance@@AAPAV1@@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEXPAPAVCSphereCollisionInstance@@AAPAV2@@Z ENDP ; std::allocator<CSphereCollisionInstance *>::construct<CSphereCollisionInstance *,CSphereCollisionInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCOBBCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCOBBCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@0@@Z PROC ; std::_Uninitialized_move<COBBCollisionInstance * *,COBBCollisionInstance * *,std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninitialized_move@PAPAVCOBBCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<COBBCollisionInstance * *,COBBCollisionInstance * *,std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCAABBCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCAABBCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@0@@Z PROC ; std::_Uninitialized_move<CAABBCollisionInstance * *,CAABBCollisionInstance * *,std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninitialized_move@PAPAVCAABBCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<CAABBCollisionInstance * *,CAABBCollisionInstance * *,std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCPlaneCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCPlaneCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@0@@Z PROC ; std::_Uninitialized_move<CPlaneCollisionInstance * *,CPlaneCollisionInstance * *,std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninitialized_move@PAPAVCPlaneCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<CPlaneCollisionInstance * *,CPlaneCollisionInstance * *,std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCCylinderCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCCylinderCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@0@@Z PROC ; std::_Uninitialized_move<CCylinderCollisionInstance * *,CCylinderCollisionInstance * *,std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninitialized_move@PAPAVCCylinderCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<CCylinderCollisionInstance * *,CCylinderCollisionInstance * *,std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCSphereCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCSphereCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@0@@Z PROC ; std::_Uninitialized_move<CSphereCollisionInstance * *,CSphereCollisionInstance * *,std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninitialized_move@PAPAVCSphereCollisionInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<CSphereCollisionInstance * *,CSphereCollisionInstance * *,std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCOBBCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCOBBCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCOBBCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCOBBCollisionInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCOBBCollisionInstance@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCOBBCollisionInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCOBBCollisionInstance@@0@Z PROC ; std::_Ptr_cat<COBBCollisionInstance *,COBBCollisionInstance *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCOBBCollisionInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCOBBCollisionInstance@@0@Z ENDP ; std::_Ptr_cat<COBBCollisionInstance *,COBBCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCAABBCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCAABBCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCAABBCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCAABBCollisionInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCAABBCollisionInstance@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCAABBCollisionInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCAABBCollisionInstance@@0@Z PROC ; std::_Ptr_cat<CAABBCollisionInstance *,CAABBCollisionInstance *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCAABBCollisionInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCAABBCollisionInstance@@0@Z ENDP ; std::_Ptr_cat<CAABBCollisionInstance *,CAABBCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCPlaneCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCPlaneCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCPlaneCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCPlaneCollisionInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCPlaneCollisionInstance@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCPlaneCollisionInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCPlaneCollisionInstance@@0@Z PROC ; std::_Ptr_cat<CPlaneCollisionInstance *,CPlaneCollisionInstance *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCPlaneCollisionInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCPlaneCollisionInstance@@0@Z ENDP ; std::_Ptr_cat<CPlaneCollisionInstance *,CPlaneCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCCylinderCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCCylinderCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCCylinderCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCCylinderCollisionInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCCylinderCollisionInstance@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCCylinderCollisionInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCCylinderCollisionInstance@@0@Z PROC ; std::_Ptr_cat<CCylinderCollisionInstance *,CCylinderCollisionInstance *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCCylinderCollisionInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCCylinderCollisionInstance@@0@Z ENDP ; std::_Ptr_cat<CCylinderCollisionInstance *,CCylinderCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCSphereCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCSphereCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCSphereCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCSphereCollisionInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCSphereCollisionInstance@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCSphereCollisionInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCSphereCollisionInstance@@0@Z PROC ; std::_Ptr_cat<CSphereCollisionInstance *,CSphereCollisionInstance *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCSphereCollisionInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCSphereCollisionInstance@@0@Z ENDP ; std::_Ptr_cat<CSphereCollisionInstance *,CSphereCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCOBBCollisionInstance@@@?$allocator_traits@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCOBBCollisionInstance@@@1@PAPAVCOBBCollisionInstance@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAVCOBBCollisionInstance@@@?$allocator_traits@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCOBBCollisionInstance@@@1@PAPAVCOBBCollisionInstance@@@Z PROC ; std::allocator_traits<std::allocator<COBBCollisionInstance *> >::destroy<COBBCollisionInstance *>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@PAVCOBBCollisionInstance@@@?$allocator_traits@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCOBBCollisionInstance@@@1@PAPAVCOBBCollisionInstance@@@Z ENDP ; std::allocator_traits<std::allocator<COBBCollisionInstance *> >::destroy<COBBCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCOBBCollisionInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCOBBCollisionInstance@@@1@PAPAVCOBBCollisionInstance@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCOBBCollisionInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCOBBCollisionInstance@@@1@PAPAVCOBBCollisionInstance@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<COBBCollisionInstance *> >::construct<COBBCollisionInstance *,COBBCollisionInstance * const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCOBBCollisionInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCOBBCollisionInstance@@@1@PAPAVCOBBCollisionInstance@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<COBBCollisionInstance *> >::construct<COBBCollisionInstance *,COBBCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAVCOBBCollisionInstance@@@std@@YAABQAVCOBBCollisionInstance@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVCOBBCollisionInstance@@@std@@YAABQAVCOBBCollisionInstance@@ABQAV1@@Z PROC ; std::forward<COBBCollisionInstance * const &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAVCOBBCollisionInstance@@@std@@YAABQAVCOBBCollisionInstance@@ABQAV1@@Z ENDP ; std::forward<COBBCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCOBBCollisionInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCOBBCollisionInstance@@@1@PAPAVCOBBCollisionInstance@@AAPAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCOBBCollisionInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCOBBCollisionInstance@@@1@PAPAVCOBBCollisionInstance@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<COBBCollisionInstance *> >::construct<COBBCollisionInstance *,COBBCollisionInstance * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCOBBCollisionInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCOBBCollisionInstance@@@1@PAPAVCOBBCollisionInstance@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<COBBCollisionInstance *> >::construct<COBBCollisionInstance *,COBBCollisionInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAVCOBBCollisionInstance@@@std@@YAAAPAVCOBBCollisionInstance@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVCOBBCollisionInstance@@@std@@YAAAPAVCOBBCollisionInstance@@AAPAV1@@Z PROC ; std::forward<COBBCollisionInstance * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAVCOBBCollisionInstance@@@std@@YAAAPAVCOBBCollisionInstance@@AAPAV1@@Z ENDP ; std::forward<COBBCollisionInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCAABBCollisionInstance@@@?$allocator_traits@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCAABBCollisionInstance@@@1@PAPAVCAABBCollisionInstance@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAVCAABBCollisionInstance@@@?$allocator_traits@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCAABBCollisionInstance@@@1@PAPAVCAABBCollisionInstance@@@Z PROC ; std::allocator_traits<std::allocator<CAABBCollisionInstance *> >::destroy<CAABBCollisionInstance *>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@PAVCAABBCollisionInstance@@@?$allocator_traits@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCAABBCollisionInstance@@@1@PAPAVCAABBCollisionInstance@@@Z ENDP ; std::allocator_traits<std::allocator<CAABBCollisionInstance *> >::destroy<CAABBCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCAABBCollisionInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCAABBCollisionInstance@@@1@PAPAVCAABBCollisionInstance@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCAABBCollisionInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCAABBCollisionInstance@@@1@PAPAVCAABBCollisionInstance@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<CAABBCollisionInstance *> >::construct<CAABBCollisionInstance *,CAABBCollisionInstance * const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCAABBCollisionInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCAABBCollisionInstance@@@1@PAPAVCAABBCollisionInstance@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<CAABBCollisionInstance *> >::construct<CAABBCollisionInstance *,CAABBCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAVCAABBCollisionInstance@@@std@@YAABQAVCAABBCollisionInstance@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVCAABBCollisionInstance@@@std@@YAABQAVCAABBCollisionInstance@@ABQAV1@@Z PROC ; std::forward<CAABBCollisionInstance * const &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAVCAABBCollisionInstance@@@std@@YAABQAVCAABBCollisionInstance@@ABQAV1@@Z ENDP ; std::forward<CAABBCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCAABBCollisionInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCAABBCollisionInstance@@@1@PAPAVCAABBCollisionInstance@@AAPAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCAABBCollisionInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCAABBCollisionInstance@@@1@PAPAVCAABBCollisionInstance@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<CAABBCollisionInstance *> >::construct<CAABBCollisionInstance *,CAABBCollisionInstance * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCAABBCollisionInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCAABBCollisionInstance@@@1@PAPAVCAABBCollisionInstance@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<CAABBCollisionInstance *> >::construct<CAABBCollisionInstance *,CAABBCollisionInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAVCAABBCollisionInstance@@@std@@YAAAPAVCAABBCollisionInstance@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVCAABBCollisionInstance@@@std@@YAAAPAVCAABBCollisionInstance@@AAPAV1@@Z PROC ; std::forward<CAABBCollisionInstance * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAVCAABBCollisionInstance@@@std@@YAAAPAVCAABBCollisionInstance@@AAPAV1@@Z ENDP ; std::forward<CAABBCollisionInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCPlaneCollisionInstance@@@?$allocator_traits@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCPlaneCollisionInstance@@@1@PAPAVCPlaneCollisionInstance@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAVCPlaneCollisionInstance@@@?$allocator_traits@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCPlaneCollisionInstance@@@1@PAPAVCPlaneCollisionInstance@@@Z PROC ; std::allocator_traits<std::allocator<CPlaneCollisionInstance *> >::destroy<CPlaneCollisionInstance *>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@PAVCPlaneCollisionInstance@@@?$allocator_traits@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCPlaneCollisionInstance@@@1@PAPAVCPlaneCollisionInstance@@@Z ENDP ; std::allocator_traits<std::allocator<CPlaneCollisionInstance *> >::destroy<CPlaneCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCPlaneCollisionInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCPlaneCollisionInstance@@@1@PAPAVCPlaneCollisionInstance@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCPlaneCollisionInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCPlaneCollisionInstance@@@1@PAPAVCPlaneCollisionInstance@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<CPlaneCollisionInstance *> >::construct<CPlaneCollisionInstance *,CPlaneCollisionInstance * const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCPlaneCollisionInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCPlaneCollisionInstance@@@1@PAPAVCPlaneCollisionInstance@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<CPlaneCollisionInstance *> >::construct<CPlaneCollisionInstance *,CPlaneCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAVCPlaneCollisionInstance@@@std@@YAABQAVCPlaneCollisionInstance@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVCPlaneCollisionInstance@@@std@@YAABQAVCPlaneCollisionInstance@@ABQAV1@@Z PROC ; std::forward<CPlaneCollisionInstance * const &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAVCPlaneCollisionInstance@@@std@@YAABQAVCPlaneCollisionInstance@@ABQAV1@@Z ENDP ; std::forward<CPlaneCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCPlaneCollisionInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCPlaneCollisionInstance@@@1@PAPAVCPlaneCollisionInstance@@AAPAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCPlaneCollisionInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCPlaneCollisionInstance@@@1@PAPAVCPlaneCollisionInstance@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<CPlaneCollisionInstance *> >::construct<CPlaneCollisionInstance *,CPlaneCollisionInstance * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCPlaneCollisionInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCPlaneCollisionInstance@@@1@PAPAVCPlaneCollisionInstance@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<CPlaneCollisionInstance *> >::construct<CPlaneCollisionInstance *,CPlaneCollisionInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAVCPlaneCollisionInstance@@@std@@YAAAPAVCPlaneCollisionInstance@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVCPlaneCollisionInstance@@@std@@YAAAPAVCPlaneCollisionInstance@@AAPAV1@@Z PROC ; std::forward<CPlaneCollisionInstance * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAVCPlaneCollisionInstance@@@std@@YAAAPAVCPlaneCollisionInstance@@AAPAV1@@Z ENDP ; std::forward<CPlaneCollisionInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCCylinderCollisionInstance@@@?$allocator_traits@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCCylinderCollisionInstance@@@1@PAPAVCCylinderCollisionInstance@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAVCCylinderCollisionInstance@@@?$allocator_traits@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCCylinderCollisionInstance@@@1@PAPAVCCylinderCollisionInstance@@@Z PROC ; std::allocator_traits<std::allocator<CCylinderCollisionInstance *> >::destroy<CCylinderCollisionInstance *>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@PAVCCylinderCollisionInstance@@@?$allocator_traits@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCCylinderCollisionInstance@@@1@PAPAVCCylinderCollisionInstance@@@Z ENDP ; std::allocator_traits<std::allocator<CCylinderCollisionInstance *> >::destroy<CCylinderCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCCylinderCollisionInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCCylinderCollisionInstance@@@1@PAPAVCCylinderCollisionInstance@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCCylinderCollisionInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCCylinderCollisionInstance@@@1@PAPAVCCylinderCollisionInstance@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<CCylinderCollisionInstance *> >::construct<CCylinderCollisionInstance *,CCylinderCollisionInstance * const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCCylinderCollisionInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCCylinderCollisionInstance@@@1@PAPAVCCylinderCollisionInstance@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<CCylinderCollisionInstance *> >::construct<CCylinderCollisionInstance *,CCylinderCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAVCCylinderCollisionInstance@@@std@@YAABQAVCCylinderCollisionInstance@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVCCylinderCollisionInstance@@@std@@YAABQAVCCylinderCollisionInstance@@ABQAV1@@Z PROC ; std::forward<CCylinderCollisionInstance * const &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAVCCylinderCollisionInstance@@@std@@YAABQAVCCylinderCollisionInstance@@ABQAV1@@Z ENDP ; std::forward<CCylinderCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCCylinderCollisionInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCCylinderCollisionInstance@@@1@PAPAVCCylinderCollisionInstance@@AAPAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCCylinderCollisionInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCCylinderCollisionInstance@@@1@PAPAVCCylinderCollisionInstance@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<CCylinderCollisionInstance *> >::construct<CCylinderCollisionInstance *,CCylinderCollisionInstance * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCCylinderCollisionInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCCylinderCollisionInstance@@@1@PAPAVCCylinderCollisionInstance@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<CCylinderCollisionInstance *> >::construct<CCylinderCollisionInstance *,CCylinderCollisionInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAVCCylinderCollisionInstance@@@std@@YAAAPAVCCylinderCollisionInstance@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVCCylinderCollisionInstance@@@std@@YAAAPAVCCylinderCollisionInstance@@AAPAV1@@Z PROC ; std::forward<CCylinderCollisionInstance * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAVCCylinderCollisionInstance@@@std@@YAAAPAVCCylinderCollisionInstance@@AAPAV1@@Z ENDP ; std::forward<CCylinderCollisionInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCSphereCollisionInstance@@@?$allocator_traits@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCSphereCollisionInstance@@@1@PAPAVCSphereCollisionInstance@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAVCSphereCollisionInstance@@@?$allocator_traits@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCSphereCollisionInstance@@@1@PAPAVCSphereCollisionInstance@@@Z PROC ; std::allocator_traits<std::allocator<CSphereCollisionInstance *> >::destroy<CSphereCollisionInstance *>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@PAVCSphereCollisionInstance@@@?$allocator_traits@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCSphereCollisionInstance@@@1@PAPAVCSphereCollisionInstance@@@Z ENDP ; std::allocator_traits<std::allocator<CSphereCollisionInstance *> >::destroy<CSphereCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCSphereCollisionInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCSphereCollisionInstance@@@1@PAPAVCSphereCollisionInstance@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCSphereCollisionInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCSphereCollisionInstance@@@1@PAPAVCSphereCollisionInstance@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<CSphereCollisionInstance *> >::construct<CSphereCollisionInstance *,CSphereCollisionInstance * const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCSphereCollisionInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCSphereCollisionInstance@@@1@PAPAVCSphereCollisionInstance@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<CSphereCollisionInstance *> >::construct<CSphereCollisionInstance *,CSphereCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAVCSphereCollisionInstance@@@std@@YAABQAVCSphereCollisionInstance@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVCSphereCollisionInstance@@@std@@YAABQAVCSphereCollisionInstance@@ABQAV1@@Z PROC ; std::forward<CSphereCollisionInstance * const &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAVCSphereCollisionInstance@@@std@@YAABQAVCSphereCollisionInstance@@ABQAV1@@Z ENDP ; std::forward<CSphereCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCSphereCollisionInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCSphereCollisionInstance@@@1@PAPAVCSphereCollisionInstance@@AAPAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCSphereCollisionInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCSphereCollisionInstance@@@1@PAPAVCSphereCollisionInstance@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<CSphereCollisionInstance *> >::construct<CSphereCollisionInstance *,CSphereCollisionInstance * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCSphereCollisionInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@SAXAAV?$allocator@PAVCSphereCollisionInstance@@@1@PAPAVCSphereCollisionInstance@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<CSphereCollisionInstance *> >::construct<CSphereCollisionInstance *,CSphereCollisionInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAVCSphereCollisionInstance@@@std@@YAAAPAVCSphereCollisionInstance@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVCSphereCollisionInstance@@@std@@YAAAPAVCSphereCollisionInstance@@AAPAV1@@Z PROC ; std::forward<CSphereCollisionInstance * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAVCSphereCollisionInstance@@@std@@YAAAPAVCSphereCollisionInstance@@AAPAV1@@Z ENDP ; std::forward<CSphereCollisionInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCOBBCollisionInstance@@@Z@std@@YA$$QAP6AXPAVCOBBCollisionInstance@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCOBBCollisionInstance@@@Z@std@@YA$$QAP6AXPAVCOBBCollisionInstance@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(COBBCollisionInstance *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCOBBCollisionInstance@@@Z@std@@YA$$QAP6AXPAVCOBBCollisionInstance@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(COBBCollisionInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCOBBCollisionInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCOBBCollisionInstance@@0AAP6AXPAV1@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCOBBCollisionInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCOBBCollisionInstance@@0AAP6AXPAV1@@Z@Z PROC ; std::_For_each<COBBCollisionInstance * *,void (__cdecl*)(COBBCollisionInstance *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCOBBCollisionInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCOBBCollisionInstance@@0AAP6AXPAV1@@Z@Z ENDP ; std::_For_each<COBBCollisionInstance * *,void (__cdecl*)(COBBCollisionInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCOBBCollisionInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCOBBCollisionInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCOBBCollisionInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCAABBCollisionInstance@@@Z@std@@YA$$QAP6AXPAVCAABBCollisionInstance@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCAABBCollisionInstance@@@Z@std@@YA$$QAP6AXPAVCAABBCollisionInstance@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(CAABBCollisionInstance *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCAABBCollisionInstance@@@Z@std@@YA$$QAP6AXPAVCAABBCollisionInstance@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(CAABBCollisionInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCAABBCollisionInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCAABBCollisionInstance@@0AAP6AXPAV1@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCAABBCollisionInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCAABBCollisionInstance@@0AAP6AXPAV1@@Z@Z PROC ; std::_For_each<CAABBCollisionInstance * *,void (__cdecl*)(CAABBCollisionInstance *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCAABBCollisionInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCAABBCollisionInstance@@0AAP6AXPAV1@@Z@Z ENDP ; std::_For_each<CAABBCollisionInstance * *,void (__cdecl*)(CAABBCollisionInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCAABBCollisionInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCAABBCollisionInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@YAPAPAVCAABBCollisionInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCPlaneCollisionInstance@@@Z@std@@YA$$QAP6AXPAVCPlaneCollisionInstance@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCPlaneCollisionInstance@@@Z@std@@YA$$QAP6AXPAVCPlaneCollisionInstance@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(CPlaneCollisionInstance *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCPlaneCollisionInstance@@@Z@std@@YA$$QAP6AXPAVCPlaneCollisionInstance@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(CPlaneCollisionInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCPlaneCollisionInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCPlaneCollisionInstance@@0AAP6AXPAV1@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCPlaneCollisionInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCPlaneCollisionInstance@@0AAP6AXPAV1@@Z@Z PROC ; std::_For_each<CPlaneCollisionInstance * *,void (__cdecl*)(CPlaneCollisionInstance *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCPlaneCollisionInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCPlaneCollisionInstance@@0AAP6AXPAV1@@Z@Z ENDP ; std::_For_each<CPlaneCollisionInstance * *,void (__cdecl*)(CPlaneCollisionInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@YAPAPAVCPlaneCollisionInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@YAPAPAVCPlaneCollisionInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@YAPAPAVCPlaneCollisionInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCCylinderCollisionInstance@@@Z@std@@YA$$QAP6AXPAVCCylinderCollisionInstance@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCCylinderCollisionInstance@@@Z@std@@YA$$QAP6AXPAVCCylinderCollisionInstance@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(CCylinderCollisionInstance *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCCylinderCollisionInstance@@@Z@std@@YA$$QAP6AXPAVCCylinderCollisionInstance@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(CCylinderCollisionInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCCylinderCollisionInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCCylinderCollisionInstance@@0AAP6AXPAV1@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCCylinderCollisionInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCCylinderCollisionInstance@@0AAP6AXPAV1@@Z@Z PROC ; std::_For_each<CCylinderCollisionInstance * *,void (__cdecl*)(CCylinderCollisionInstance *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCCylinderCollisionInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCCylinderCollisionInstance@@0AAP6AXPAV1@@Z@Z ENDP ; std::_For_each<CCylinderCollisionInstance * *,void (__cdecl*)(CCylinderCollisionInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@YAPAPAVCCylinderCollisionInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@YAPAPAVCCylinderCollisionInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@YAPAPAVCCylinderCollisionInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCSphereCollisionInstance@@@Z@std@@YA$$QAP6AXPAVCSphereCollisionInstance@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCSphereCollisionInstance@@@Z@std@@YA$$QAP6AXPAVCSphereCollisionInstance@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(CSphereCollisionInstance *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCSphereCollisionInstance@@@Z@std@@YA$$QAP6AXPAVCSphereCollisionInstance@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(CSphereCollisionInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCSphereCollisionInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCSphereCollisionInstance@@0AAP6AXPAV1@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCSphereCollisionInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCSphereCollisionInstance@@0AAP6AXPAV1@@Z@Z PROC ; std::_For_each<CSphereCollisionInstance * *,void (__cdecl*)(CSphereCollisionInstance *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCSphereCollisionInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCSphereCollisionInstance@@0AAP6AXPAV1@@Z@Z ENDP ; std::_For_each<CSphereCollisionInstance * *,void (__cdecl*)(CSphereCollisionInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@YAPAPAVCSphereCollisionInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@YAPAPAVCSphereCollisionInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@YAPAPAVCSphereCollisionInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAVCOBBCollisionInstance@@@std@@YAPAPAVCOBBCollisionInstance@@IPAPAV1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCOBBCollisionInstance@@@std@@YAPAPAVCOBBCollisionInstance@@IPAPAV1@@Z PROC ; std::_Allocate<COBBCollisionInstance *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1e		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 12		 ja	 SHORT $LN1@Allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00025	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002a	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Allocate@PAVCOBBCollisionInstance@@@std@@YAPAPAVCOBBCollisionInstance@@IPAPAV1@@Z ENDP ; std::_Allocate<COBBCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAVCAABBCollisionInstance@@@std@@YAPAPAVCAABBCollisionInstance@@IPAPAV1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCAABBCollisionInstance@@@std@@YAPAPAVCAABBCollisionInstance@@IPAPAV1@@Z PROC ; std::_Allocate<CAABBCollisionInstance *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1e		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 12		 ja	 SHORT $LN1@Allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00025	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002a	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Allocate@PAVCAABBCollisionInstance@@@std@@YAPAPAVCAABBCollisionInstance@@IPAPAV1@@Z ENDP ; std::_Allocate<CAABBCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAVCPlaneCollisionInstance@@@std@@YAPAPAVCPlaneCollisionInstance@@IPAPAV1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCPlaneCollisionInstance@@@std@@YAPAPAVCPlaneCollisionInstance@@IPAPAV1@@Z PROC ; std::_Allocate<CPlaneCollisionInstance *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1e		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 12		 ja	 SHORT $LN1@Allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00025	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002a	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Allocate@PAVCPlaneCollisionInstance@@@std@@YAPAPAVCPlaneCollisionInstance@@IPAPAV1@@Z ENDP ; std::_Allocate<CPlaneCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAVCCylinderCollisionInstance@@@std@@YAPAPAVCCylinderCollisionInstance@@IPAPAV1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCCylinderCollisionInstance@@@std@@YAPAPAVCCylinderCollisionInstance@@IPAPAV1@@Z PROC ; std::_Allocate<CCylinderCollisionInstance *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1e		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 12		 ja	 SHORT $LN1@Allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00025	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002a	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Allocate@PAVCCylinderCollisionInstance@@@std@@YAPAPAVCCylinderCollisionInstance@@IPAPAV1@@Z ENDP ; std::_Allocate<CCylinderCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAVCSphereCollisionInstance@@@std@@YAPAPAVCSphereCollisionInstance@@IPAPAV1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCSphereCollisionInstance@@@std@@YAPAPAVCSphereCollisionInstance@@IPAPAV1@@Z PROC ; std::_Allocate<CSphereCollisionInstance *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1e		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 12		 ja	 SHORT $LN1@Allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00025	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002a	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Allocate@PAVCSphereCollisionInstance@@@std@@YAPAPAVCSphereCollisionInstance@@IPAPAV1@@Z ENDP ; std::_Allocate<CSphereCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEPAPAVCOBBCollisionInstance@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEPAPAVCOBBCollisionInstance@@PAPAV2@00@Z PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Umove<COBBCollisionInstance * *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1649 : 		}

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAPAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEPAPAVCOBBCollisionInstance@@PAPAV2@00@Z ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Umove<COBBCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEPAPAVCAABBCollisionInstance@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEPAPAVCAABBCollisionInstance@@PAPAV2@00@Z PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Umove<CAABBCollisionInstance * *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1649 : 		}

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAPAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEPAPAVCAABBCollisionInstance@@PAPAV2@00@Z ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Umove<CAABBCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEPAPAVCPlaneCollisionInstance@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEPAPAVCPlaneCollisionInstance@@PAPAV2@00@Z PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Umove<CPlaneCollisionInstance * *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1649 : 		}

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAPAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEPAPAVCPlaneCollisionInstance@@PAPAV2@00@Z ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Umove<CPlaneCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEPAPAVCCylinderCollisionInstance@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEPAPAVCCylinderCollisionInstance@@PAPAV2@00@Z PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Umove<CCylinderCollisionInstance * *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1649 : 		}

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAPAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEPAPAVCCylinderCollisionInstance@@PAPAV2@00@Z ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Umove<CCylinderCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEPAPAVCSphereCollisionInstance@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEPAPAVCSphereCollisionInstance@@PAPAV2@00@Z PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Umove<CSphereCollisionInstance * *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1649 : 		}

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAPAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEPAPAVCSphereCollisionInstance@@PAPAV2@00@Z ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Umove<CSphereCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCOBBCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCOBBCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCOBBCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCAABBCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCAABBCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCAABBCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCPlaneCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCPlaneCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCPlaneCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCCylinderCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCCylinderCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCCylinderCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCSphereCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCSphereCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@YAXPAPAVCSphereCollisionInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCOBBCollisionInstance@@@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXPAPAVCOBBCollisionInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVCOBBCollisionInstance@@@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXPAPAVCOBBCollisionInstance@@@Z PROC ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::destroy<COBBCollisionInstance *>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAVCOBBCollisionInstance@@@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXPAPAVCOBBCollisionInstance@@@Z ENDP ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::destroy<COBBCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCOBBCollisionInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXPAPAVCOBBCollisionInstance@@ABQAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCOBBCollisionInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXPAPAVCOBBCollisionInstance@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::construct<COBBCollisionInstance *,COBBCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCOBBCollisionInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXPAPAVCOBBCollisionInstance@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::construct<COBBCollisionInstance *,COBBCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCOBBCollisionInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXPAPAVCOBBCollisionInstance@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCOBBCollisionInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXPAPAVCOBBCollisionInstance@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::construct<COBBCollisionInstance *,COBBCollisionInstance * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCOBBCollisionInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXPAPAVCOBBCollisionInstance@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::construct<COBBCollisionInstance *,COBBCollisionInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@QAVCOBBCollisionInstance@@@std@@YAPBQAVCOBBCollisionInstance@@ABQAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAVCOBBCollisionInstance@@@std@@YAPBQAVCOBBCollisionInstance@@ABQAV1@@Z PROC ; std::addressof<COBBCollisionInstance * const>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@QAVCOBBCollisionInstance@@@std@@YAPBQAVCOBBCollisionInstance@@ABQAV1@@Z ENDP ; std::addressof<COBBCollisionInstance * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCAABBCollisionInstance@@@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXPAPAVCAABBCollisionInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVCAABBCollisionInstance@@@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXPAPAVCAABBCollisionInstance@@@Z PROC ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::destroy<CAABBCollisionInstance *>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAVCAABBCollisionInstance@@@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXPAPAVCAABBCollisionInstance@@@Z ENDP ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::destroy<CAABBCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCAABBCollisionInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXPAPAVCAABBCollisionInstance@@ABQAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCAABBCollisionInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXPAPAVCAABBCollisionInstance@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::construct<CAABBCollisionInstance *,CAABBCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCAABBCollisionInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXPAPAVCAABBCollisionInstance@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::construct<CAABBCollisionInstance *,CAABBCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCAABBCollisionInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXPAPAVCAABBCollisionInstance@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCAABBCollisionInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXPAPAVCAABBCollisionInstance@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::construct<CAABBCollisionInstance *,CAABBCollisionInstance * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCAABBCollisionInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXPAPAVCAABBCollisionInstance@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::construct<CAABBCollisionInstance *,CAABBCollisionInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@QAVCAABBCollisionInstance@@@std@@YAPBQAVCAABBCollisionInstance@@ABQAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAVCAABBCollisionInstance@@@std@@YAPBQAVCAABBCollisionInstance@@ABQAV1@@Z PROC ; std::addressof<CAABBCollisionInstance * const>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@QAVCAABBCollisionInstance@@@std@@YAPBQAVCAABBCollisionInstance@@ABQAV1@@Z ENDP ; std::addressof<CAABBCollisionInstance * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCPlaneCollisionInstance@@@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXPAPAVCPlaneCollisionInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVCPlaneCollisionInstance@@@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXPAPAVCPlaneCollisionInstance@@@Z PROC ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::destroy<CPlaneCollisionInstance *>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAVCPlaneCollisionInstance@@@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXPAPAVCPlaneCollisionInstance@@@Z ENDP ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::destroy<CPlaneCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCPlaneCollisionInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXPAPAVCPlaneCollisionInstance@@ABQAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCPlaneCollisionInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXPAPAVCPlaneCollisionInstance@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::construct<CPlaneCollisionInstance *,CPlaneCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCPlaneCollisionInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXPAPAVCPlaneCollisionInstance@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::construct<CPlaneCollisionInstance *,CPlaneCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCPlaneCollisionInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXPAPAVCPlaneCollisionInstance@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCPlaneCollisionInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXPAPAVCPlaneCollisionInstance@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::construct<CPlaneCollisionInstance *,CPlaneCollisionInstance * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCPlaneCollisionInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXPAPAVCPlaneCollisionInstance@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::construct<CPlaneCollisionInstance *,CPlaneCollisionInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@QAVCPlaneCollisionInstance@@@std@@YAPBQAVCPlaneCollisionInstance@@ABQAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAVCPlaneCollisionInstance@@@std@@YAPBQAVCPlaneCollisionInstance@@ABQAV1@@Z PROC ; std::addressof<CPlaneCollisionInstance * const>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@QAVCPlaneCollisionInstance@@@std@@YAPBQAVCPlaneCollisionInstance@@ABQAV1@@Z ENDP ; std::addressof<CPlaneCollisionInstance * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCCylinderCollisionInstance@@@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXPAPAVCCylinderCollisionInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVCCylinderCollisionInstance@@@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXPAPAVCCylinderCollisionInstance@@@Z PROC ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::destroy<CCylinderCollisionInstance *>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAVCCylinderCollisionInstance@@@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXPAPAVCCylinderCollisionInstance@@@Z ENDP ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::destroy<CCylinderCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCCylinderCollisionInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXPAPAVCCylinderCollisionInstance@@ABQAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCCylinderCollisionInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXPAPAVCCylinderCollisionInstance@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::construct<CCylinderCollisionInstance *,CCylinderCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCCylinderCollisionInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXPAPAVCCylinderCollisionInstance@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::construct<CCylinderCollisionInstance *,CCylinderCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCCylinderCollisionInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXPAPAVCCylinderCollisionInstance@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCCylinderCollisionInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXPAPAVCCylinderCollisionInstance@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::construct<CCylinderCollisionInstance *,CCylinderCollisionInstance * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCCylinderCollisionInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXPAPAVCCylinderCollisionInstance@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::construct<CCylinderCollisionInstance *,CCylinderCollisionInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@QAVCCylinderCollisionInstance@@@std@@YAPBQAVCCylinderCollisionInstance@@ABQAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAVCCylinderCollisionInstance@@@std@@YAPBQAVCCylinderCollisionInstance@@ABQAV1@@Z PROC ; std::addressof<CCylinderCollisionInstance * const>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@QAVCCylinderCollisionInstance@@@std@@YAPBQAVCCylinderCollisionInstance@@ABQAV1@@Z ENDP ; std::addressof<CCylinderCollisionInstance * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCSphereCollisionInstance@@@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXPAPAVCSphereCollisionInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVCSphereCollisionInstance@@@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXPAPAVCSphereCollisionInstance@@@Z PROC ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::destroy<CSphereCollisionInstance *>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAVCSphereCollisionInstance@@@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXPAPAVCSphereCollisionInstance@@@Z ENDP ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::destroy<CSphereCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCSphereCollisionInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXPAPAVCSphereCollisionInstance@@ABQAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCSphereCollisionInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXPAPAVCSphereCollisionInstance@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::construct<CSphereCollisionInstance *,CSphereCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCSphereCollisionInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXPAPAVCSphereCollisionInstance@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::construct<CSphereCollisionInstance *,CSphereCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCSphereCollisionInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXPAPAVCSphereCollisionInstance@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCSphereCollisionInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXPAPAVCSphereCollisionInstance@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::construct<CSphereCollisionInstance *,CSphereCollisionInstance * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCSphereCollisionInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXPAPAVCSphereCollisionInstance@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::construct<CSphereCollisionInstance *,CSphereCollisionInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@QAVCSphereCollisionInstance@@@std@@YAPBQAVCSphereCollisionInstance@@ABQAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAVCSphereCollisionInstance@@@std@@YAPBQAVCSphereCollisionInstance@@ABQAV1@@Z PROC ; std::addressof<CSphereCollisionInstance * const>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@QAVCSphereCollisionInstance@@@std@@YAPBQAVCSphereCollisionInstance@@ABQAV1@@Z ENDP ; std::addressof<CSphereCollisionInstance * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@P6AXPAVCOBBCollisionInstance@@@Z@std@@YAP6AXPAVCOBBCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@P6AXPAVCOBBCollisionInstance@@@Z@std@@YAP6AXPAVCOBBCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >,void (__cdecl*)(COBBCollisionInstance *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@P6AXPAVCOBBCollisionInstance@@@Z@std@@YAP6AXPAVCOBBCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >,void (__cdecl*)(COBBCollisionInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::operator-, COMDAT
; _this$ = ecx

; 376  : 		{	// return this - integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	c1 e0 02	 shl	 eax, 2
  0000b	2b c8		 sub	 ecx, eax

; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);

  0000d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00010	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::operator-=, COMDAT
; _this$ = ecx

; 371  : 		{	// decrement by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	f7 d8		 neg	 eax
  00008	c1 e0 02	 shl	 eax, 2
  0000b	01 01		 add	 DWORD PTR [ecx], eax

; 372  : 		return (*this += -_Off);

  0000d	8b c1		 mov	 eax, ecx

; 373  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::operator+=, COMDAT
; _this$ = ecx

; 359  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	01 01		 add	 DWORD PTR [ecx], eax

; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);

  0000b	8b c1		 mov	 eax, ecx

; 362  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QBEAAPAVCOBBCollisionInstance@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QBEAAPAVCOBBCollisionInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 325  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QBEAAPAVCOBBCollisionInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QBEPAPAVCOBBCollisionInstance@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QBEPAPAVCOBBCollisionInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QBEPAPAVCOBBCollisionInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCOBBCollisionInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCOBBCollisionInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCOBBCollisionInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::operator+=, COMDAT
; _this$ = ecx

; 153  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	01 01		 add	 DWORD PTR [ecx], eax

; 171  : 		return (*this);

  0000b	8b c1		 mov	 eax, ecx

; 172  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QBEABQAVCOBBCollisionInstance@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QBEABQAVCOBBCollisionInstance@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QBEABQAVCOBBCollisionInstance@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCOBBCollisionInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCOBBCollisionInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCOBBCollisionInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@P6AXPAVCAABBCollisionInstance@@@Z@std@@YAP6AXPAVCAABBCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@P6AXPAVCAABBCollisionInstance@@@Z@std@@YAP6AXPAVCAABBCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >,void (__cdecl*)(CAABBCollisionInstance *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@P6AXPAVCAABBCollisionInstance@@@Z@std@@YAP6AXPAVCAABBCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >,void (__cdecl*)(CAABBCollisionInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::operator-, COMDAT
; _this$ = ecx

; 376  : 		{	// return this - integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	c1 e0 02	 shl	 eax, 2
  0000b	2b c8		 sub	 ecx, eax

; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);

  0000d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00010	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::operator-=, COMDAT
; _this$ = ecx

; 371  : 		{	// decrement by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	f7 d8		 neg	 eax
  00008	c1 e0 02	 shl	 eax, 2
  0000b	01 01		 add	 DWORD PTR [ecx], eax

; 372  : 		return (*this += -_Off);

  0000d	8b c1		 mov	 eax, ecx

; 373  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::operator+=, COMDAT
; _this$ = ecx

; 359  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	01 01		 add	 DWORD PTR [ecx], eax

; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);

  0000b	8b c1		 mov	 eax, ecx

; 362  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QBEAAPAVCAABBCollisionInstance@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QBEAAPAVCAABBCollisionInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 325  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QBEAAPAVCAABBCollisionInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QBEPAPAVCAABBCollisionInstance@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QBEPAPAVCAABBCollisionInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QBEPAPAVCAABBCollisionInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCAABBCollisionInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCAABBCollisionInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCAABBCollisionInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::operator+=, COMDAT
; _this$ = ecx

; 153  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	01 01		 add	 DWORD PTR [ecx], eax

; 171  : 		return (*this);

  0000b	8b c1		 mov	 eax, ecx

; 172  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QBEABQAVCAABBCollisionInstance@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QBEABQAVCAABBCollisionInstance@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QBEABQAVCAABBCollisionInstance@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCAABBCollisionInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCAABBCollisionInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCAABBCollisionInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@P6AXPAVCPlaneCollisionInstance@@@Z@std@@YAP6AXPAVCPlaneCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@P6AXPAVCPlaneCollisionInstance@@@Z@std@@YAP6AXPAVCPlaneCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >,void (__cdecl*)(CPlaneCollisionInstance *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@P6AXPAVCPlaneCollisionInstance@@@Z@std@@YAP6AXPAVCPlaneCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >,void (__cdecl*)(CPlaneCollisionInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::operator-, COMDAT
; _this$ = ecx

; 376  : 		{	// return this - integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	c1 e0 02	 shl	 eax, 2
  0000b	2b c8		 sub	 ecx, eax

; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);

  0000d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00010	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::operator-=, COMDAT
; _this$ = ecx

; 371  : 		{	// decrement by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	f7 d8		 neg	 eax
  00008	c1 e0 02	 shl	 eax, 2
  0000b	01 01		 add	 DWORD PTR [ecx], eax

; 372  : 		return (*this += -_Off);

  0000d	8b c1		 mov	 eax, ecx

; 373  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::operator+=, COMDAT
; _this$ = ecx

; 359  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	01 01		 add	 DWORD PTR [ecx], eax

; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);

  0000b	8b c1		 mov	 eax, ecx

; 362  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QBEAAPAVCPlaneCollisionInstance@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QBEAAPAVCPlaneCollisionInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 325  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QBEAAPAVCPlaneCollisionInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QBEPAPAVCPlaneCollisionInstance@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QBEPAPAVCPlaneCollisionInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QBEPAPAVCPlaneCollisionInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCPlaneCollisionInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCPlaneCollisionInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCPlaneCollisionInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::operator+=, COMDAT
; _this$ = ecx

; 153  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	01 01		 add	 DWORD PTR [ecx], eax

; 171  : 		return (*this);

  0000b	8b c1		 mov	 eax, ecx

; 172  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QBEABQAVCPlaneCollisionInstance@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QBEABQAVCPlaneCollisionInstance@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QBEABQAVCPlaneCollisionInstance@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCPlaneCollisionInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCPlaneCollisionInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCPlaneCollisionInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@P6AXPAVCCylinderCollisionInstance@@@Z@std@@YAP6AXPAVCCylinderCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@P6AXPAVCCylinderCollisionInstance@@@Z@std@@YAP6AXPAVCCylinderCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >,void (__cdecl*)(CCylinderCollisionInstance *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@P6AXPAVCCylinderCollisionInstance@@@Z@std@@YAP6AXPAVCCylinderCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >,void (__cdecl*)(CCylinderCollisionInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::operator-, COMDAT
; _this$ = ecx

; 376  : 		{	// return this - integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	c1 e0 02	 shl	 eax, 2
  0000b	2b c8		 sub	 ecx, eax

; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);

  0000d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00010	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::operator-=, COMDAT
; _this$ = ecx

; 371  : 		{	// decrement by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	f7 d8		 neg	 eax
  00008	c1 e0 02	 shl	 eax, 2
  0000b	01 01		 add	 DWORD PTR [ecx], eax

; 372  : 		return (*this += -_Off);

  0000d	8b c1		 mov	 eax, ecx

; 373  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::operator+=, COMDAT
; _this$ = ecx

; 359  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	01 01		 add	 DWORD PTR [ecx], eax

; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);

  0000b	8b c1		 mov	 eax, ecx

; 362  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QBEAAPAVCCylinderCollisionInstance@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QBEAAPAVCCylinderCollisionInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 325  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QBEAAPAVCCylinderCollisionInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QBEPAPAVCCylinderCollisionInstance@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QBEPAPAVCCylinderCollisionInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QBEPAPAVCCylinderCollisionInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCCylinderCollisionInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCCylinderCollisionInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCCylinderCollisionInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::operator+=, COMDAT
; _this$ = ecx

; 153  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	01 01		 add	 DWORD PTR [ecx], eax

; 171  : 		return (*this);

  0000b	8b c1		 mov	 eax, ecx

; 172  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QBEABQAVCCylinderCollisionInstance@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QBEABQAVCCylinderCollisionInstance@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QBEABQAVCCylinderCollisionInstance@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCCylinderCollisionInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCCylinderCollisionInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCCylinderCollisionInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@P6AXPAVCSphereCollisionInstance@@@Z@std@@YAP6AXPAVCSphereCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@P6AXPAVCSphereCollisionInstance@@@Z@std@@YAP6AXPAVCSphereCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >,void (__cdecl*)(CSphereCollisionInstance *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@P6AXPAVCSphereCollisionInstance@@@Z@std@@YAP6AXPAVCSphereCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >,void (__cdecl*)(CSphereCollisionInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::operator-, COMDAT
; _this$ = ecx

; 376  : 		{	// return this - integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	c1 e0 02	 shl	 eax, 2
  0000b	2b c8		 sub	 ecx, eax

; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);

  0000d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00010	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::operator-=, COMDAT
; _this$ = ecx

; 371  : 		{	// decrement by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	f7 d8		 neg	 eax
  00008	c1 e0 02	 shl	 eax, 2
  0000b	01 01		 add	 DWORD PTR [ecx], eax

; 372  : 		return (*this += -_Off);

  0000d	8b c1		 mov	 eax, ecx

; 373  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::operator+=, COMDAT
; _this$ = ecx

; 359  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	01 01		 add	 DWORD PTR [ecx], eax

; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);

  0000b	8b c1		 mov	 eax, ecx

; 362  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QBEAAPAVCSphereCollisionInstance@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QBEAAPAVCSphereCollisionInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 325  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QBEAAPAVCSphereCollisionInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QBEPAPAVCSphereCollisionInstance@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QBEPAPAVCSphereCollisionInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QBEPAPAVCSphereCollisionInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCSphereCollisionInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCSphereCollisionInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCSphereCollisionInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::operator+=, COMDAT
; _this$ = ecx

; 153  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	01 01		 add	 DWORD PTR [ecx], eax

; 171  : 		return (*this);

  0000b	8b c1		 mov	 eax, ecx

; 172  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QBEABQAVCSphereCollisionInstance@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QBEABQAVCSphereCollisionInstance@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QBEABQAVCSphereCollisionInstance@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCSphereCollisionInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCSphereCollisionInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAE@PAPAVCSphereCollisionInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fs@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ
text$yd	SEGMENT
??__Fs@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ PROC ; `COBBCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00005	e9 00 00 00 00	 jmp	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
??__Fs@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ENDP ; `COBBCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
text$yd	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fs@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ
text$yd	SEGMENT
??__Fs@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ PROC ; `CAABBCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00005	e9 00 00 00 00	 jmp	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
??__Fs@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ENDP ; `CAABBCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
text$yd	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fs@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ
text$yd	SEGMENT
??__Fs@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ PROC ; `CCylinderCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00005	e9 00 00 00 00	 jmp	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
??__Fs@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ENDP ; `CCylinderCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
text$yd	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fs@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ
text$yd	SEGMENT
??__Fs@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ PROC ; `CPlaneCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00005	e9 00 00 00 00	 jmp	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
??__Fs@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ENDP ; `CPlaneCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
text$yd	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fs@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ
text$yd	SEGMENT
??__Fs@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ PROC ; `CSphereCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00005	e9 00 00 00 00	 jmp	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
??__Fs@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ENDP ; `CSphereCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??__Fgs_oci@@YAXXZ
text$yd	SEGMENT
$T1 = -1						; size = 1
$T2 = -1						; size = 1
??__Fgs_oci@@YAXXZ PROC					; `dynamic atexit destructor for 'gs_oci'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00004	a1 10 00 00 00	 mov	 eax, DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+16
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 18   : 		{

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A, OFFSET ??_7?$CDynamicPool@VCOBBCollisionInstance@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00013	85 c0		 test	 eax, eax
  00015	74 45		 je	 SHORT $LN7@dynamic

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00017	ff 35 14 00 00
	00		 push	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+20
  0001d	b9 10 00 00 00	 mov	 ecx, OFFSET ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+16
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXPAPAVCOBBCollisionInstance@@0@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Destroy

; 642  : 		return (_Alty());

  00028	8d 4d ff	 lea	 ecx, DWORD PTR $T2[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00030	ff 35 10 00 00
	00		 push	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+16
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0003e	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+16, 0

; 1630 : 			this->_Mylast = pointer();

  00048	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+20, 0

; 1631 : 			this->_Myend = pointer();

  00052	c7 05 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+24, 0
$LN7@dynamic:

; 1623 : 		if (this->_Myfirst != pointer())

  0005c	a1 04 00 00 00	 mov	 eax, DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+4
  00061	85 c0		 test	 eax, eax
  00063	74 45		 je	 SHORT $LN20@dynamic

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00065	ff 35 08 00 00
	00		 push	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+8
  0006b	b9 04 00 00 00	 mov	 ecx, OFFSET ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+4
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXPAPAVCOBBCollisionInstance@@0@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Destroy

; 642  : 		return (_Alty());

  00076	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00079	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007e	ff 35 04 00 00
	00		 push	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+4
  00084	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00089	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0008c	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+4, 0

; 1630 : 			this->_Mylast = pointer();

  00096	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+8, 0

; 1631 : 			this->_Myend = pointer();

  000a0	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+12, 0
$LN20@dynamic:
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
??__Fgs_oci@@YAXXZ ENDP					; `dynamic atexit destructor for 'gs_oci''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ??__Egs_oci@@YAXXZ
text$di	SEGMENT
??__Egs_oci@@YAXXZ PROC					; `dynamic initializer for 'gs_oci'', COMDAT

; 22   : CDynamicPool<COBBCollisionInstance> gs_oci;

  00000	68 00 00 00 00	 push	 OFFSET ??__Fgs_oci@@YAXXZ ; `dynamic atexit destructor for 'gs_oci''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Egs_oci@@YAXXZ ENDP					; `dynamic initializer for 'gs_oci''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??_G?$CDynamicPool@VCOBBCollisionInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCOBBCollisionInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<COBBCollisionInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 18   : 		{

  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCOBBCollisionInstance@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  0000c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000f	85 c0		 test	 eax, eax
  00011	74 1e		 je	 SHORT $LN8@scalar
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00019	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0001c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  00023	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  0002a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN8@scalar:

; 1623 : 		if (this->_Myfirst != pointer())

  00031	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00034	85 c0		 test	 eax, eax
  00036	74 1e		 je	 SHORT $LN21@scalar
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003e	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00041	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  00048	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  0004f	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN21@scalar:
  00056	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0005a	74 09		 je	 SHORT $LN32@scalar
  0005c	56		 push	 esi
  0005d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00062	83 c4 04	 add	 esp, 4
$LN32@scalar:
  00065	8b c6		 mov	 eax, esi
  00067	5e		 pop	 esi
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCOBBCollisionInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<COBBCollisionInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IBEXPAPAVCOBBCollisionInstance@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IBEXPAPAVCOBBCollisionInstance@@0@Z PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IBEXPAPAVCOBBCollisionInstance@@0@Z ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IBEXXZ PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IBEXXZ ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXXZ PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXXZ ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000c	2b c6		 sub	 eax, esi
  0000e	57		 push	 edi

; 1613 : 		if (_Unused_capacity() < _Count)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00012	c1 f8 02	 sar	 eax, 2

; 1613 : 		if (_Unused_capacity() < _Count)

  00015	3b c7		 cmp	 eax, edi
  00017	73 49		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00019	2b 31		 sub	 esi, DWORD PTR [ecx]
  0001b	53		 push	 ebx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  0001c	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00021	c1 fe 02	 sar	 esi, 2

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00024	8b c3		 mov	 eax, ebx
  00026	2b c6		 sub	 eax, esi
  00028	3b c7		 cmp	 eax, edi
  0002a	72 3c		 jb	 SHORT $LN43@Reserve

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0002c	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0002e	03 f7		 add	 esi, edi

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00030	c1 fa 02	 sar	 edx, 2

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00033	8b c2		 mov	 eax, edx
  00035	d1 e8		 shr	 eax, 1
  00037	2b d8		 sub	 ebx, eax
  00039	3b da		 cmp	 ebx, edx
  0003b	5b		 pop	 ebx
  0003c	73 12		 jae	 SHORT $LN27@Reserve
  0003e	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  00040	3b d6		 cmp	 edx, esi
  00042	5f		 pop	 edi
  00043	0f 42 d6	 cmovb	 edx, esi
  00046	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00047	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0004a	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Reallocate
$LN27@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00050	03 d0		 add	 edx, eax

; 1576 : 		if (_Capacity < _Count)

  00052	3b d6		 cmp	 edx, esi
  00054	5f		 pop	 edi
  00055	0f 42 d6	 cmovb	 edx, esi
  00058	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00059	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0005c	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0005d	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Reallocate
$LN2@Reserve:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 1618 : 			}
; 1619 : 		}

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN43@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0006d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN45@Reserve:
$LN42@Reserve:
  00072	cc		 int	 3
?_Reserve@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = 8						; size = 4
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi

; 23   : 	void *_Ptr = 0;

  00008	33 f6		 xor	 esi, esi
  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1587 : 		{	// move to array of exactly _Count elements

  0000b	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0000d	85 db		 test	 ebx, ebx
  0000f	74 1e		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00011	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  00017	77 5d		 ja	 SHORT $LN61@Reallocate
  00019	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	8b f0		 mov	 esi, eax
  00028	83 c4 04	 add	 esp, 4
  0002b	85 f6		 test	 esi, esi
  0002d	74 47		 je	 SHORT $LN61@Reallocate
$LN16@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  0002f	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00034	2b c1		 sub	 eax, ecx

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00036	83 e0 fc	 and	 eax, -4			; fffffffcH
  00039	50		 push	 eax
  0003a	51		 push	 ecx
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 _memmove
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00041	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00046	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00049	2b c1		 sub	 eax, ecx
  0004b	c1 f8 02	 sar	 eax, 2
  0004e	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  00051	85 c9		 test	 ecx, ecx
  00053	74 09		 je	 SHORT $LN56@Reallocate
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005b	83 c4 04	 add	 esp, 4
$LN56@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  0005e	8d 04 9e	 lea	 eax, DWORD PTR [esi+ebx*4]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  00061	89 37		 mov	 DWORD PTR [edi], esi
  00063	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00066	8b 45 08	 mov	 eax, DWORD PTR __Size$1$[ebp]
  00069	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  0006c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 1609 : 		}

  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
$LN61@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00076	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN63@Reallocate:
$LN60@Reallocate:
  0007b	cc		 int	 3
?_Reallocate@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IBE_NPBQAVCOBBCollisionInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IBE_NPBQAVCOBBCollisionInstance@@@Z PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IBE_NPBQAVCOBBCollisionInstance@@@Z ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IBEII@Z PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00006	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 02	 sar	 edx, 2

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b c2		 cmp	 eax, edx
  00018	73 0f		 jae	 SHORT $LN4@Grow_to
  0001a	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  0001c	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0001f	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00023	8b c2		 mov	 eax, edx

; 1579 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00029	03 d1		 add	 edx, ecx

; 1576 : 		if (_Capacity < _Count)

  0002b	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0002e	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00032	8b c2		 mov	 eax, edx

; 1579 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Grow_to@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IBEII@Z ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXPAPAVCOBBCollisionInstance@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXPAPAVCOBBCollisionInstance@@0@Z PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXPAPAVCOBBCollisionInstance@@0@Z ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?pop_back@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::pop_back, COMDAT
; _this$ = ecx

; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;

  00000	83 41 04 fc	 add	 DWORD PTR [ecx+4], -4	; fffffffcH

; 1283 : 		}

  00004	c3		 ret	 0
?pop_back@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXABQAVCOBBCollisionInstance@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXABQAVCOBBCollisionInstance@@@Z PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 31		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 2b		 ja	 SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Reserve
$LN3@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0002a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 2a		 je	 SHORT $LN49@push_back
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00036	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  00038	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN4@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  00042	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00045	75 09		 jne	 SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

  00047	6a 01		 push	 1
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Reserve
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00050	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00053	85 c9		 test	 ecx, ecx
  00055	74 04		 je	 SHORT $LN49@push_back
  00057	8b 07		 mov	 eax, DWORD PTR [edi]
  00059	89 01		 mov	 DWORD PTR [ecx], eax
$LN49@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  0005b	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?push_back@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXABQAVCOBBCollisionInstance@@@Z ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?back@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEAAPAVCOBBCollisionInstance@@XZ
_TEXT	SEGMENT
?back@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEAAPAVCOBBCollisionInstance@@XZ PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::back, COMDAT
; _this$ = ecx

; 170  : 		_Ptr += _Off;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 e8 04	 sub	 eax, 4

; 1234 : 		return (*(end() - 1));
; 1235 : 		}

  00006	c3		 ret	 0
?back@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEAAPAVCOBBCollisionInstance@@XZ ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?empty@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBE_NXZ PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::empty, COMDAT
; _this$ = ecx

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 1159 : 		}

  0000a	c3		 ret	 0
?empty@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBE_NXZ ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@2@XZ PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@2@XZ PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00006	c1 f8 02	 sar	 eax, 2

; 1016 : 		}

  00009	c3		 ret	 0
?_Unused_capacity@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1011 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::~vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::~vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCOBBCollisionInstance@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCOBBCollisionInstance@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCOBBCollisionInstance@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> >::_Vector_val<std::_Simple_types<COBBCollisionInstance *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> >::_Vector_val<std::_Simple_types<COBBCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXPAPAVCOBBCollisionInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXPAPAVCOBBCollisionInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXPAPAVCOBBCollisionInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 848  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >::_Wrap_alloc<std::allocator<COBBCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@SAIABV?$allocator@PAVCOBBCollisionInstance@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@SAIABV?$allocator@PAVCOBBCollisionInstance@@@2@@Z PROC ; std::allocator_traits<std::allocator<COBBCollisionInstance *> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@SAIABV?$allocator@PAVCOBBCollisionInstance@@@2@@Z ENDP ; std::allocator_traits<std::allocator<COBBCollisionInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVCOBBCollisionInstance@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCOBBCollisionInstance@@@std@@QBEIXZ PROC ; std::allocator<COBBCollisionInstance *>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAVCOBBCollisionInstance@@@std@@QBEIXZ ENDP ; std::allocator<COBBCollisionInstance *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEXPAPAVCOBBCollisionInstance@@ABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEXPAPAVCOBBCollisionInstance@@ABQAV3@@Z PROC ; std::allocator<COBBCollisionInstance *>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 594  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEXPAPAVCOBBCollisionInstance@@ABQAV3@@Z ENDP ; std::allocator<COBBCollisionInstance *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEPAPAVCOBBCollisionInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEPAPAVCOBBCollisionInstance@@I@Z PROC ; std::allocator<COBBCollisionInstance *>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 579  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEPAPAVCOBBCollisionInstance@@I@Z ENDP ; std::allocator<COBBCollisionInstance *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEXPAPAVCOBBCollisionInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEXPAPAVCOBBCollisionInstance@@I@Z PROC ; std::allocator<COBBCollisionInstance *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEXPAPAVCOBBCollisionInstance@@I@Z ENDP ; std::allocator<COBBCollisionInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCOBBCollisionInstance@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCOBBCollisionInstance@@@std@@QAE@XZ PROC ; std::allocator<COBBCollisionInstance *>::allocator<COBBCollisionInstance *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCOBBCollisionInstance@@@std@@QAE@XZ ENDP ; std::allocator<COBBCollisionInstance *>::allocator<COBBCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCOBBCollisionInstance@@@@KAXPAVCOBBCollisionInstance@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCOBBCollisionInstance@@@@KAXPAVCOBBCollisionInstance@@@Z PROC ; CDynamicPool<COBBCollisionInstance>::Delete, COMDAT

; 110  : 			delete pkData;

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPool@VCOBBCollisionInstance@@@@KAXPAVCOBBCollisionInstance@@@Z ENDP ; CDynamicPool<COBBCollisionInstance>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ?Free@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEXPAVCOBBCollisionInstance@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Free@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEXPAVCOBBCollisionInstance@@@Z PROC ; CDynamicPool<COBBCollisionInstance>::Free, COMDAT
; _this$ = ecx

; 76   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 77   : #ifdef DYNAMIC_POOL_STRICT
; 78   : 			assert(__IsValidData(pkData));
; 79   : 			assert(!__IsFreeData(pkData));
; 80   : #endif
; 81   : 			m_kVct_pkFree.push_back(pkData);

  00003	8d 45 08	 lea	 eax, DWORD PTR _pkData$[ebp]
  00006	83 c1 10	 add	 ecx, 16			; 00000010H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXABQAVCOBBCollisionInstance@@@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::push_back

; 82   : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?Free@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEXPAVCOBBCollisionInstance@@@Z ENDP ; CDynamicPool<COBBCollisionInstance>::Free
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEPAVCOBBCollisionInstance@@XZ
_TEXT	SEGMENT
_pkNewData$1 = -4					; size = 4
?Alloc@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEPAVCOBBCollisionInstance@@XZ PROC ; CDynamicPool<COBBCollisionInstance>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00007	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000a	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  0000d	75 32		 jne	 SHORT $LN1@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  0000f	6a 5c		 push	 92			; 0000005cH
  00011	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00016	83 c4 04	 add	 esp, 4
  00019	85 c0		 test	 eax, eax
  0001b	74 08		 je	 SHORT $LN4@Alloc
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7COBBCollisionInstance@@6B@
  00023	eb 02		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  00025	33 c0		 xor	 eax, eax
$LN5@Alloc:
  00027	89 45 fc	 mov	 DWORD PTR _pkNewData$1[ebp], eax

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  0002a	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0002d	8d 45 fc	 lea	 eax, DWORD PTR _pkNewData$1[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXABQAVCOBBCollisionInstance@@@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::push_back

; 67   : 				++m_uUsedCapacity;

  00036	ff 46 20	 inc	 DWORD PTR [esi+32]

; 68   : 				return pkNewData;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _pkNewData$1[ebp]
  0003c	5e		 pop	 esi

; 74   : 		}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
$LN1@Alloc:

; 69   : 			}
; 70   : 
; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  00041	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00044	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1282 : 		--this->_Mylast;

  00047	83 46 14 fc	 add	 DWORD PTR [esi+20], -4	; fffffffcH
  0004b	5e		 pop	 esi
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 74   : 		}

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?Alloc@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEPAVCOBBCollisionInstance@@XZ ENDP ; CDynamicPool<COBBCollisionInstance>::Alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEXXZ PROC ; CDynamicPool<COBBCollisionInstance>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 38   : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPool@VCOBBCollisionInstance@@@@KAXPAVCOBBCollisionInstance@@@Z ; CDynamicPool<COBBCollisionInstance>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 53   : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEXXZ ENDP ; CDynamicPool<COBBCollisionInstance>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ??1?$CDynamicPool@VCOBBCollisionInstance@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@VCOBBCollisionInstance@@@@UAE@XZ PROC	; CDynamicPool<COBBCollisionInstance>::~CDynamicPool<COBBCollisionInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCOBBCollisionInstance@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	85 c0		 test	 eax, eax
  0000e	74 1e		 je	 SHORT $LN7@CDynamicPo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  00020	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00027	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN7@CDynamicPo:

; 1623 : 		if (this->_Myfirst != pointer())

  0002e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00031	85 c0		 test	 eax, eax
  00033	74 1e		 je	 SHORT $LN20@CDynamicPo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0003e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  00045	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  0004c	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN20@CDynamicPo:
  00053	5e		 pop	 esi
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 26   : 		}

  00054	c3		 ret	 0
??1?$CDynamicPool@VCOBBCollisionInstance@@@@UAE@XZ ENDP	; CDynamicPool<COBBCollisionInstance>::~CDynamicPool<COBBCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ??0?$CDynamicPool@VCOBBCollisionInstance@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPool@VCOBBCollisionInstance@@@@QAE@XZ PROC	; CDynamicPool<COBBCollisionInstance>::CDynamicPool<COBBCollisionInstance>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPool@VCOBBCollisionInstance@@@@6B@

; 16   : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 14   : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 15   : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 16   : 		}

  00040	c3		 ret	 0
??0?$CDynamicPool@VCOBBCollisionInstance@@@@QAE@XZ ENDP	; CDynamicPool<COBBCollisionInstance>::CDynamicPool<COBBCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??__Fgs_aci@@YAXXZ
text$yd	SEGMENT
$T1 = -1						; size = 1
$T2 = -1						; size = 1
??__Fgs_aci@@YAXXZ PROC					; `dynamic atexit destructor for 'gs_aci'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00004	a1 10 00 00 00	 mov	 eax, DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+16
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 18   : 		{

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A, OFFSET ??_7?$CDynamicPool@VCAABBCollisionInstance@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00013	85 c0		 test	 eax, eax
  00015	74 45		 je	 SHORT $LN7@dynamic

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00017	ff 35 14 00 00
	00		 push	 DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+20
  0001d	b9 10 00 00 00	 mov	 ecx, OFFSET ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+16
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXPAPAVCAABBCollisionInstance@@0@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Destroy

; 642  : 		return (_Alty());

  00028	8d 4d ff	 lea	 ecx, DWORD PTR $T2[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00030	ff 35 10 00 00
	00		 push	 DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+16
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0003e	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+16, 0

; 1630 : 			this->_Mylast = pointer();

  00048	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+20, 0

; 1631 : 			this->_Myend = pointer();

  00052	c7 05 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+24, 0
$LN7@dynamic:

; 1623 : 		if (this->_Myfirst != pointer())

  0005c	a1 04 00 00 00	 mov	 eax, DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+4
  00061	85 c0		 test	 eax, eax
  00063	74 45		 je	 SHORT $LN20@dynamic

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00065	ff 35 08 00 00
	00		 push	 DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+8
  0006b	b9 04 00 00 00	 mov	 ecx, OFFSET ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+4
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXPAPAVCAABBCollisionInstance@@0@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Destroy

; 642  : 		return (_Alty());

  00076	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00079	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007e	ff 35 04 00 00
	00		 push	 DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+4
  00084	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00089	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0008c	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+4, 0

; 1630 : 			this->_Mylast = pointer();

  00096	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+8, 0

; 1631 : 			this->_Myend = pointer();

  000a0	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+12, 0
$LN20@dynamic:
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
??__Fgs_aci@@YAXXZ ENDP					; `dynamic atexit destructor for 'gs_aci''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ??__Egs_aci@@YAXXZ
text$di	SEGMENT
??__Egs_aci@@YAXXZ PROC					; `dynamic initializer for 'gs_aci'', COMDAT

; 21   : CDynamicPool<CAABBCollisionInstance> gs_aci;

  00000	68 00 00 00 00	 push	 OFFSET ??__Fgs_aci@@YAXXZ ; `dynamic atexit destructor for 'gs_aci''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Egs_aci@@YAXXZ ENDP					; `dynamic initializer for 'gs_aci''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??_G?$CDynamicPool@VCAABBCollisionInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCAABBCollisionInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CAABBCollisionInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 18   : 		{

  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCAABBCollisionInstance@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  0000c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000f	85 c0		 test	 eax, eax
  00011	74 1e		 je	 SHORT $LN8@scalar
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00019	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0001c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  00023	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  0002a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN8@scalar:

; 1623 : 		if (this->_Myfirst != pointer())

  00031	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00034	85 c0		 test	 eax, eax
  00036	74 1e		 je	 SHORT $LN21@scalar
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003e	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00041	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  00048	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  0004f	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN21@scalar:
  00056	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0005a	74 09		 je	 SHORT $LN32@scalar
  0005c	56		 push	 esi
  0005d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00062	83 c4 04	 add	 esp, 4
$LN32@scalar:
  00065	8b c6		 mov	 eax, esi
  00067	5e		 pop	 esi
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCAABBCollisionInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CAABBCollisionInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IBEXPAPAVCAABBCollisionInstance@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IBEXPAPAVCAABBCollisionInstance@@0@Z PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IBEXPAPAVCAABBCollisionInstance@@0@Z ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IBEXXZ PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IBEXXZ ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXXZ PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXXZ ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000c	2b c6		 sub	 eax, esi
  0000e	57		 push	 edi

; 1613 : 		if (_Unused_capacity() < _Count)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00012	c1 f8 02	 sar	 eax, 2

; 1613 : 		if (_Unused_capacity() < _Count)

  00015	3b c7		 cmp	 eax, edi
  00017	73 49		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00019	2b 31		 sub	 esi, DWORD PTR [ecx]
  0001b	53		 push	 ebx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  0001c	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00021	c1 fe 02	 sar	 esi, 2

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00024	8b c3		 mov	 eax, ebx
  00026	2b c6		 sub	 eax, esi
  00028	3b c7		 cmp	 eax, edi
  0002a	72 3c		 jb	 SHORT $LN43@Reserve

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0002c	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0002e	03 f7		 add	 esi, edi

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00030	c1 fa 02	 sar	 edx, 2

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00033	8b c2		 mov	 eax, edx
  00035	d1 e8		 shr	 eax, 1
  00037	2b d8		 sub	 ebx, eax
  00039	3b da		 cmp	 ebx, edx
  0003b	5b		 pop	 ebx
  0003c	73 12		 jae	 SHORT $LN27@Reserve
  0003e	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  00040	3b d6		 cmp	 edx, esi
  00042	5f		 pop	 edi
  00043	0f 42 d6	 cmovb	 edx, esi
  00046	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00047	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0004a	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Reallocate
$LN27@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00050	03 d0		 add	 edx, eax

; 1576 : 		if (_Capacity < _Count)

  00052	3b d6		 cmp	 edx, esi
  00054	5f		 pop	 edi
  00055	0f 42 d6	 cmovb	 edx, esi
  00058	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00059	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0005c	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0005d	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Reallocate
$LN2@Reserve:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 1618 : 			}
; 1619 : 		}

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN43@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0006d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN45@Reserve:
$LN42@Reserve:
  00072	cc		 int	 3
?_Reserve@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = 8						; size = 4
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi

; 23   : 	void *_Ptr = 0;

  00008	33 f6		 xor	 esi, esi
  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1587 : 		{	// move to array of exactly _Count elements

  0000b	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0000d	85 db		 test	 ebx, ebx
  0000f	74 1e		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00011	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  00017	77 5d		 ja	 SHORT $LN61@Reallocate
  00019	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	8b f0		 mov	 esi, eax
  00028	83 c4 04	 add	 esp, 4
  0002b	85 f6		 test	 esi, esi
  0002d	74 47		 je	 SHORT $LN61@Reallocate
$LN16@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  0002f	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00034	2b c1		 sub	 eax, ecx

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00036	83 e0 fc	 and	 eax, -4			; fffffffcH
  00039	50		 push	 eax
  0003a	51		 push	 ecx
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 _memmove
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00041	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00046	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00049	2b c1		 sub	 eax, ecx
  0004b	c1 f8 02	 sar	 eax, 2
  0004e	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  00051	85 c9		 test	 ecx, ecx
  00053	74 09		 je	 SHORT $LN56@Reallocate
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005b	83 c4 04	 add	 esp, 4
$LN56@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  0005e	8d 04 9e	 lea	 eax, DWORD PTR [esi+ebx*4]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  00061	89 37		 mov	 DWORD PTR [edi], esi
  00063	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00066	8b 45 08	 mov	 eax, DWORD PTR __Size$1$[ebp]
  00069	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  0006c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 1609 : 		}

  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
$LN61@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00076	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN63@Reallocate:
$LN60@Reallocate:
  0007b	cc		 int	 3
?_Reallocate@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IBE_NPBQAVCAABBCollisionInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IBE_NPBQAVCAABBCollisionInstance@@@Z PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IBE_NPBQAVCAABBCollisionInstance@@@Z ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IBEII@Z PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00006	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 02	 sar	 edx, 2

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b c2		 cmp	 eax, edx
  00018	73 0f		 jae	 SHORT $LN4@Grow_to
  0001a	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  0001c	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0001f	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00023	8b c2		 mov	 eax, edx

; 1579 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00029	03 d1		 add	 edx, ecx

; 1576 : 		if (_Capacity < _Count)

  0002b	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0002e	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00032	8b c2		 mov	 eax, edx

; 1579 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Grow_to@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IBEII@Z ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXPAPAVCAABBCollisionInstance@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXPAPAVCAABBCollisionInstance@@0@Z PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXPAPAVCAABBCollisionInstance@@0@Z ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?pop_back@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::pop_back, COMDAT
; _this$ = ecx

; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;

  00000	83 41 04 fc	 add	 DWORD PTR [ecx+4], -4	; fffffffcH

; 1283 : 		}

  00004	c3		 ret	 0
?pop_back@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXABQAVCAABBCollisionInstance@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXABQAVCAABBCollisionInstance@@@Z PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 31		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 2b		 ja	 SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Reserve
$LN3@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0002a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 2a		 je	 SHORT $LN49@push_back
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00036	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  00038	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN4@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  00042	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00045	75 09		 jne	 SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

  00047	6a 01		 push	 1
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Reserve
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00050	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00053	85 c9		 test	 ecx, ecx
  00055	74 04		 je	 SHORT $LN49@push_back
  00057	8b 07		 mov	 eax, DWORD PTR [edi]
  00059	89 01		 mov	 DWORD PTR [ecx], eax
$LN49@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  0005b	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?push_back@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXABQAVCAABBCollisionInstance@@@Z ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?back@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEAAPAVCAABBCollisionInstance@@XZ
_TEXT	SEGMENT
?back@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEAAPAVCAABBCollisionInstance@@XZ PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::back, COMDAT
; _this$ = ecx

; 170  : 		_Ptr += _Off;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 e8 04	 sub	 eax, 4

; 1234 : 		return (*(end() - 1));
; 1235 : 		}

  00006	c3		 ret	 0
?back@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEAAPAVCAABBCollisionInstance@@XZ ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?empty@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBE_NXZ PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::empty, COMDAT
; _this$ = ecx

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 1159 : 		}

  0000a	c3		 ret	 0
?empty@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00006	c1 f8 02	 sar	 eax, 2

; 1016 : 		}

  00009	c3		 ret	 0
?_Unused_capacity@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1011 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::~vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::~vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCAABBCollisionInstance@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCAABBCollisionInstance@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCAABBCollisionInstance@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> >::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> >::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXPAPAVCAABBCollisionInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXPAPAVCAABBCollisionInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXPAPAVCAABBCollisionInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 848  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >::_Wrap_alloc<std::allocator<CAABBCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@SAIABV?$allocator@PAVCAABBCollisionInstance@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@SAIABV?$allocator@PAVCAABBCollisionInstance@@@2@@Z PROC ; std::allocator_traits<std::allocator<CAABBCollisionInstance *> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@SAIABV?$allocator@PAVCAABBCollisionInstance@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CAABBCollisionInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVCAABBCollisionInstance@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCAABBCollisionInstance@@@std@@QBEIXZ PROC ; std::allocator<CAABBCollisionInstance *>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAVCAABBCollisionInstance@@@std@@QBEIXZ ENDP ; std::allocator<CAABBCollisionInstance *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEXPAPAVCAABBCollisionInstance@@ABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEXPAPAVCAABBCollisionInstance@@ABQAV3@@Z PROC ; std::allocator<CAABBCollisionInstance *>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 594  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEXPAPAVCAABBCollisionInstance@@ABQAV3@@Z ENDP ; std::allocator<CAABBCollisionInstance *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEPAPAVCAABBCollisionInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEPAPAVCAABBCollisionInstance@@I@Z PROC ; std::allocator<CAABBCollisionInstance *>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 579  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEPAPAVCAABBCollisionInstance@@I@Z ENDP ; std::allocator<CAABBCollisionInstance *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEXPAPAVCAABBCollisionInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEXPAPAVCAABBCollisionInstance@@I@Z PROC ; std::allocator<CAABBCollisionInstance *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEXPAPAVCAABBCollisionInstance@@I@Z ENDP ; std::allocator<CAABBCollisionInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCAABBCollisionInstance@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCAABBCollisionInstance@@@std@@QAE@XZ PROC ; std::allocator<CAABBCollisionInstance *>::allocator<CAABBCollisionInstance *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCAABBCollisionInstance@@@std@@QAE@XZ ENDP ; std::allocator<CAABBCollisionInstance *>::allocator<CAABBCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCAABBCollisionInstance@@@@KAXPAVCAABBCollisionInstance@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCAABBCollisionInstance@@@@KAXPAVCAABBCollisionInstance@@@Z PROC ; CDynamicPool<CAABBCollisionInstance>::Delete, COMDAT

; 110  : 			delete pkData;

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPool@VCAABBCollisionInstance@@@@KAXPAVCAABBCollisionInstance@@@Z ENDP ; CDynamicPool<CAABBCollisionInstance>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ?Free@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEXPAVCAABBCollisionInstance@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Free@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEXPAVCAABBCollisionInstance@@@Z PROC ; CDynamicPool<CAABBCollisionInstance>::Free, COMDAT
; _this$ = ecx

; 76   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 77   : #ifdef DYNAMIC_POOL_STRICT
; 78   : 			assert(__IsValidData(pkData));
; 79   : 			assert(!__IsFreeData(pkData));
; 80   : #endif
; 81   : 			m_kVct_pkFree.push_back(pkData);

  00003	8d 45 08	 lea	 eax, DWORD PTR _pkData$[ebp]
  00006	83 c1 10	 add	 ecx, 16			; 00000010H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXABQAVCAABBCollisionInstance@@@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::push_back

; 82   : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?Free@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEXPAVCAABBCollisionInstance@@@Z ENDP ; CDynamicPool<CAABBCollisionInstance>::Free
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEPAVCAABBCollisionInstance@@XZ
_TEXT	SEGMENT
_pkNewData$1 = -4					; size = 4
?Alloc@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEPAVCAABBCollisionInstance@@XZ PROC ; CDynamicPool<CAABBCollisionInstance>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00007	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000a	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  0000d	75 32		 jne	 SHORT $LN1@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  0000f	6a 1c		 push	 28			; 0000001cH
  00011	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00016	83 c4 04	 add	 esp, 4
  00019	85 c0		 test	 eax, eax
  0001b	74 08		 je	 SHORT $LN4@Alloc
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CAABBCollisionInstance@@6B@
  00023	eb 02		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  00025	33 c0		 xor	 eax, eax
$LN5@Alloc:
  00027	89 45 fc	 mov	 DWORD PTR _pkNewData$1[ebp], eax

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  0002a	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0002d	8d 45 fc	 lea	 eax, DWORD PTR _pkNewData$1[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXABQAVCAABBCollisionInstance@@@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::push_back

; 67   : 				++m_uUsedCapacity;

  00036	ff 46 20	 inc	 DWORD PTR [esi+32]

; 68   : 				return pkNewData;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _pkNewData$1[ebp]
  0003c	5e		 pop	 esi

; 74   : 		}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
$LN1@Alloc:

; 69   : 			}
; 70   : 
; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  00041	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00044	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1282 : 		--this->_Mylast;

  00047	83 46 14 fc	 add	 DWORD PTR [esi+20], -4	; fffffffcH
  0004b	5e		 pop	 esi
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 74   : 		}

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?Alloc@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEPAVCAABBCollisionInstance@@XZ ENDP ; CDynamicPool<CAABBCollisionInstance>::Alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEXXZ PROC ; CDynamicPool<CAABBCollisionInstance>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 38   : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPool@VCAABBCollisionInstance@@@@KAXPAVCAABBCollisionInstance@@@Z ; CDynamicPool<CAABBCollisionInstance>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 53   : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEXXZ ENDP ; CDynamicPool<CAABBCollisionInstance>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ??1?$CDynamicPool@VCAABBCollisionInstance@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@VCAABBCollisionInstance@@@@UAE@XZ PROC ; CDynamicPool<CAABBCollisionInstance>::~CDynamicPool<CAABBCollisionInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCAABBCollisionInstance@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	85 c0		 test	 eax, eax
  0000e	74 1e		 je	 SHORT $LN7@CDynamicPo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  00020	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00027	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN7@CDynamicPo:

; 1623 : 		if (this->_Myfirst != pointer())

  0002e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00031	85 c0		 test	 eax, eax
  00033	74 1e		 je	 SHORT $LN20@CDynamicPo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0003e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  00045	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  0004c	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN20@CDynamicPo:
  00053	5e		 pop	 esi
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 26   : 		}

  00054	c3		 ret	 0
??1?$CDynamicPool@VCAABBCollisionInstance@@@@UAE@XZ ENDP ; CDynamicPool<CAABBCollisionInstance>::~CDynamicPool<CAABBCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ??0?$CDynamicPool@VCAABBCollisionInstance@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPool@VCAABBCollisionInstance@@@@QAE@XZ PROC ; CDynamicPool<CAABBCollisionInstance>::CDynamicPool<CAABBCollisionInstance>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPool@VCAABBCollisionInstance@@@@6B@

; 16   : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 14   : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 15   : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 16   : 		}

  00040	c3		 ret	 0
??0?$CDynamicPool@VCAABBCollisionInstance@@@@QAE@XZ ENDP ; CDynamicPool<CAABBCollisionInstance>::CDynamicPool<CAABBCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??__Fgs_pci@@YAXXZ
text$yd	SEGMENT
$T1 = -1						; size = 1
$T2 = -1						; size = 1
??__Fgs_pci@@YAXXZ PROC					; `dynamic atexit destructor for 'gs_pci'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00004	a1 10 00 00 00	 mov	 eax, DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+16
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 18   : 		{

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A, OFFSET ??_7?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00013	85 c0		 test	 eax, eax
  00015	74 45		 je	 SHORT $LN7@dynamic

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00017	ff 35 14 00 00
	00		 push	 DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+20
  0001d	b9 10 00 00 00	 mov	 ecx, OFFSET ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+16
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXPAPAVCPlaneCollisionInstance@@0@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Destroy

; 642  : 		return (_Alty());

  00028	8d 4d ff	 lea	 ecx, DWORD PTR $T2[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00030	ff 35 10 00 00
	00		 push	 DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+16
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0003e	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+16, 0

; 1630 : 			this->_Mylast = pointer();

  00048	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+20, 0

; 1631 : 			this->_Myend = pointer();

  00052	c7 05 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+24, 0
$LN7@dynamic:

; 1623 : 		if (this->_Myfirst != pointer())

  0005c	a1 04 00 00 00	 mov	 eax, DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+4
  00061	85 c0		 test	 eax, eax
  00063	74 45		 je	 SHORT $LN20@dynamic

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00065	ff 35 08 00 00
	00		 push	 DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+8
  0006b	b9 04 00 00 00	 mov	 ecx, OFFSET ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+4
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXPAPAVCPlaneCollisionInstance@@0@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Destroy

; 642  : 		return (_Alty());

  00076	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00079	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007e	ff 35 04 00 00
	00		 push	 DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+4
  00084	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00089	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0008c	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+4, 0

; 1630 : 			this->_Mylast = pointer();

  00096	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+8, 0

; 1631 : 			this->_Myend = pointer();

  000a0	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+12, 0
$LN20@dynamic:
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
??__Fgs_pci@@YAXXZ ENDP					; `dynamic atexit destructor for 'gs_pci''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ??__Egs_pci@@YAXXZ
text$di	SEGMENT
??__Egs_pci@@YAXXZ PROC					; `dynamic initializer for 'gs_pci'', COMDAT

; 20   : CDynamicPool<CPlaneCollisionInstance> gs_pci;

  00000	68 00 00 00 00	 push	 OFFSET ??__Fgs_pci@@YAXXZ ; `dynamic atexit destructor for 'gs_pci''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Egs_pci@@YAXXZ ENDP					; `dynamic initializer for 'gs_pci''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??_G?$CDynamicPool@VCPlaneCollisionInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCPlaneCollisionInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CPlaneCollisionInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 18   : 		{

  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  0000c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000f	85 c0		 test	 eax, eax
  00011	74 1e		 je	 SHORT $LN8@scalar
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00019	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0001c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  00023	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  0002a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN8@scalar:

; 1623 : 		if (this->_Myfirst != pointer())

  00031	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00034	85 c0		 test	 eax, eax
  00036	74 1e		 je	 SHORT $LN21@scalar
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003e	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00041	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  00048	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  0004f	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN21@scalar:
  00056	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0005a	74 09		 je	 SHORT $LN32@scalar
  0005c	56		 push	 esi
  0005d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00062	83 c4 04	 add	 esp, 4
$LN32@scalar:
  00065	8b c6		 mov	 eax, esi
  00067	5e		 pop	 esi
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCPlaneCollisionInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CPlaneCollisionInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IBEXPAPAVCPlaneCollisionInstance@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IBEXPAPAVCPlaneCollisionInstance@@0@Z PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IBEXPAPAVCPlaneCollisionInstance@@0@Z ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IBEXXZ PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IBEXXZ ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXXZ PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXXZ ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000c	2b c6		 sub	 eax, esi
  0000e	57		 push	 edi

; 1613 : 		if (_Unused_capacity() < _Count)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00012	c1 f8 02	 sar	 eax, 2

; 1613 : 		if (_Unused_capacity() < _Count)

  00015	3b c7		 cmp	 eax, edi
  00017	73 49		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00019	2b 31		 sub	 esi, DWORD PTR [ecx]
  0001b	53		 push	 ebx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  0001c	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00021	c1 fe 02	 sar	 esi, 2

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00024	8b c3		 mov	 eax, ebx
  00026	2b c6		 sub	 eax, esi
  00028	3b c7		 cmp	 eax, edi
  0002a	72 3c		 jb	 SHORT $LN43@Reserve

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0002c	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0002e	03 f7		 add	 esi, edi

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00030	c1 fa 02	 sar	 edx, 2

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00033	8b c2		 mov	 eax, edx
  00035	d1 e8		 shr	 eax, 1
  00037	2b d8		 sub	 ebx, eax
  00039	3b da		 cmp	 ebx, edx
  0003b	5b		 pop	 ebx
  0003c	73 12		 jae	 SHORT $LN27@Reserve
  0003e	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  00040	3b d6		 cmp	 edx, esi
  00042	5f		 pop	 edi
  00043	0f 42 d6	 cmovb	 edx, esi
  00046	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00047	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0004a	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Reallocate
$LN27@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00050	03 d0		 add	 edx, eax

; 1576 : 		if (_Capacity < _Count)

  00052	3b d6		 cmp	 edx, esi
  00054	5f		 pop	 edi
  00055	0f 42 d6	 cmovb	 edx, esi
  00058	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00059	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0005c	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0005d	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Reallocate
$LN2@Reserve:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 1618 : 			}
; 1619 : 		}

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN43@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0006d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN45@Reserve:
$LN42@Reserve:
  00072	cc		 int	 3
?_Reserve@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = 8						; size = 4
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi

; 23   : 	void *_Ptr = 0;

  00008	33 f6		 xor	 esi, esi
  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1587 : 		{	// move to array of exactly _Count elements

  0000b	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0000d	85 db		 test	 ebx, ebx
  0000f	74 1e		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00011	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  00017	77 5d		 ja	 SHORT $LN61@Reallocate
  00019	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	8b f0		 mov	 esi, eax
  00028	83 c4 04	 add	 esp, 4
  0002b	85 f6		 test	 esi, esi
  0002d	74 47		 je	 SHORT $LN61@Reallocate
$LN16@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  0002f	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00034	2b c1		 sub	 eax, ecx

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00036	83 e0 fc	 and	 eax, -4			; fffffffcH
  00039	50		 push	 eax
  0003a	51		 push	 ecx
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 _memmove
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00041	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00046	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00049	2b c1		 sub	 eax, ecx
  0004b	c1 f8 02	 sar	 eax, 2
  0004e	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  00051	85 c9		 test	 ecx, ecx
  00053	74 09		 je	 SHORT $LN56@Reallocate
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005b	83 c4 04	 add	 esp, 4
$LN56@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  0005e	8d 04 9e	 lea	 eax, DWORD PTR [esi+ebx*4]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  00061	89 37		 mov	 DWORD PTR [edi], esi
  00063	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00066	8b 45 08	 mov	 eax, DWORD PTR __Size$1$[ebp]
  00069	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  0006c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 1609 : 		}

  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
$LN61@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00076	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN63@Reallocate:
$LN60@Reallocate:
  0007b	cc		 int	 3
?_Reallocate@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IBE_NPBQAVCPlaneCollisionInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IBE_NPBQAVCPlaneCollisionInstance@@@Z PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IBE_NPBQAVCPlaneCollisionInstance@@@Z ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IBEII@Z PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00006	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 02	 sar	 edx, 2

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b c2		 cmp	 eax, edx
  00018	73 0f		 jae	 SHORT $LN4@Grow_to
  0001a	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  0001c	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0001f	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00023	8b c2		 mov	 eax, edx

; 1579 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00029	03 d1		 add	 edx, ecx

; 1576 : 		if (_Capacity < _Count)

  0002b	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0002e	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00032	8b c2		 mov	 eax, edx

; 1579 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Grow_to@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IBEII@Z ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXPAPAVCPlaneCollisionInstance@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXPAPAVCPlaneCollisionInstance@@0@Z PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXPAPAVCPlaneCollisionInstance@@0@Z ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?pop_back@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::pop_back, COMDAT
; _this$ = ecx

; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;

  00000	83 41 04 fc	 add	 DWORD PTR [ecx+4], -4	; fffffffcH

; 1283 : 		}

  00004	c3		 ret	 0
?pop_back@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXABQAVCPlaneCollisionInstance@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXABQAVCPlaneCollisionInstance@@@Z PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 31		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 2b		 ja	 SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Reserve
$LN3@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0002a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 2a		 je	 SHORT $LN49@push_back
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00036	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  00038	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN4@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  00042	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00045	75 09		 jne	 SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

  00047	6a 01		 push	 1
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Reserve
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00050	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00053	85 c9		 test	 ecx, ecx
  00055	74 04		 je	 SHORT $LN49@push_back
  00057	8b 07		 mov	 eax, DWORD PTR [edi]
  00059	89 01		 mov	 DWORD PTR [ecx], eax
$LN49@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  0005b	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?push_back@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXABQAVCPlaneCollisionInstance@@@Z ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?back@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEAAPAVCPlaneCollisionInstance@@XZ
_TEXT	SEGMENT
?back@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEAAPAVCPlaneCollisionInstance@@XZ PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::back, COMDAT
; _this$ = ecx

; 170  : 		_Ptr += _Off;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 e8 04	 sub	 eax, 4

; 1234 : 		return (*(end() - 1));
; 1235 : 		}

  00006	c3		 ret	 0
?back@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEAAPAVCPlaneCollisionInstance@@XZ ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?empty@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBE_NXZ PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::empty, COMDAT
; _this$ = ecx

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 1159 : 		}

  0000a	c3		 ret	 0
?empty@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00006	c1 f8 02	 sar	 eax, 2

; 1016 : 		}

  00009	c3		 ret	 0
?_Unused_capacity@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1011 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::~vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::~vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCPlaneCollisionInstance@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCPlaneCollisionInstance@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCPlaneCollisionInstance@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> >::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> >::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXPAPAVCPlaneCollisionInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXPAPAVCPlaneCollisionInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXPAPAVCPlaneCollisionInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 848  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >::_Wrap_alloc<std::allocator<CPlaneCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@SAIABV?$allocator@PAVCPlaneCollisionInstance@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@SAIABV?$allocator@PAVCPlaneCollisionInstance@@@2@@Z PROC ; std::allocator_traits<std::allocator<CPlaneCollisionInstance *> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@SAIABV?$allocator@PAVCPlaneCollisionInstance@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CPlaneCollisionInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVCPlaneCollisionInstance@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCPlaneCollisionInstance@@@std@@QBEIXZ PROC ; std::allocator<CPlaneCollisionInstance *>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAVCPlaneCollisionInstance@@@std@@QBEIXZ ENDP ; std::allocator<CPlaneCollisionInstance *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEXPAPAVCPlaneCollisionInstance@@ABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEXPAPAVCPlaneCollisionInstance@@ABQAV3@@Z PROC ; std::allocator<CPlaneCollisionInstance *>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 594  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEXPAPAVCPlaneCollisionInstance@@ABQAV3@@Z ENDP ; std::allocator<CPlaneCollisionInstance *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEPAPAVCPlaneCollisionInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEPAPAVCPlaneCollisionInstance@@I@Z PROC ; std::allocator<CPlaneCollisionInstance *>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 579  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEPAPAVCPlaneCollisionInstance@@I@Z ENDP ; std::allocator<CPlaneCollisionInstance *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEXPAPAVCPlaneCollisionInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEXPAPAVCPlaneCollisionInstance@@I@Z PROC ; std::allocator<CPlaneCollisionInstance *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEXPAPAVCPlaneCollisionInstance@@I@Z ENDP ; std::allocator<CPlaneCollisionInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCPlaneCollisionInstance@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCPlaneCollisionInstance@@@std@@QAE@XZ PROC ; std::allocator<CPlaneCollisionInstance *>::allocator<CPlaneCollisionInstance *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCPlaneCollisionInstance@@@std@@QAE@XZ ENDP ; std::allocator<CPlaneCollisionInstance *>::allocator<CPlaneCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCPlaneCollisionInstance@@@@KAXPAVCPlaneCollisionInstance@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCPlaneCollisionInstance@@@@KAXPAVCPlaneCollisionInstance@@@Z PROC ; CDynamicPool<CPlaneCollisionInstance>::Delete, COMDAT

; 110  : 			delete pkData;

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPool@VCPlaneCollisionInstance@@@@KAXPAVCPlaneCollisionInstance@@@Z ENDP ; CDynamicPool<CPlaneCollisionInstance>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ?Free@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEXPAVCPlaneCollisionInstance@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Free@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEXPAVCPlaneCollisionInstance@@@Z PROC ; CDynamicPool<CPlaneCollisionInstance>::Free, COMDAT
; _this$ = ecx

; 76   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 77   : #ifdef DYNAMIC_POOL_STRICT
; 78   : 			assert(__IsValidData(pkData));
; 79   : 			assert(!__IsFreeData(pkData));
; 80   : #endif
; 81   : 			m_kVct_pkFree.push_back(pkData);

  00003	8d 45 08	 lea	 eax, DWORD PTR _pkData$[ebp]
  00006	83 c1 10	 add	 ecx, 16			; 00000010H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXABQAVCPlaneCollisionInstance@@@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::push_back

; 82   : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?Free@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEXPAVCPlaneCollisionInstance@@@Z ENDP ; CDynamicPool<CPlaneCollisionInstance>::Free
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEPAVCPlaneCollisionInstance@@XZ
_TEXT	SEGMENT
_pkNewData$1 = -4					; size = 4
?Alloc@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEPAVCPlaneCollisionInstance@@XZ PROC ; CDynamicPool<CPlaneCollisionInstance>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00007	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000a	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  0000d	75 32		 jne	 SHORT $LN1@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  0000f	6a 7c		 push	 124			; 0000007cH
  00011	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00016	83 c4 04	 add	 esp, 4
  00019	85 c0		 test	 eax, eax
  0001b	74 08		 je	 SHORT $LN4@Alloc
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CPlaneCollisionInstance@@6B@
  00023	eb 02		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  00025	33 c0		 xor	 eax, eax
$LN5@Alloc:
  00027	89 45 fc	 mov	 DWORD PTR _pkNewData$1[ebp], eax

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  0002a	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0002d	8d 45 fc	 lea	 eax, DWORD PTR _pkNewData$1[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXABQAVCPlaneCollisionInstance@@@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::push_back

; 67   : 				++m_uUsedCapacity;

  00036	ff 46 20	 inc	 DWORD PTR [esi+32]

; 68   : 				return pkNewData;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _pkNewData$1[ebp]
  0003c	5e		 pop	 esi

; 74   : 		}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
$LN1@Alloc:

; 69   : 			}
; 70   : 
; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  00041	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00044	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1282 : 		--this->_Mylast;

  00047	83 46 14 fc	 add	 DWORD PTR [esi+20], -4	; fffffffcH
  0004b	5e		 pop	 esi
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 74   : 		}

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?Alloc@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEPAVCPlaneCollisionInstance@@XZ ENDP ; CDynamicPool<CPlaneCollisionInstance>::Alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEXXZ PROC ; CDynamicPool<CPlaneCollisionInstance>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 38   : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPool@VCPlaneCollisionInstance@@@@KAXPAVCPlaneCollisionInstance@@@Z ; CDynamicPool<CPlaneCollisionInstance>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 53   : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEXXZ ENDP ; CDynamicPool<CPlaneCollisionInstance>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ??1?$CDynamicPool@VCPlaneCollisionInstance@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@VCPlaneCollisionInstance@@@@UAE@XZ PROC ; CDynamicPool<CPlaneCollisionInstance>::~CDynamicPool<CPlaneCollisionInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	85 c0		 test	 eax, eax
  0000e	74 1e		 je	 SHORT $LN7@CDynamicPo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  00020	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00027	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN7@CDynamicPo:

; 1623 : 		if (this->_Myfirst != pointer())

  0002e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00031	85 c0		 test	 eax, eax
  00033	74 1e		 je	 SHORT $LN20@CDynamicPo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0003e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  00045	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  0004c	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN20@CDynamicPo:
  00053	5e		 pop	 esi
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 26   : 		}

  00054	c3		 ret	 0
??1?$CDynamicPool@VCPlaneCollisionInstance@@@@UAE@XZ ENDP ; CDynamicPool<CPlaneCollisionInstance>::~CDynamicPool<CPlaneCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ??0?$CDynamicPool@VCPlaneCollisionInstance@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPool@VCPlaneCollisionInstance@@@@QAE@XZ PROC ; CDynamicPool<CPlaneCollisionInstance>::CDynamicPool<CPlaneCollisionInstance>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@

; 16   : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 14   : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 15   : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 16   : 		}

  00040	c3		 ret	 0
??0?$CDynamicPool@VCPlaneCollisionInstance@@@@QAE@XZ ENDP ; CDynamicPool<CPlaneCollisionInstance>::CDynamicPool<CPlaneCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??__Fgs_cci@@YAXXZ
text$yd	SEGMENT
$T1 = -1						; size = 1
$T2 = -1						; size = 1
??__Fgs_cci@@YAXXZ PROC					; `dynamic atexit destructor for 'gs_cci'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00004	a1 10 00 00 00	 mov	 eax, DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+16
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 18   : 		{

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A, OFFSET ??_7?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00013	85 c0		 test	 eax, eax
  00015	74 45		 je	 SHORT $LN7@dynamic

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00017	ff 35 14 00 00
	00		 push	 DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+20
  0001d	b9 10 00 00 00	 mov	 ecx, OFFSET ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+16
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXPAPAVCCylinderCollisionInstance@@0@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Destroy

; 642  : 		return (_Alty());

  00028	8d 4d ff	 lea	 ecx, DWORD PTR $T2[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00030	ff 35 10 00 00
	00		 push	 DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+16
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0003e	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+16, 0

; 1630 : 			this->_Mylast = pointer();

  00048	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+20, 0

; 1631 : 			this->_Myend = pointer();

  00052	c7 05 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+24, 0
$LN7@dynamic:

; 1623 : 		if (this->_Myfirst != pointer())

  0005c	a1 04 00 00 00	 mov	 eax, DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+4
  00061	85 c0		 test	 eax, eax
  00063	74 45		 je	 SHORT $LN20@dynamic

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00065	ff 35 08 00 00
	00		 push	 DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+8
  0006b	b9 04 00 00 00	 mov	 ecx, OFFSET ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+4
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXPAPAVCCylinderCollisionInstance@@0@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Destroy

; 642  : 		return (_Alty());

  00076	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00079	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007e	ff 35 04 00 00
	00		 push	 DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+4
  00084	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00089	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0008c	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+4, 0

; 1630 : 			this->_Mylast = pointer();

  00096	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+8, 0

; 1631 : 			this->_Myend = pointer();

  000a0	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+12, 0
$LN20@dynamic:
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
??__Fgs_cci@@YAXXZ ENDP					; `dynamic atexit destructor for 'gs_cci''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ??__Egs_cci@@YAXXZ
text$di	SEGMENT
??__Egs_cci@@YAXXZ PROC					; `dynamic initializer for 'gs_cci'', COMDAT

; 19   : CDynamicPool<CCylinderCollisionInstance> gs_cci;

  00000	68 00 00 00 00	 push	 OFFSET ??__Fgs_cci@@YAXXZ ; `dynamic atexit destructor for 'gs_cci''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Egs_cci@@YAXXZ ENDP					; `dynamic initializer for 'gs_cci''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??_G?$CDynamicPool@VCCylinderCollisionInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCCylinderCollisionInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CCylinderCollisionInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 18   : 		{

  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  0000c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000f	85 c0		 test	 eax, eax
  00011	74 1e		 je	 SHORT $LN8@scalar
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00019	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0001c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  00023	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  0002a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN8@scalar:

; 1623 : 		if (this->_Myfirst != pointer())

  00031	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00034	85 c0		 test	 eax, eax
  00036	74 1e		 je	 SHORT $LN21@scalar
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003e	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00041	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  00048	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  0004f	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN21@scalar:
  00056	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0005a	74 09		 je	 SHORT $LN32@scalar
  0005c	56		 push	 esi
  0005d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00062	83 c4 04	 add	 esp, 4
$LN32@scalar:
  00065	8b c6		 mov	 eax, esi
  00067	5e		 pop	 esi
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCCylinderCollisionInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CCylinderCollisionInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IBEXPAPAVCCylinderCollisionInstance@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IBEXPAPAVCCylinderCollisionInstance@@0@Z PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IBEXPAPAVCCylinderCollisionInstance@@0@Z ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IBEXXZ PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IBEXXZ ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXXZ PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXXZ ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000c	2b c6		 sub	 eax, esi
  0000e	57		 push	 edi

; 1613 : 		if (_Unused_capacity() < _Count)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00012	c1 f8 02	 sar	 eax, 2

; 1613 : 		if (_Unused_capacity() < _Count)

  00015	3b c7		 cmp	 eax, edi
  00017	73 49		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00019	2b 31		 sub	 esi, DWORD PTR [ecx]
  0001b	53		 push	 ebx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  0001c	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00021	c1 fe 02	 sar	 esi, 2

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00024	8b c3		 mov	 eax, ebx
  00026	2b c6		 sub	 eax, esi
  00028	3b c7		 cmp	 eax, edi
  0002a	72 3c		 jb	 SHORT $LN43@Reserve

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0002c	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0002e	03 f7		 add	 esi, edi

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00030	c1 fa 02	 sar	 edx, 2

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00033	8b c2		 mov	 eax, edx
  00035	d1 e8		 shr	 eax, 1
  00037	2b d8		 sub	 ebx, eax
  00039	3b da		 cmp	 ebx, edx
  0003b	5b		 pop	 ebx
  0003c	73 12		 jae	 SHORT $LN27@Reserve
  0003e	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  00040	3b d6		 cmp	 edx, esi
  00042	5f		 pop	 edi
  00043	0f 42 d6	 cmovb	 edx, esi
  00046	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00047	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0004a	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Reallocate
$LN27@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00050	03 d0		 add	 edx, eax

; 1576 : 		if (_Capacity < _Count)

  00052	3b d6		 cmp	 edx, esi
  00054	5f		 pop	 edi
  00055	0f 42 d6	 cmovb	 edx, esi
  00058	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00059	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0005c	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0005d	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Reallocate
$LN2@Reserve:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 1618 : 			}
; 1619 : 		}

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN43@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0006d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN45@Reserve:
$LN42@Reserve:
  00072	cc		 int	 3
?_Reserve@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = 8						; size = 4
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi

; 23   : 	void *_Ptr = 0;

  00008	33 f6		 xor	 esi, esi
  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1587 : 		{	// move to array of exactly _Count elements

  0000b	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0000d	85 db		 test	 ebx, ebx
  0000f	74 1e		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00011	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  00017	77 5d		 ja	 SHORT $LN61@Reallocate
  00019	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	8b f0		 mov	 esi, eax
  00028	83 c4 04	 add	 esp, 4
  0002b	85 f6		 test	 esi, esi
  0002d	74 47		 je	 SHORT $LN61@Reallocate
$LN16@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  0002f	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00034	2b c1		 sub	 eax, ecx

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00036	83 e0 fc	 and	 eax, -4			; fffffffcH
  00039	50		 push	 eax
  0003a	51		 push	 ecx
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 _memmove
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00041	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00046	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00049	2b c1		 sub	 eax, ecx
  0004b	c1 f8 02	 sar	 eax, 2
  0004e	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  00051	85 c9		 test	 ecx, ecx
  00053	74 09		 je	 SHORT $LN56@Reallocate
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005b	83 c4 04	 add	 esp, 4
$LN56@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  0005e	8d 04 9e	 lea	 eax, DWORD PTR [esi+ebx*4]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  00061	89 37		 mov	 DWORD PTR [edi], esi
  00063	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00066	8b 45 08	 mov	 eax, DWORD PTR __Size$1$[ebp]
  00069	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  0006c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 1609 : 		}

  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
$LN61@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00076	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN63@Reallocate:
$LN60@Reallocate:
  0007b	cc		 int	 3
?_Reallocate@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IBE_NPBQAVCCylinderCollisionInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IBE_NPBQAVCCylinderCollisionInstance@@@Z PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IBE_NPBQAVCCylinderCollisionInstance@@@Z ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IBEII@Z PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00006	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 02	 sar	 edx, 2

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b c2		 cmp	 eax, edx
  00018	73 0f		 jae	 SHORT $LN4@Grow_to
  0001a	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  0001c	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0001f	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00023	8b c2		 mov	 eax, edx

; 1579 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00029	03 d1		 add	 edx, ecx

; 1576 : 		if (_Capacity < _Count)

  0002b	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0002e	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00032	8b c2		 mov	 eax, edx

; 1579 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Grow_to@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IBEII@Z ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXPAPAVCCylinderCollisionInstance@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXPAPAVCCylinderCollisionInstance@@0@Z PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXPAPAVCCylinderCollisionInstance@@0@Z ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?pop_back@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::pop_back, COMDAT
; _this$ = ecx

; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;

  00000	83 41 04 fc	 add	 DWORD PTR [ecx+4], -4	; fffffffcH

; 1283 : 		}

  00004	c3		 ret	 0
?pop_back@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXABQAVCCylinderCollisionInstance@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXABQAVCCylinderCollisionInstance@@@Z PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 31		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 2b		 ja	 SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Reserve
$LN3@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0002a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 2a		 je	 SHORT $LN49@push_back
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00036	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  00038	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN4@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  00042	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00045	75 09		 jne	 SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

  00047	6a 01		 push	 1
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Reserve
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00050	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00053	85 c9		 test	 ecx, ecx
  00055	74 04		 je	 SHORT $LN49@push_back
  00057	8b 07		 mov	 eax, DWORD PTR [edi]
  00059	89 01		 mov	 DWORD PTR [ecx], eax
$LN49@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  0005b	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?push_back@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXABQAVCCylinderCollisionInstance@@@Z ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?back@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEAAPAVCCylinderCollisionInstance@@XZ
_TEXT	SEGMENT
?back@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEAAPAVCCylinderCollisionInstance@@XZ PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::back, COMDAT
; _this$ = ecx

; 170  : 		_Ptr += _Off;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 e8 04	 sub	 eax, 4

; 1234 : 		return (*(end() - 1));
; 1235 : 		}

  00006	c3		 ret	 0
?back@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEAAPAVCCylinderCollisionInstance@@XZ ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?empty@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBE_NXZ PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::empty, COMDAT
; _this$ = ecx

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 1159 : 		}

  0000a	c3		 ret	 0
?empty@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00006	c1 f8 02	 sar	 eax, 2

; 1016 : 		}

  00009	c3		 ret	 0
?_Unused_capacity@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1011 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::~vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::~vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCCylinderCollisionInstance@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCCylinderCollisionInstance@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCCylinderCollisionInstance@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> >::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> >::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXPAPAVCCylinderCollisionInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXPAPAVCCylinderCollisionInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXPAPAVCCylinderCollisionInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 848  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >::_Wrap_alloc<std::allocator<CCylinderCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@SAIABV?$allocator@PAVCCylinderCollisionInstance@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@SAIABV?$allocator@PAVCCylinderCollisionInstance@@@2@@Z PROC ; std::allocator_traits<std::allocator<CCylinderCollisionInstance *> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@SAIABV?$allocator@PAVCCylinderCollisionInstance@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CCylinderCollisionInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVCCylinderCollisionInstance@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCCylinderCollisionInstance@@@std@@QBEIXZ PROC ; std::allocator<CCylinderCollisionInstance *>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAVCCylinderCollisionInstance@@@std@@QBEIXZ ENDP ; std::allocator<CCylinderCollisionInstance *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEXPAPAVCCylinderCollisionInstance@@ABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEXPAPAVCCylinderCollisionInstance@@ABQAV3@@Z PROC ; std::allocator<CCylinderCollisionInstance *>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 594  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEXPAPAVCCylinderCollisionInstance@@ABQAV3@@Z ENDP ; std::allocator<CCylinderCollisionInstance *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEPAPAVCCylinderCollisionInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEPAPAVCCylinderCollisionInstance@@I@Z PROC ; std::allocator<CCylinderCollisionInstance *>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 579  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEPAPAVCCylinderCollisionInstance@@I@Z ENDP ; std::allocator<CCylinderCollisionInstance *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEXPAPAVCCylinderCollisionInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEXPAPAVCCylinderCollisionInstance@@I@Z PROC ; std::allocator<CCylinderCollisionInstance *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEXPAPAVCCylinderCollisionInstance@@I@Z ENDP ; std::allocator<CCylinderCollisionInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCCylinderCollisionInstance@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCCylinderCollisionInstance@@@std@@QAE@XZ PROC ; std::allocator<CCylinderCollisionInstance *>::allocator<CCylinderCollisionInstance *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCCylinderCollisionInstance@@@std@@QAE@XZ ENDP ; std::allocator<CCylinderCollisionInstance *>::allocator<CCylinderCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCCylinderCollisionInstance@@@@KAXPAVCCylinderCollisionInstance@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCCylinderCollisionInstance@@@@KAXPAVCCylinderCollisionInstance@@@Z PROC ; CDynamicPool<CCylinderCollisionInstance>::Delete, COMDAT

; 110  : 			delete pkData;

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPool@VCCylinderCollisionInstance@@@@KAXPAVCCylinderCollisionInstance@@@Z ENDP ; CDynamicPool<CCylinderCollisionInstance>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ?Free@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEXPAVCCylinderCollisionInstance@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Free@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEXPAVCCylinderCollisionInstance@@@Z PROC ; CDynamicPool<CCylinderCollisionInstance>::Free, COMDAT
; _this$ = ecx

; 76   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 77   : #ifdef DYNAMIC_POOL_STRICT
; 78   : 			assert(__IsValidData(pkData));
; 79   : 			assert(!__IsFreeData(pkData));
; 80   : #endif
; 81   : 			m_kVct_pkFree.push_back(pkData);

  00003	8d 45 08	 lea	 eax, DWORD PTR _pkData$[ebp]
  00006	83 c1 10	 add	 ecx, 16			; 00000010H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXABQAVCCylinderCollisionInstance@@@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::push_back

; 82   : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?Free@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEXPAVCCylinderCollisionInstance@@@Z ENDP ; CDynamicPool<CCylinderCollisionInstance>::Free
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEPAVCCylinderCollisionInstance@@XZ
_TEXT	SEGMENT
_pkNewData$1 = -4					; size = 4
?Alloc@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEPAVCCylinderCollisionInstance@@XZ PROC ; CDynamicPool<CCylinderCollisionInstance>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00007	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000a	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  0000d	75 32		 jne	 SHORT $LN1@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  0000f	6a 18		 push	 24			; 00000018H
  00011	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00016	83 c4 04	 add	 esp, 4
  00019	85 c0		 test	 eax, eax
  0001b	74 08		 je	 SHORT $LN4@Alloc
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CCylinderCollisionInstance@@6B@
  00023	eb 02		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  00025	33 c0		 xor	 eax, eax
$LN5@Alloc:
  00027	89 45 fc	 mov	 DWORD PTR _pkNewData$1[ebp], eax

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  0002a	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0002d	8d 45 fc	 lea	 eax, DWORD PTR _pkNewData$1[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXABQAVCCylinderCollisionInstance@@@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::push_back

; 67   : 				++m_uUsedCapacity;

  00036	ff 46 20	 inc	 DWORD PTR [esi+32]

; 68   : 				return pkNewData;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _pkNewData$1[ebp]
  0003c	5e		 pop	 esi

; 74   : 		}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
$LN1@Alloc:

; 69   : 			}
; 70   : 
; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  00041	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00044	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1282 : 		--this->_Mylast;

  00047	83 46 14 fc	 add	 DWORD PTR [esi+20], -4	; fffffffcH
  0004b	5e		 pop	 esi
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 74   : 		}

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?Alloc@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEPAVCCylinderCollisionInstance@@XZ ENDP ; CDynamicPool<CCylinderCollisionInstance>::Alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEXXZ PROC ; CDynamicPool<CCylinderCollisionInstance>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 38   : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPool@VCCylinderCollisionInstance@@@@KAXPAVCCylinderCollisionInstance@@@Z ; CDynamicPool<CCylinderCollisionInstance>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 53   : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEXXZ ENDP ; CDynamicPool<CCylinderCollisionInstance>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ??1?$CDynamicPool@VCCylinderCollisionInstance@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@VCCylinderCollisionInstance@@@@UAE@XZ PROC ; CDynamicPool<CCylinderCollisionInstance>::~CDynamicPool<CCylinderCollisionInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	85 c0		 test	 eax, eax
  0000e	74 1e		 je	 SHORT $LN7@CDynamicPo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  00020	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00027	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN7@CDynamicPo:

; 1623 : 		if (this->_Myfirst != pointer())

  0002e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00031	85 c0		 test	 eax, eax
  00033	74 1e		 je	 SHORT $LN20@CDynamicPo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0003e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  00045	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  0004c	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN20@CDynamicPo:
  00053	5e		 pop	 esi
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 26   : 		}

  00054	c3		 ret	 0
??1?$CDynamicPool@VCCylinderCollisionInstance@@@@UAE@XZ ENDP ; CDynamicPool<CCylinderCollisionInstance>::~CDynamicPool<CCylinderCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ??0?$CDynamicPool@VCCylinderCollisionInstance@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPool@VCCylinderCollisionInstance@@@@QAE@XZ PROC ; CDynamicPool<CCylinderCollisionInstance>::CDynamicPool<CCylinderCollisionInstance>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@

; 16   : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 14   : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 15   : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 16   : 		}

  00040	c3		 ret	 0
??0?$CDynamicPool@VCCylinderCollisionInstance@@@@QAE@XZ ENDP ; CDynamicPool<CCylinderCollisionInstance>::CDynamicPool<CCylinderCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??__Fgs_sci@@YAXXZ
text$yd	SEGMENT
$T1 = -1						; size = 1
$T2 = -1						; size = 1
??__Fgs_sci@@YAXXZ PROC					; `dynamic atexit destructor for 'gs_sci'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00004	a1 10 00 00 00	 mov	 eax, DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+16
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 18   : 		{

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A, OFFSET ??_7?$CDynamicPool@VCSphereCollisionInstance@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00013	85 c0		 test	 eax, eax
  00015	74 45		 je	 SHORT $LN7@dynamic

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00017	ff 35 14 00 00
	00		 push	 DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+20
  0001d	b9 10 00 00 00	 mov	 ecx, OFFSET ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+16
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXPAPAVCSphereCollisionInstance@@0@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Destroy

; 642  : 		return (_Alty());

  00028	8d 4d ff	 lea	 ecx, DWORD PTR $T2[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00030	ff 35 10 00 00
	00		 push	 DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+16
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0003e	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+16, 0

; 1630 : 			this->_Mylast = pointer();

  00048	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+20, 0

; 1631 : 			this->_Myend = pointer();

  00052	c7 05 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+24, 0
$LN7@dynamic:

; 1623 : 		if (this->_Myfirst != pointer())

  0005c	a1 04 00 00 00	 mov	 eax, DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+4
  00061	85 c0		 test	 eax, eax
  00063	74 45		 je	 SHORT $LN20@dynamic

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00065	ff 35 08 00 00
	00		 push	 DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+8
  0006b	b9 04 00 00 00	 mov	 ecx, OFFSET ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+4
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXPAPAVCSphereCollisionInstance@@0@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Destroy

; 642  : 		return (_Alty());

  00076	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00079	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007e	ff 35 04 00 00
	00		 push	 DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+4
  00084	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00089	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0008c	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+4, 0

; 1630 : 			this->_Mylast = pointer();

  00096	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+8, 0

; 1631 : 			this->_Myend = pointer();

  000a0	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+12, 0
$LN20@dynamic:
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
??__Fgs_sci@@YAXXZ ENDP					; `dynamic atexit destructor for 'gs_sci''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ??__Egs_sci@@YAXXZ
text$di	SEGMENT
??__Egs_sci@@YAXXZ PROC					; `dynamic initializer for 'gs_sci'', COMDAT

; 18   : CDynamicPool<CSphereCollisionInstance> gs_sci;

  00000	68 00 00 00 00	 push	 OFFSET ??__Fgs_sci@@YAXXZ ; `dynamic atexit destructor for 'gs_sci''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Egs_sci@@YAXXZ ENDP					; `dynamic initializer for 'gs_sci''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??_G?$CDynamicPool@VCSphereCollisionInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCSphereCollisionInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CSphereCollisionInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 18   : 		{

  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCSphereCollisionInstance@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  0000c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000f	85 c0		 test	 eax, eax
  00011	74 1e		 je	 SHORT $LN8@scalar
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00019	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0001c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  00023	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  0002a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN8@scalar:

; 1623 : 		if (this->_Myfirst != pointer())

  00031	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00034	85 c0		 test	 eax, eax
  00036	74 1e		 je	 SHORT $LN21@scalar
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003e	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00041	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  00048	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  0004f	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN21@scalar:
  00056	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0005a	74 09		 je	 SHORT $LN32@scalar
  0005c	56		 push	 esi
  0005d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00062	83 c4 04	 add	 esp, 4
$LN32@scalar:
  00065	8b c6		 mov	 eax, esi
  00067	5e		 pop	 esi
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCSphereCollisionInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CSphereCollisionInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IBEXPAPAVCSphereCollisionInstance@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IBEXPAPAVCSphereCollisionInstance@@0@Z PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IBEXPAPAVCSphereCollisionInstance@@0@Z ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IBEXXZ PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IBEXXZ ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXXZ PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXXZ ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000c	2b c6		 sub	 eax, esi
  0000e	57		 push	 edi

; 1613 : 		if (_Unused_capacity() < _Count)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00012	c1 f8 02	 sar	 eax, 2

; 1613 : 		if (_Unused_capacity() < _Count)

  00015	3b c7		 cmp	 eax, edi
  00017	73 49		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00019	2b 31		 sub	 esi, DWORD PTR [ecx]
  0001b	53		 push	 ebx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  0001c	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00021	c1 fe 02	 sar	 esi, 2

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00024	8b c3		 mov	 eax, ebx
  00026	2b c6		 sub	 eax, esi
  00028	3b c7		 cmp	 eax, edi
  0002a	72 3c		 jb	 SHORT $LN43@Reserve

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0002c	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0002e	03 f7		 add	 esi, edi

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00030	c1 fa 02	 sar	 edx, 2

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00033	8b c2		 mov	 eax, edx
  00035	d1 e8		 shr	 eax, 1
  00037	2b d8		 sub	 ebx, eax
  00039	3b da		 cmp	 ebx, edx
  0003b	5b		 pop	 ebx
  0003c	73 12		 jae	 SHORT $LN27@Reserve
  0003e	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  00040	3b d6		 cmp	 edx, esi
  00042	5f		 pop	 edi
  00043	0f 42 d6	 cmovb	 edx, esi
  00046	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00047	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0004a	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Reallocate
$LN27@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00050	03 d0		 add	 edx, eax

; 1576 : 		if (_Capacity < _Count)

  00052	3b d6		 cmp	 edx, esi
  00054	5f		 pop	 edi
  00055	0f 42 d6	 cmovb	 edx, esi
  00058	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00059	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0005c	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0005d	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Reallocate
$LN2@Reserve:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 1618 : 			}
; 1619 : 		}

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN43@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0006d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN45@Reserve:
$LN42@Reserve:
  00072	cc		 int	 3
?_Reserve@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = 8						; size = 4
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi

; 23   : 	void *_Ptr = 0;

  00008	33 f6		 xor	 esi, esi
  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1587 : 		{	// move to array of exactly _Count elements

  0000b	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0000d	85 db		 test	 ebx, ebx
  0000f	74 1e		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00011	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  00017	77 5d		 ja	 SHORT $LN61@Reallocate
  00019	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	8b f0		 mov	 esi, eax
  00028	83 c4 04	 add	 esp, 4
  0002b	85 f6		 test	 esi, esi
  0002d	74 47		 je	 SHORT $LN61@Reallocate
$LN16@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  0002f	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00034	2b c1		 sub	 eax, ecx

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00036	83 e0 fc	 and	 eax, -4			; fffffffcH
  00039	50		 push	 eax
  0003a	51		 push	 ecx
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 _memmove
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00041	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00046	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00049	2b c1		 sub	 eax, ecx
  0004b	c1 f8 02	 sar	 eax, 2
  0004e	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  00051	85 c9		 test	 ecx, ecx
  00053	74 09		 je	 SHORT $LN56@Reallocate
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005b	83 c4 04	 add	 esp, 4
$LN56@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  0005e	8d 04 9e	 lea	 eax, DWORD PTR [esi+ebx*4]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  00061	89 37		 mov	 DWORD PTR [edi], esi
  00063	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00066	8b 45 08	 mov	 eax, DWORD PTR __Size$1$[ebp]
  00069	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  0006c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 1609 : 		}

  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
$LN61@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00076	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN63@Reallocate:
$LN60@Reallocate:
  0007b	cc		 int	 3
?_Reallocate@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IBE_NPBQAVCSphereCollisionInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IBE_NPBQAVCSphereCollisionInstance@@@Z PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IBE_NPBQAVCSphereCollisionInstance@@@Z ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IBEII@Z PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00006	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 02	 sar	 edx, 2

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b c2		 cmp	 eax, edx
  00018	73 0f		 jae	 SHORT $LN4@Grow_to
  0001a	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  0001c	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0001f	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00023	8b c2		 mov	 eax, edx

; 1579 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00029	03 d1		 add	 edx, ecx

; 1576 : 		if (_Capacity < _Count)

  0002b	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0002e	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00032	8b c2		 mov	 eax, edx

; 1579 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Grow_to@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IBEII@Z ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXPAPAVCSphereCollisionInstance@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXPAPAVCSphereCollisionInstance@@0@Z PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXPAPAVCSphereCollisionInstance@@0@Z ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?pop_back@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::pop_back, COMDAT
; _this$ = ecx

; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;

  00000	83 41 04 fc	 add	 DWORD PTR [ecx+4], -4	; fffffffcH

; 1283 : 		}

  00004	c3		 ret	 0
?pop_back@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXABQAVCSphereCollisionInstance@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXABQAVCSphereCollisionInstance@@@Z PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 31		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 2b		 ja	 SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Reserve
$LN3@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0002a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 2a		 je	 SHORT $LN49@push_back
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00036	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  00038	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN4@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  00042	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00045	75 09		 jne	 SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

  00047	6a 01		 push	 1
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@IAEXI@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Reserve
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00050	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00053	85 c9		 test	 ecx, ecx
  00055	74 04		 je	 SHORT $LN49@push_back
  00057	8b 07		 mov	 eax, DWORD PTR [edi]
  00059	89 01		 mov	 DWORD PTR [ecx], eax
$LN49@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  0005b	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?push_back@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXABQAVCSphereCollisionInstance@@@Z ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?back@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEAAPAVCSphereCollisionInstance@@XZ
_TEXT	SEGMENT
?back@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEAAPAVCSphereCollisionInstance@@XZ PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::back, COMDAT
; _this$ = ecx

; 170  : 		_Ptr += _Off;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 e8 04	 sub	 eax, 4

; 1234 : 		return (*(end() - 1));
; 1235 : 		}

  00006	c3		 ret	 0
?back@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEAAPAVCSphereCollisionInstance@@XZ ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?empty@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBE_NXZ PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::empty, COMDAT
; _this$ = ecx

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 1159 : 		}

  0000a	c3		 ret	 0
?empty@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00006	c1 f8 02	 sar	 eax, 2

; 1016 : 		}

  00009	c3		 ret	 0
?_Unused_capacity@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1011 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::~vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::~vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCSphereCollisionInstance@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCSphereCollisionInstance@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCSphereCollisionInstance@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> >::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> >::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXPAPAVCSphereCollisionInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXPAPAVCSphereCollisionInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXPAPAVCSphereCollisionInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 848  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >::_Wrap_alloc<std::allocator<CSphereCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@SAIABV?$allocator@PAVCSphereCollisionInstance@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@SAIABV?$allocator@PAVCSphereCollisionInstance@@@2@@Z PROC ; std::allocator_traits<std::allocator<CSphereCollisionInstance *> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@SAIABV?$allocator@PAVCSphereCollisionInstance@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CSphereCollisionInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVCSphereCollisionInstance@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCSphereCollisionInstance@@@std@@QBEIXZ PROC ; std::allocator<CSphereCollisionInstance *>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAVCSphereCollisionInstance@@@std@@QBEIXZ ENDP ; std::allocator<CSphereCollisionInstance *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEXPAPAVCSphereCollisionInstance@@ABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEXPAPAVCSphereCollisionInstance@@ABQAV3@@Z PROC ; std::allocator<CSphereCollisionInstance *>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 594  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEXPAPAVCSphereCollisionInstance@@ABQAV3@@Z ENDP ; std::allocator<CSphereCollisionInstance *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEPAPAVCSphereCollisionInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEPAPAVCSphereCollisionInstance@@I@Z PROC ; std::allocator<CSphereCollisionInstance *>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 579  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEPAPAVCSphereCollisionInstance@@I@Z ENDP ; std::allocator<CSphereCollisionInstance *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEXPAPAVCSphereCollisionInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEXPAPAVCSphereCollisionInstance@@I@Z PROC ; std::allocator<CSphereCollisionInstance *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEXPAPAVCSphereCollisionInstance@@I@Z ENDP ; std::allocator<CSphereCollisionInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCSphereCollisionInstance@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCSphereCollisionInstance@@@std@@QAE@XZ PROC ; std::allocator<CSphereCollisionInstance *>::allocator<CSphereCollisionInstance *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCSphereCollisionInstance@@@std@@QAE@XZ ENDP ; std::allocator<CSphereCollisionInstance *>::allocator<CSphereCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCSphereCollisionInstance@@@@KAXPAVCSphereCollisionInstance@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCSphereCollisionInstance@@@@KAXPAVCSphereCollisionInstance@@@Z PROC ; CDynamicPool<CSphereCollisionInstance>::Delete, COMDAT

; 110  : 			delete pkData;

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPool@VCSphereCollisionInstance@@@@KAXPAVCSphereCollisionInstance@@@Z ENDP ; CDynamicPool<CSphereCollisionInstance>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ?Free@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEXPAVCSphereCollisionInstance@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Free@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEXPAVCSphereCollisionInstance@@@Z PROC ; CDynamicPool<CSphereCollisionInstance>::Free, COMDAT
; _this$ = ecx

; 76   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 77   : #ifdef DYNAMIC_POOL_STRICT
; 78   : 			assert(__IsValidData(pkData));
; 79   : 			assert(!__IsFreeData(pkData));
; 80   : #endif
; 81   : 			m_kVct_pkFree.push_back(pkData);

  00003	8d 45 08	 lea	 eax, DWORD PTR _pkData$[ebp]
  00006	83 c1 10	 add	 ecx, 16			; 00000010H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXABQAVCSphereCollisionInstance@@@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::push_back

; 82   : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?Free@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEXPAVCSphereCollisionInstance@@@Z ENDP ; CDynamicPool<CSphereCollisionInstance>::Free
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEPAVCSphereCollisionInstance@@XZ
_TEXT	SEGMENT
_pkNewData$1 = -4					; size = 4
?Alloc@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEPAVCSphereCollisionInstance@@XZ PROC ; CDynamicPool<CSphereCollisionInstance>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00007	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000a	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  0000d	75 32		 jne	 SHORT $LN1@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  0000f	6a 14		 push	 20			; 00000014H
  00011	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00016	83 c4 04	 add	 esp, 4
  00019	85 c0		 test	 eax, eax
  0001b	74 08		 je	 SHORT $LN4@Alloc
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CSphereCollisionInstance@@6B@
  00023	eb 02		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  00025	33 c0		 xor	 eax, eax
$LN5@Alloc:
  00027	89 45 fc	 mov	 DWORD PTR _pkNewData$1[ebp], eax

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  0002a	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0002d	8d 45 fc	 lea	 eax, DWORD PTR _pkNewData$1[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXABQAVCSphereCollisionInstance@@@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::push_back

; 67   : 				++m_uUsedCapacity;

  00036	ff 46 20	 inc	 DWORD PTR [esi+32]

; 68   : 				return pkNewData;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _pkNewData$1[ebp]
  0003c	5e		 pop	 esi

; 74   : 		}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
$LN1@Alloc:

; 69   : 			}
; 70   : 
; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  00041	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00044	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1282 : 		--this->_Mylast;

  00047	83 46 14 fc	 add	 DWORD PTR [esi+20], -4	; fffffffcH
  0004b	5e		 pop	 esi
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 74   : 		}

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?Alloc@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEPAVCSphereCollisionInstance@@XZ ENDP ; CDynamicPool<CSphereCollisionInstance>::Alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEXXZ PROC ; CDynamicPool<CSphereCollisionInstance>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 38   : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPool@VCSphereCollisionInstance@@@@KAXPAVCSphereCollisionInstance@@@Z ; CDynamicPool<CSphereCollisionInstance>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 53   : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEXXZ ENDP ; CDynamicPool<CSphereCollisionInstance>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ??1?$CDynamicPool@VCSphereCollisionInstance@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@VCSphereCollisionInstance@@@@UAE@XZ PROC ; CDynamicPool<CSphereCollisionInstance>::~CDynamicPool<CSphereCollisionInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCSphereCollisionInstance@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	85 c0		 test	 eax, eax
  0000e	74 1e		 je	 SHORT $LN7@CDynamicPo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  00020	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00027	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN7@CDynamicPo:

; 1623 : 		if (this->_Myfirst != pointer())

  0002e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00031	85 c0		 test	 eax, eax
  00033	74 1e		 je	 SHORT $LN20@CDynamicPo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0003e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  00045	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  0004c	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN20@CDynamicPo:
  00053	5e		 pop	 esi
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 26   : 		}

  00054	c3		 ret	 0
??1?$CDynamicPool@VCSphereCollisionInstance@@@@UAE@XZ ENDP ; CDynamicPool<CSphereCollisionInstance>::~CDynamicPool<CSphereCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
;	COMDAT ??0?$CDynamicPool@VCSphereCollisionInstance@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPool@VCSphereCollisionInstance@@@@QAE@XZ PROC ; CDynamicPool<CSphereCollisionInstance>::CDynamicPool<CSphereCollisionInstance>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPool@VCSphereCollisionInstance@@@@6B@

; 16   : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 14   : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 15   : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 16   : 		}

  00040	c3		 ret	 0
??0?$CDynamicPool@VCSphereCollisionInstance@@@@QAE@XZ ENDP ; CDynamicPool<CSphereCollisionInstance>::CDynamicPool<CSphereCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCStateManager@@@@SAAAVCStateManager@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCStateManager@@@@SAAAVCStateManager@@XZ PROC ; CSingleton<CStateManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCStateManager@@@@SAAAVCStateManager@@XZ ENDP ; CSingleton<CStateManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
;	COMDAT ?square_distance_between_linesegment_and_point@@YAMABUD3DXVECTOR3@@00@Z
_TEXT	SEGMENT
_l$1$ = -4						; size = 4
$T1 = 8							; size = 4
_p1$ = 8						; size = 4
$T2 = 12						; size = 4
tv858 = 12						; size = 4
tv848 = 12						; size = 4
tv830 = 12						; size = 4
_p2$ = 12						; size = 4
$T3 = 16						; size = 4
_x$ = 16						; size = 4
?square_distance_between_linesegment_and_point@@YAMABUD3DXVECTOR3@@00@Z PROC ; square_distance_between_linesegment_and_point, COMDAT

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00004	8b 45 08	 mov	 eax, DWORD PTR _p1$[ebp]
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR _p2$[ebp]
  0000a	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  0000e	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00012	f3 0f 10 50 04	 movss	 xmm2, DWORD PTR [eax+4]
  00017	f3 0f 5c c3	 subss	 xmm0, xmm3
  0001b	f3 0f 10 69 04	 movss	 xmm5, DWORD PTR [ecx+4]
  00020	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  00025	f3 0f 5c ea	 subss	 xmm5, xmm2
  00029	f3 0f 10 61 08	 movss	 xmm4, DWORD PTR [ecx+8]
  0002e	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  00031	f3 0f 5c e1	 subss	 xmm4, xmm1

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00035	0f 28 f0	 movaps	 xmm6, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00038	f3 0f 11 45 08	 movss	 DWORD PTR $T1[ebp], xmm0

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0003d	f3 0f 59 f0	 mulss	 xmm6, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00041	f3 0f 10 78 08	 movss	 xmm7, DWORD PTR [eax+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00046	0f 28 c5	 movaps	 xmm0, xmm5
  00049	f3 0f 59 c5	 mulss	 xmm0, xmm5

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0004d	f3 0f 11 65 0c	 movss	 DWORD PTR $T2[ebp], xmm4

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00052	f3 0f 58 f0	 addss	 xmm6, xmm0
  00056	0f 28 c4	 movaps	 xmm0, xmm4
  00059	f3 0f 59 c4	 mulss	 xmm0, xmm4

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0005d	f3 0f 10 60 04	 movss	 xmm4, DWORD PTR [eax+4]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00062	f3 0f 58 f0	 addss	 xmm6, xmm0
  00066	f3 0f 11 75 fc	 movss	 DWORD PTR _l$1$[ebp], xmm6

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0006b	f3 0f 10 30	 movss	 xmm6, DWORD PTR [eax]
  0006f	0f 28 c6	 movaps	 xmm0, xmm6
  00072	f3 0f 5c c3	 subss	 xmm0, xmm3
  00076	0f 28 dc	 movaps	 xmm3, xmm4
  00079	f3 0f 5c da	 subss	 xmm3, xmm2
  0007d	0f 28 d7	 movaps	 xmm2, xmm7
  00080	f3 0f 5c d1	 subss	 xmm2, xmm1
  00084	f3 0f 11 45 10	 movss	 DWORD PTR $T3[ebp], xmm0

; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00089	f3 0f 59 45 08	 mulss	 xmm0, DWORD PTR $T1[ebp]
  0008e	0f 28 cb	 movaps	 xmm1, xmm3
  00091	f3 0f 59 cd	 mulss	 xmm1, xmm5
  00095	f3 0f 58 c8	 addss	 xmm1, xmm0
  00099	0f 28 c2	 movaps	 xmm0, xmm2
  0009c	f3 0f 59 45 0c	 mulss	 xmm0, DWORD PTR $T2[ebp]
  000a1	f3 0f 58 c8	 addss	 xmm1, xmm0
  000a5	0f 57 c0	 xorps	 xmm0, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 84   : 	if (d<=0.0f)

  000a8	0f 2f c1	 comiss	 xmm0, xmm1
  000ab	72 25		 jb	 SHORT $LN4@square_dis
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000ad	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR $T3[ebp]
  000b2	f3 0f 59 db	 mulss	 xmm3, xmm3
  000b6	f3 0f 59 c0	 mulss	 xmm0, xmm0
  000ba	f3 0f 59 d2	 mulss	 xmm2, xmm2
  000be	f3 0f 58 d8	 addss	 xmm3, xmm0
  000c2	f3 0f 58 da	 addss	 xmm3, xmm2
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 86   : 		return D3DXVec3LengthSq(&(x-p1));

  000c6	f3 0f 11 5d 0c	 movss	 DWORD PTR tv858[ebp], xmm3
  000cb	d9 45 0c	 fld	 DWORD PTR tv858[ebp]

; 96   : 	}
; 97   : }

  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
$LN4@square_dis:

; 87   : 	}
; 88   : 	else if (d>=l)

  000d2	0f 2f 4d fc	 comiss	 xmm1, DWORD PTR _l$1$[ebp]
  000d6	72 2e		 jb	 SHORT $LN2@square_dis
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000d8	f3 0f 5c 61 04	 subss	 xmm4, DWORD PTR [ecx+4]
  000dd	f3 0f 5c 31	 subss	 xmm6, DWORD PTR [ecx]
  000e1	f3 0f 5c 79 08	 subss	 xmm7, DWORD PTR [ecx+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000e6	f3 0f 59 e4	 mulss	 xmm4, xmm4
  000ea	f3 0f 59 f6	 mulss	 xmm6, xmm6
  000ee	f3 0f 59 ff	 mulss	 xmm7, xmm7
  000f2	f3 0f 58 e6	 addss	 xmm4, xmm6
  000f6	f3 0f 58 e7	 addss	 xmm4, xmm7
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 90   : 		return D3DXVec3LengthSq(&(x-p2));

  000fa	f3 0f 11 65 0c	 movss	 DWORD PTR tv848[ebp], xmm4
  000ff	d9 45 0c	 fld	 DWORD PTR tv848[ebp]

; 96   : 	}
; 97   : }

  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
$LN2@square_dis:
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00106	f3 0f 10 65 0c	 movss	 xmm4, DWORD PTR $T2[ebp]
  0010b	0f 28 c2	 movaps	 xmm0, xmm2

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0010e	f3 0f 59 55 08	 mulss	 xmm2, DWORD PTR $T1[ebp]
  00113	0f 28 cb	 movaps	 xmm1, xmm3

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00116	f3 0f 59 5d 08	 mulss	 xmm3, DWORD PTR $T1[ebp]
  0011b	f3 0f 59 cc	 mulss	 xmm1, xmm4
  0011f	f3 0f 59 65 10	 mulss	 xmm4, DWORD PTR $T3[ebp]
  00124	f3 0f 59 c5	 mulss	 xmm0, xmm5
  00128	f3 0f 59 6d 10	 mulss	 xmm5, DWORD PTR $T3[ebp]
  0012d	f3 0f 5c d4	 subss	 xmm2, xmm4
  00131	f3 0f 5c c8	 subss	 xmm1, xmm0
  00135	f3 0f 5c eb	 subss	 xmm5, xmm3

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00139	f3 0f 59 d2	 mulss	 xmm2, xmm2
  0013d	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00141	f3 0f 59 ed	 mulss	 xmm5, xmm5
  00145	f3 0f 58 d1	 addss	 xmm2, xmm1
  00149	f3 0f 58 d5	 addss	 xmm2, xmm5
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 95   : 		return D3DXVec3LengthSq(D3DXVec3Cross(&c,&(x-p1),&(p2-p1)))/l;

  0014d	f3 0f 5e 55 fc	 divss	 xmm2, DWORD PTR _l$1$[ebp]
  00152	f3 0f 11 55 0c	 movss	 DWORD PTR tv830[ebp], xmm2
  00157	d9 45 0c	 fld	 DWORD PTR tv830[ebp]

; 96   : 	}
; 97   : }

  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c3		 ret	 0
?square_distance_between_linesegment_and_point@@YAMABUD3DXVECTOR3@@00@Z ENDP ; square_distance_between_linesegment_and_point
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
;	COMDAT ?GetVector3Distance@@YAMABUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
tv168 = 8						; size = 4
_c_rv3Source$ = 8					; size = 4
_c_rv3Target$ = 12					; size = 4
?GetVector3Distance@@YAMABUD3DXVECTOR3@@0@Z PROC	; GetVector3Distance, COMDAT

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _c_rv3Source$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR _c_rv3Target$[ebp]
  00009	f3 0f 10 49 04	 movss	 xmm1, DWORD PTR [ecx+4]
  0000e	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00012	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  00016	f3 0f 5c 48 04	 subss	 xmm1, DWORD PTR [eax+4]
  0001b	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0001f	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00023	f3 0f 58 c1	 addss	 xmm0, xmm1
  00027	f3 0f 11 45 08	 movss	 DWORD PTR tv168[ebp], xmm0
  0002c	d9 45 08	 fld	 DWORD PTR tv168[ebp]

; 45   : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?GetVector3Distance@@YAMABUD3DXVECTOR3@@0@Z ENDP	; GetVector3Distance
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0CCylinderCollisionInstance@@QAE@XZ
_TEXT	SEGMENT
??0CCylinderCollisionInstance@@QAE@XZ PROC		; CCylinderCollisionInstance::CCylinderCollisionInstance, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CCylinderCollisionInstance@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0CCylinderCollisionInstance@@QAE@XZ ENDP		; CCylinderCollisionInstance::CCylinderCollisionInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?CollideCylinderVSDynamicSphere@CCylinderCollisionInstance@@IBE_NABUSCylinderData@@ABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_ob$ = -40						; size = 12
$T1 = -28						; size = 12
_oa$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_c_rattribute$ = 8					; size = 4
_s$ = 12						; size = 4
?CollideCylinderVSDynamicSphere@CCylinderCollisionInstance@@IBE_NABUSCylinderData@@ABUCDynamicSphereInstance@@@Z PROC ; CCylinderCollisionInstance::CollideCylinderVSDynamicSphere, COMDAT
; _this$ = ecx

; 452  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _c_rattribute$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 0c	 mov	 edi, DWORD PTR _s$[ebp]

; 453  : 	if (s.v3Position.z + s.fRadius < c_rattribute.v3Position.z)

  00018	f3 0f 10 66 08	 movss	 xmm4, DWORD PTR [esi+8]
  0001d	f3 0f 10 4f 08	 movss	 xmm1, DWORD PTR [edi+8]
  00022	f3 0f 10 5f 18	 movss	 xmm3, DWORD PTR [edi+24]
  00027	0f 28 c1	 movaps	 xmm0, xmm1
  0002a	f3 0f 58 c3	 addss	 xmm0, xmm3
  0002e	0f 2f e0	 comiss	 xmm4, xmm0
  00031	76 14		 jbe	 SHORT $LN2@CollideCyl
$LN17@CollideCyl:
  00033	5f		 pop	 edi

; 454  : 		return false;

  00034	32 c0		 xor	 al, al
  00036	5e		 pop	 esi

; 468  : }

  00037	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003a	33 cd		 xor	 ecx, ebp
  0003c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 08 00	 ret	 8
$LN2@CollideCyl:

; 455  : 
; 456  : 	if (s.v3Position.z - s.fRadius > c_rattribute.v3Position.z + c_rattribute.fHeight)

  00047	f3 0f 10 56 10	 movss	 xmm2, DWORD PTR [esi+16]
  0004c	f3 0f 5c cb	 subss	 xmm1, xmm3
  00050	f3 0f 58 d4	 addss	 xmm2, xmm4
  00054	0f 2f ca	 comiss	 xmm1, xmm2
  00057	77 da		 ja	 SHORT $LN17@CollideCyl
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 180  :     x = fx;

  00059	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 466  : 	IntersectLineSegments(c_rattribute.v3Position, D3DXVECTOR3(c_rattribute.v3Position.x,c_rattribute.v3Position.y,c_rattribute.v3Position.z+c_rattribute.fHeight), s.v3LastPosition, s.v3Position, oa, ob);

  0005d	8d 45 d8	 lea	 eax, DWORD PTR _ob$[ebp]
  00060	50		 push	 eax
  00061	8d 45 f0	 lea	 eax, DWORD PTR _oa$[ebp]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 180  :     x = fx;

  00064	f3 0f 11 45 e4	 movss	 DWORD PTR $T1[ebp], xmm0

; 181  :     y = fy;

  00069	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 466  : 	IntersectLineSegments(c_rattribute.v3Position, D3DXVECTOR3(c_rattribute.v3Position.x,c_rattribute.v3Position.y,c_rattribute.v3Position.z+c_rattribute.fHeight), s.v3LastPosition, s.v3Position, oa, ob);

  0006e	50		 push	 eax
  0006f	57		 push	 edi
  00070	8d 47 0c	 lea	 eax, DWORD PTR [edi+12]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 181  :     y = fy;

  00073	f3 0f 11 45 e8	 movss	 DWORD PTR $T1[ebp+4], xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 466  : 	IntersectLineSegments(c_rattribute.v3Position, D3DXVECTOR3(c_rattribute.v3Position.x,c_rattribute.v3Position.y,c_rattribute.v3Position.z+c_rattribute.fHeight), s.v3LastPosition, s.v3Position, oa, ob);

  00078	50		 push	 eax
  00079	8d 45 e4	 lea	 eax, DWORD PTR $T1[ebp]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 182  :     z = fz;

  0007c	f3 0f 11 55 ec	 movss	 DWORD PTR $T1[ebp+8], xmm2
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 466  : 	IntersectLineSegments(c_rattribute.v3Position, D3DXVECTOR3(c_rattribute.v3Position.x,c_rattribute.v3Position.y,c_rattribute.v3Position.z+c_rattribute.fHeight), s.v3LastPosition, s.v3Position, oa, ob);

  00081	50		 push	 eax
  00082	56		 push	 esi
  00083	e8 00 00 00 00	 call	 ?IntersectLineSegments@@YAXABUD3DXVECTOR3@@000AAU1@1@Z ; IntersectLineSegments
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00088	f3 0f 10 55 f0	 movss	 xmm2, DWORD PTR _oa$[ebp]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 466  : 	IntersectLineSegments(c_rattribute.v3Position, D3DXVECTOR3(c_rattribute.v3Position.x,c_rattribute.v3Position.y,c_rattribute.v3Position.z+c_rattribute.fHeight), s.v3LastPosition, s.v3Position, oa, ob);

  0008d	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00090	f3 0f 10 5d f4	 movss	 xmm3, DWORD PTR _oa$[ebp+4]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 467  : 	return (D3DXVec3LengthSq(&(oa-ob))<=(c_rattribute.fRadius+s.fRadius)*(c_rattribute.fRadius+s.fRadius));

  00095	33 c0		 xor	 eax, eax
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00097	f3 0f 5c 5d dc	 subss	 xmm3, DWORD PTR _ob$[ebp+4]
  0009c	f3 0f 5c 55 d8	 subss	 xmm2, DWORD PTR _ob$[ebp]
  000a1	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _oa$[ebp+8]
  000a6	f3 0f 5c 45 e0	 subss	 xmm0, DWORD PTR _ob$[ebp+8]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 467  : 	return (D3DXVec3LengthSq(&(oa-ob))<=(c_rattribute.fRadius+s.fRadius)*(c_rattribute.fRadius+s.fRadius));

  000ab	f3 0f 10 4e 0c	 movss	 xmm1, DWORD PTR [esi+12]
  000b0	f3 0f 58 4f 18	 addss	 xmm1, DWORD PTR [edi+24]

; 468  : }

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000b8	f3 0f 59 db	 mulss	 xmm3, xmm3
  000bc	5f		 pop	 edi
  000bd	f3 0f 59 d2	 mulss	 xmm2, xmm2
  000c1	5e		 pop	 esi
  000c2	f3 0f 59 c0	 mulss	 xmm0, xmm0
  000c6	f3 0f 58 da	 addss	 xmm3, xmm2
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 467  : 	return (D3DXVec3LengthSq(&(oa-ob))<=(c_rattribute.fRadius+s.fRadius)*(c_rattribute.fRadius+s.fRadius));

  000ca	f3 0f 59 c9	 mulss	 xmm1, xmm1
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000ce	f3 0f 58 d8	 addss	 xmm3, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 467  : 	return (D3DXVec3LengthSq(&(oa-ob))<=(c_rattribute.fRadius+s.fRadius)*(c_rattribute.fRadius+s.fRadius));

  000d2	0f 2f cb	 comiss	 xmm1, xmm3
  000d5	0f 93 c0	 setae	 al

; 468  : }

  000d8	33 cd		 xor	 ecx, ebp
  000da	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000df	8b e5		 mov	 esp, ebp
  000e1	5d		 pop	 ebp
  000e2	c2 08 00	 ret	 8
?CollideCylinderVSDynamicSphere@CCylinderCollisionInstance@@IBE_NABUSCylinderData@@ABUCDynamicSphereInstance@@@Z ENDP ; CCylinderCollisionInstance::CollideCylinderVSDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?OnGetCollisionMovementAdjust@CCylinderCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_v$1$ = -28						; size = 4
_v$2$ = -24						; size = 4
_v$3$ = -20						; size = 4
_sum$1$ = -16						; size = 4
_v3Position$ = -12					; size = 12
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
?OnGetCollisionMovementAdjust@CCylinderCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z PROC ; CCylinderCollisionInstance::OnGetCollisionMovementAdjust, COMDAT
; _this$ = ecx

; 515  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 20	 sub	 esp, 32			; 00000020H

; 516  : 	D3DXVECTOR3 v3Position = m_attribute.v3Position;

  00009	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0000c	f3 0f 7e 41 04	 movq	 xmm0, QWORD PTR [ecx+4]
  00011	89 44 24 1c	 mov	 DWORD PTR _v3Position$[esp+40], eax

; 517  : 	v3Position.z = s.v3Position.z;

  00015	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00018	66 0f d6 44 24
	14		 movq	 QWORD PTR _v3Position$[esp+32], xmm0
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0001e	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  00022	f3 0f 10 78 04	 movss	 xmm7, DWORD PTR [eax+4]
  00027	0f 28 ea	 movaps	 xmm5, xmm2
  0002a	f3 0f 5c 6c 24
	14		 subss	 xmm5, DWORD PTR _v3Position$[esp+32]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 517  : 	v3Position.z = s.v3Position.z;

  00030	f3 0f 10 60 08	 movss	 xmm4, DWORD PTR [eax+8]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00035	0f 28 f7	 movaps	 xmm6, xmm7
  00038	f3 0f 5c 74 24
	18		 subss	 xmm6, DWORD PTR _v3Position$[esp+36]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 518  : 	if (D3DXVec3LengthSq(&(s.v3Position-v3Position))>=(s.fRadius+m_attribute.fRadius)*(m_attribute.fRadius+s.fRadius))

  0003e	f3 0f 10 58 18	 movss	 xmm3, DWORD PTR [eax+24]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00043	f3 0f 5c e4	 subss	 xmm4, xmm4
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 518  : 	if (D3DXVec3LengthSq(&(s.v3Position-v3Position))>=(s.fRadius+m_attribute.fRadius)*(m_attribute.fRadius+s.fRadius))

  00047	f3 0f 58 59 10	 addss	 xmm3, DWORD PTR [ecx+16]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0004c	0f 28 c5	 movaps	 xmm0, xmm5
  0004f	f3 0f 59 c5	 mulss	 xmm0, xmm5
  00053	0f 28 ce	 movaps	 xmm1, xmm6
  00056	f3 0f 59 ce	 mulss	 xmm1, xmm6
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 518  : 	if (D3DXVec3LengthSq(&(s.v3Position-v3Position))>=(s.fRadius+m_attribute.fRadius)*(m_attribute.fRadius+s.fRadius))

  0005a	f3 0f 59 db	 mulss	 xmm3, xmm3
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0005e	f3 0f 58 c8	 addss	 xmm1, xmm0
  00062	0f 28 c4	 movaps	 xmm0, xmm4
  00065	f3 0f 59 c4	 mulss	 xmm0, xmm4
  00069	f3 0f 58 c8	 addss	 xmm1, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 518  : 	if (D3DXVec3LengthSq(&(s.v3Position-v3Position))>=(s.fRadius+m_attribute.fRadius)*(m_attribute.fRadius+s.fRadius))

  0006d	0f 2f cb	 comiss	 xmm1, xmm3
  00070	72 1d		 jb	 SHORT $LN4@OnGetColli
$LN62@OnGetColli:
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 180  :     x = fx;

  00072	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00075	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 181  :     y = fy;

  0007b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 182  :     z = fz;

  00082	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 554  : }

  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c2 08 00	 ret	 8
$LN4@OnGetColli:
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0008f	f3 0f 5c 78 10	 subss	 xmm7, DWORD PTR [eax+16]
  00094	f3 0f 5c 50 0c	 subss	 xmm2, DWORD PTR [eax+12]
  00099	0f 57 c9	 xorps	 xmm1, xmm1

; 1265 : }
; 1266 : 
; 1267 : D3DXINLINE D3DXVECTOR3* D3DXVec3Cross
; 1268 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1269 : {
; 1270 :     D3DXVECTOR3 v;
; 1271 : 
; 1272 : #ifdef D3DX_DEBUG
; 1273 :     if(!pOut || !pV1 || !pV2)
; 1274 :         return NULL;
; 1275 : #endif
; 1276 : 
; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  0009c	0f 28 c7	 movaps	 xmm0, xmm7

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  0009f	f3 0f 59 f9	 mulss	 xmm7, xmm1
  000a3	f3 0f 5c c1	 subss	 xmm0, xmm1
  000a7	f3 0f 11 44 24
	04		 movss	 DWORD PTR _v$1$[esp+32], xmm0
  000ad	0f 28 c1	 movaps	 xmm0, xmm1
  000b0	f3 0f 5c c2	 subss	 xmm0, xmm2
  000b4	f3 0f 59 d1	 mulss	 xmm2, xmm1
  000b8	f3 0f 5c d7	 subss	 xmm2, xmm7

; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000bc	0f 28 fe	 movaps	 xmm7, xmm6
  000bf	f3 0f 59 f8	 mulss	 xmm7, xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  000c3	f3 0f 11 44 24
	08		 movss	 DWORD PTR _v$2$[esp+32], xmm0

; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000c9	0f 28 c5	 movaps	 xmm0, xmm5
  000cc	f3 0f 59 44 24
	04		 mulss	 xmm0, DWORD PTR _v$1$[esp+32]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000d2	f3 0f 59 ed	 mulss	 xmm5, xmm5

; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000d6	f3 0f 58 f8	 addss	 xmm7, xmm0

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000da	f3 0f 59 f6	 mulss	 xmm6, xmm6

; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000de	0f 28 c4	 movaps	 xmm0, xmm4

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  000e1	f3 0f 11 54 24
	0c		 movss	 DWORD PTR _v$3$[esp+32], xmm2

; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000e7	f3 0f 59 c2	 mulss	 xmm0, xmm2

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000eb	f3 0f 58 ee	 addss	 xmm5, xmm6
  000ef	f3 0f 59 e4	 mulss	 xmm4, xmm4

; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000f3	f3 0f 58 f8	 addss	 xmm7, xmm0

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000f7	f3 0f 58 ec	 addss	 xmm5, xmm4
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 525  : 	float sum = - D3DXVec3Dot(&c,&(s.v3Position-v3Position));

  000fb	0f 57 3d 00 00
	00 00		 xorps	 xmm7, DWORD PTR __xmm@80000000800000008000000080000000

; 526  : 	float mul = (s.fRadius+m_attribute.fRadius)*(s.fRadius+m_attribute.fRadius)-D3DXVec3LengthSq(&(s.v3Position-v3Position));
; 527  : 
; 528  : 	if (sum*sum-4*mul<=0)

  00102	0f 28 c7	 movaps	 xmm0, xmm7
  00105	f3 0f 11 7c 24
	10		 movss	 DWORD PTR _sum$1$[esp+32], xmm7
  0010b	f3 0f 59 c7	 mulss	 xmm0, xmm7
  0010f	f3 0f 5c dd	 subss	 xmm3, xmm5
  00113	f3 0f 59 1d 00
	00 00 00	 mulss	 xmm3, DWORD PTR __real@40800000
  0011b	f3 0f 5c c3	 subss	 xmm0, xmm3
  0011f	0f 2f c8	 comiss	 xmm1, xmm0
  00122	0f 83 4a ff ff
	ff		 jae	 $LN62@OnGetColli
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  00128	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  0012c	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 531  : 	float t1=-sum-sq, t2=-sum+sq;

  00131	f3 0f 10 5c 24
	10		 movss	 xmm3, DWORD PTR _sum$1$[esp+32]
  00137	0f 57 e4	 xorps	 xmm4, xmm4
  0013a	0f 57 1d 00 00
	00 00		 xorps	 xmm3, DWORD PTR __xmm@80000000800000008000000080000000

; 532  : 	t1*=0.5f;

  00141	f3 0f 10 2d 00
	00 00 00	 movss	 xmm5, DWORD PTR __real@3f000000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  00149	f2 0f 5a e0	 cvtsd2ss xmm4, xmm0
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 180  :     x = fx;

  0014d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00150	0f 57 c0	 xorps	 xmm0, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 531  : 	float t1=-sum-sq, t2=-sum+sq;

  00153	f3 0f 5c dc	 subss	 xmm3, xmm4
  00157	f3 0f 5c 64 24
	10		 subss	 xmm4, DWORD PTR _sum$1$[esp+32]

; 532  : 	t1*=0.5f;

  0015d	f3 0f 59 dd	 mulss	 xmm3, xmm5

; 533  : 	t2*=0.5f;

  00161	f3 0f 59 e5	 mulss	 xmm4, xmm5
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

  00165	f3 0f 5a c3	 cvtss2sd xmm0, xmm3
  00169	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00171	66 0f 5a d0	 cvtpd2ps xmm2, xmm0
  00175	0f 5a c4	 cvtps2pd xmm0, xmm4
  00178	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00180	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 536  : 	if (fabs(t1)<=fabs(t2))

  00184	0f 2f c2	 comiss	 xmm0, xmm2
  00187	72 30		 jb	 SHORT $LN2@OnGetColli

; 537  : 	{
; 538  : 		return (gc_fReduceMove*t1)*c;

  00189	f3 0f 59 dd	 mulss	 xmm3, xmm5
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0018d	0f 28 c3	 movaps	 xmm0, xmm3
  00190	f3 0f 59 44 24
	04		 mulss	 xmm0, DWORD PTR _v$1$[esp+32]

; 180  :     x = fx;

  00196	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0019a	0f 28 c3	 movaps	 xmm0, xmm3
  0019d	f3 0f 59 5c 24
	0c		 mulss	 xmm3, DWORD PTR _v$3$[esp+32]
  001a3	f3 0f 59 44 24
	08		 mulss	 xmm0, DWORD PTR _v$2$[esp+32]

; 182  :     z = fz;

  001a9	f3 0f 11 58 08	 movss	 DWORD PTR [eax+8], xmm3

; 181  :     y = fy;

  001ae	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 554  : }

  001b3	8b e5		 mov	 esp, ebp
  001b5	5d		 pop	 ebp
  001b6	c2 08 00	 ret	 8
$LN2@OnGetColli:

; 539  : 	}
; 540  : 	else
; 541  : 		return (gc_fReduceMove*t2)*c;

  001b9	f3 0f 59 e5	 mulss	 xmm4, xmm5
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001bd	0f 28 c4	 movaps	 xmm0, xmm4
  001c0	f3 0f 59 44 24
	04		 mulss	 xmm0, DWORD PTR _v$1$[esp+32]

; 180  :     x = fx;

  001c6	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001ca	0f 28 c4	 movaps	 xmm0, xmm4
  001cd	f3 0f 59 64 24
	0c		 mulss	 xmm4, DWORD PTR _v$3$[esp+32]
  001d3	f3 0f 59 44 24
	08		 mulss	 xmm0, DWORD PTR _v$2$[esp+32]

; 182  :     z = fz;

  001d9	f3 0f 11 60 08	 movss	 DWORD PTR [eax+8], xmm4
  001de	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 554  : }

  001e3	8b e5		 mov	 esp, ebp
  001e5	5d		 pop	 ebp
  001e6	c2 08 00	 ret	 8
?OnGetCollisionMovementAdjust@CCylinderCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ENDP ; CCylinderCollisionInstance::OnGetCollisionMovementAdjust
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?OnCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
?OnCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CCylinderCollisionInstance::OnCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 508  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 509  : 	//Tracef("OnCollisionDynamicSphere\n");
; 510  : 	
; 511  : 	return (CollideCylinderVSDynamicSphere(m_attribute, s));

  00003	ff 75 08	 push	 DWORD PTR _s$[ebp]
  00006	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?CollideCylinderVSDynamicSphere@CCylinderCollisionInstance@@IBE_NABUSCylinderData@@ABUCDynamicSphereInstance@@@Z ; CCylinderCollisionInstance::CollideCylinderVSDynamicSphere

; 512  : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?OnCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CCylinderCollisionInstance::OnCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?OnMovementCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_v3Step$1$ = -40					; size = 4
_v3Distance$1$ = -40					; size = 4
_v3Step$2$ = -36					; size = 4
_v3Step$3$ = -32					; size = 4
_iStep$1$ = -28						; size = 4
_cylinder$1 = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
?OnMovementCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CCylinderCollisionInstance::OnMovementCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 471  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 28	 mov	 DWORD PTR __$ArrayPad$[esp+44], eax
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b d9		 mov	 ebx, ecx
  00018	57		 push	 edi
  00019	8b 7d 08	 mov	 edi, DWORD PTR _s$[ebp]

; 472  : 	if (CollideCylinderVSDynamicSphere(m_attribute, s))

  0001c	57		 push	 edi
  0001d	8d 73 04	 lea	 esi, DWORD PTR [ebx+4]
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ?CollideCylinderVSDynamicSphere@CCylinderCollisionInstance@@IBE_NABUSCylinderData@@ABUCDynamicSphereInstance@@@Z ; CCylinderCollisionInstance::CollideCylinderVSDynamicSphere
  00026	84 c0		 test	 al, al
  00028	74 58		 je	 SHORT $LN7@OnMovement
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  0002a	f3 0f 10 57 04	 movss	 xmm2, DWORD PTR [edi+4]
  0002f	f3 0f 10 1f	 movss	 xmm3, DWORD PTR [edi]
  00033	f3 0f 10 4f 10	 movss	 xmm1, DWORD PTR [edi+16]
  00038	f3 0f 10 47 0c	 movss	 xmm0, DWORD PTR [edi+12]
  0003d	f3 0f 5c 1e	 subss	 xmm3, DWORD PTR [esi]
  00041	f3 0f 5c 06	 subss	 xmm0, DWORD PTR [esi]
  00045	f3 0f 5c 56 04	 subss	 xmm2, DWORD PTR [esi+4]
  0004a	f3 0f 5c 4e 04	 subss	 xmm1, DWORD PTR [esi+4]
  0004f	f3 0f 59 db	 mulss	 xmm3, xmm3
  00053	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00057	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0005b	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0005f	f3 0f 58 da	 addss	 xmm3, xmm2
  00063	f3 0f 58 c1	 addss	 xmm0, xmm1
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 476  : 			GetVector3Distance(s.v3LastPosition, m_attribute.v3Position))

  00067	0f 2f c3	 comiss	 xmm0, xmm3
  0006a	76 16		 jbe	 SHORT $LN7@OnMovement
$LN30@OnMovement:

; 477  : 			return true;

  0006c	b0 01		 mov	 al, 1

; 499  : 				return true;
; 500  : 				
; 501  : 		}
; 502  : 	}
; 503  : 	
; 504  : 	return false;
; 505  : }

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b 4c 24 28	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+44]
  00075	33 cc		 xor	 ecx, esp
  00077	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
$LN7@OnMovement:
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00082	f3 0f 10 47 04	 movss	 xmm0, DWORD PTR [edi+4]
  00087	f3 0f 5c 47 10	 subss	 xmm0, DWORD PTR [edi+16]
  0008c	f3 0f 10 1f	 movss	 xmm3, DWORD PTR [edi]
  00090	f3 0f 5c 5f 0c	 subss	 xmm3, DWORD PTR [edi+12]
  00095	f3 0f 10 57 08	 movss	 xmm2, DWORD PTR [edi+8]
  0009a	f3 0f 5c 57 14	 subss	 xmm2, DWORD PTR [edi+20]

; 277  : }
; 278  : 
; 279  : 
; 280  : D3DXINLINE D3DXVECTOR3
; 281  : operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
; 282  : {
; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  0009f	0f 28 c8	 movaps	 xmm1, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000a2	f3 0f 11 44 24
	14		 movss	 DWORD PTR _v3Step$2$[esp+56], xmm0

; 277  : }
; 278  : 
; 279  : 
; 280  : D3DXINLINE D3DXVECTOR3
; 281  : operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
; 282  : {
; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  000a8	f3 0f 59 c8	 mulss	 xmm1, xmm0
  000ac	0f 28 c3	 movaps	 xmm0, xmm3

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000af	f3 0f 11 5c 24
	10		 movss	 DWORD PTR _v3Distance$1$[esp+56], xmm3

; 277  : }
; 278  : 
; 279  : 
; 280  : D3DXINLINE D3DXVECTOR3
; 281  : operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
; 282  : {
; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  000b5	f3 0f 59 c3	 mulss	 xmm0, xmm3

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000b9	f3 0f 11 54 24
	18		 movss	 DWORD PTR _v3Step$3$[esp+56], xmm2

; 277  : }
; 278  : 
; 279  : 
; 280  : D3DXINLINE D3DXVECTOR3
; 281  : operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
; 282  : {
; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  000bf	f3 0f 58 c8	 addss	 xmm1, xmm0
  000c3	0f 28 c2	 movaps	 xmm0, xmm2
  000c6	f3 0f 59 c2	 mulss	 xmm0, xmm2
  000ca	f3 0f 58 c8	 addss	 xmm1, xmm0
  000ce	0f 57 c0	 xorps	 xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  000d1	f3 0f 5a c1	 cvtss2sd xmm0, xmm1
  000d5	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 484  : 	if (s.fRadius<=0.0001f)

  000da	f3 0f 10 5f 18	 movss	 xmm3, DWORD PTR [edi+24]
  000df	0f 57 c9	 xorps	 xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  000e2	f2 0f 5a c8	 cvtsd2ss xmm1, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 484  : 	if (s.fRadius<=0.0001f)

  000e6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@38d1b717
  000ee	0f 2f c3	 comiss	 xmm0, xmm3
  000f1	0f 83 f3 00 00
	00		 jae	 $LN2@OnMovement

; 485  : 		return false;
; 486  : 	if (fDistance >= s.fRadius*2.0f)

  000f7	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@40000000
  000ff	0f 28 c3	 movaps	 xmm0, xmm3
  00102	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00106	0f 2f c8	 comiss	 xmm1, xmm0
  00109	0f 82 db 00 00
	00		 jb	 $LN2@OnMovement

; 492  : 		int iStep = fDistance / s.fRadius*2.0f;

  0010f	f3 0f 5e cb	 divss	 xmm1, xmm3
  00113	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00116	89 44 24 30	 mov	 DWORD PTR _cylinder$1[esp+72], eax
  0011a	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0011d	f3 0f 6f 06	 movdqu	 xmm0, XMMWORD PTR [esi]

; 495  : 		for (int i = 0; i < iStep; ++i)

  00121	33 f6		 xor	 esi, esi
  00123	f3 0f 59 ca	 mulss	 xmm1, xmm2
  00127	f3 0f 7f 44 24
	20		 movdqu	 XMMWORD PTR _cylinder$1[esp+56], xmm0
  0012d	89 44 24 28	 mov	 DWORD PTR _cylinder$1[esp+64], eax
  00131	f3 0f 7e 47 0c	 movq	 xmm0, QWORD PTR [edi+12]
  00136	f3 0f 2c c1	 cvttss2si eax, xmm1
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 275  :     FLOAT fInv = 1.0f / f;

  0013a	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 490  : 		cylinder.v3Position = s.v3LastPosition;

  00142	66 0f d6 44 24
	20		 movq	 QWORD PTR _cylinder$1[esp+56], xmm0
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);

  00148	f3 0f 10 54 24
	14		 movss	 xmm2, DWORD PTR _v3Step$2$[esp+56]
  0014e	f3 0f 10 5c 24
	18		 movss	 xmm3, DWORD PTR _v3Step$3$[esp+56]
  00154	66 0f 6e c0	 movd	 xmm0, eax
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 492  : 		int iStep = fDistance / s.fRadius*2.0f;

  00158	89 44 24 1c	 mov	 DWORD PTR _iStep$1$[esp+56], eax

; 493  : 		D3DXVECTOR3 v3Step = v3Distance / float(iStep);

  0015c	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 275  :     FLOAT fInv = 1.0f / f;

  0015f	f3 0f 5e c8	 divss	 xmm1, xmm0

; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);

  00163	f3 0f 59 d1	 mulss	 xmm2, xmm1
  00167	0f 28 c1	 movaps	 xmm0, xmm1
  0016a	f3 0f 59 44 24
	10		 mulss	 xmm0, DWORD PTR _v3Distance$1$[esp+56]
  00170	f3 0f 59 d9	 mulss	 xmm3, xmm1
  00174	f3 0f 11 54 24
	14		 movss	 DWORD PTR _v3Step$2$[esp+56], xmm2
  0017a	f3 0f 11 44 24
	10		 movss	 DWORD PTR _v3Step$1$[esp+56], xmm0
  00180	f3 0f 11 5c 24
	18		 movss	 DWORD PTR _v3Step$3$[esp+56], xmm3
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 495  : 		for (int i = 0; i < iStep; ++i)

  00186	85 c0		 test	 eax, eax
  00188	7e 60		 jle	 SHORT $LN2@OnMovement
  0018a	8d 9b 00 00 00
	00		 npad	 6
$LL4@OnMovement:
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 204  :     x += v.x;

  00190	f3 0f 58 44 24
	20		 addss	 xmm0, DWORD PTR _cylinder$1[esp+56]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 498  : 			if (CollideCylinderVSDynamicSphere(cylinder, s))

  00196	57		 push	 edi
  00197	8d 44 24 24	 lea	 eax, DWORD PTR _cylinder$1[esp+60]
  0019b	8b cb		 mov	 ecx, ebx
  0019d	50		 push	 eax
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 204  :     x += v.x;

  0019e	f3 0f 11 44 24
	28		 movss	 DWORD PTR _cylinder$1[esp+64], xmm0

; 205  :     y += v.y;

  001a4	f3 0f 10 44 24
	2c		 movss	 xmm0, DWORD PTR _cylinder$1[esp+68]
  001aa	f3 0f 58 c2	 addss	 xmm0, xmm2
  001ae	f3 0f 11 44 24
	2c		 movss	 DWORD PTR _cylinder$1[esp+68], xmm0

; 206  :     z += v.z;

  001b4	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR _cylinder$1[esp+72]
  001ba	f3 0f 58 c3	 addss	 xmm0, xmm3
  001be	f3 0f 11 44 24
	30		 movss	 DWORD PTR _cylinder$1[esp+72], xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 498  : 			if (CollideCylinderVSDynamicSphere(cylinder, s))

  001c4	e8 00 00 00 00	 call	 ?CollideCylinderVSDynamicSphere@CCylinderCollisionInstance@@IBE_NABUSCylinderData@@ABUCDynamicSphereInstance@@@Z ; CCylinderCollisionInstance::CollideCylinderVSDynamicSphere
  001c9	84 c0		 test	 al, al
  001cb	0f 85 9b fe ff
	ff		 jne	 $LN30@OnMovement

; 495  : 		for (int i = 0; i < iStep; ++i)

  001d1	f3 0f 10 54 24
	14		 movss	 xmm2, DWORD PTR _v3Step$2$[esp+56]
  001d7	46		 inc	 esi
  001d8	f3 0f 10 5c 24
	18		 movss	 xmm3, DWORD PTR _v3Step$3$[esp+56]
  001de	f3 0f 10 44 24
	10		 movss	 xmm0, DWORD PTR _v3Step$1$[esp+56]
  001e4	3b 74 24 1c	 cmp	 esi, DWORD PTR _iStep$1$[esp+56]
  001e8	7c a6		 jl	 SHORT $LL4@OnMovement
$LN2@OnMovement:

; 499  : 				return true;
; 500  : 				
; 501  : 		}
; 502  : 	}
; 503  : 	
; 504  : 	return false;
; 505  : }

  001ea	8b 4c 24 34	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+56]
  001ee	32 c0		 xor	 al, al
  001f0	5f		 pop	 edi
  001f1	5e		 pop	 esi
  001f2	5b		 pop	 ebx
  001f3	33 cc		 xor	 ecx, esp
  001f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001fa	8b e5		 mov	 esp, ebp
  001fc	5d		 pop	 ebp
  001fd	c2 04 00	 ret	 4
?OnMovementCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CCylinderCollisionInstance::OnMovementCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?OnDestroy@CCylinderCollisionInstance@@MAEXXZ
_TEXT	SEGMENT
_pkData$ = -4						; size = 4
?OnDestroy@CCylinderCollisionInstance@@MAEXXZ PROC	; CCylinderCollisionInstance::OnDestroy, COMDAT
; _this$ = ecx

; 564  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 81   : 			m_kVct_pkFree.push_back(pkData);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _pkData$[ebp]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 565  : 	gs_cci.Free(this);

  00007	89 4d fc	 mov	 DWORD PTR _pkData$[ebp], ecx
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 81   : 			m_kVct_pkFree.push_back(pkData);

  0000a	50		 push	 eax
  0000b	b9 10 00 00 00	 mov	 ecx, OFFSET ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+16
  00010	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXABQAVCCylinderCollisionInstance@@@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::push_back
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 566  : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?OnDestroy@CCylinderCollisionInstance@@MAEXXZ ENDP	; CCylinderCollisionInstance::OnDestroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_d3dFillMode$ = 8					; size = 4
?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z PROC ; CCylinderCollisionInstance::Render, COMDAT
; _this$ = ecx

; 557  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 558  : 	static CScreen s;

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S3@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA
  0002a	a8 01		 test	 al, 1
  0002c	75 2d		 jne	 SHORT $LN1@Render
  0002e	83 c8 01	 or	 eax, 1
  00031	a3 00 00 00 00	 mov	 DWORD PTR ?$S3@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA, eax
  00036	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00042	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  00047	68 00 00 00 00	 push	 OFFSET ??__Fs@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ; `CCylinderCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
  0004c	e8 00 00 00 00	 call	 _atexit
  00051	83 c4 04	 add	 esp, 4
  00054	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
$LN1@Render:

; 559  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, 0xffffffff);

  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00061	6a ff		 push	 -1
  00063	6a 3c		 push	 60			; 0000003cH
  00065	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 560  : 	s.RenderCylinder(NULL, m_attribute.v3Position.x, m_attribute.v3Position.y, m_attribute.v3Position.z+m_attribute.fHeight/2, m_attribute.fRadius, m_attribute.fHeight, d3dFillMode);

  0006a	ff 75 08	 push	 DWORD PTR _d3dFillMode$[ebp]
  0006d	f3 0f 10 4e 14	 movss	 xmm1, DWORD PTR [esi+20]
  00072	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00077	f3 0f 10 46 10	 movss	 xmm0, DWORD PTR [esi+16]
  0007c	83 ec 14	 sub	 esp, 20			; 00000014H
  0007f	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [esp+16], xmm1
  00085	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  0008d	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  00093	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
  00098	f3 0f 58 4e 0c	 addss	 xmm1, DWORD PTR [esi+12]
  0009d	f3 0f 11 4c 24
	08		 movss	 DWORD PTR [esp+8], xmm1
  000a3	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000a9	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]
  000ae	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b3	6a 00		 push	 0
  000b5	e8 00 00 00 00	 call	 ?RenderCylinder@CScreen@@QAEXPBUD3DXMATRIX@@MMMMMW4_D3DFILLMODE@@@Z ; CScreen::RenderCylinder

; 561  : }

  000ba	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000bd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c4	59		 pop	 ecx
  000c5	5e		 pop	 esi
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0:
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S3@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA
  00005	83 e0 fe	 and	 eax, -2			; fffffffeH
  00008	a3 00 00 00 00	 mov	 DWORD PTR ?$S3@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA, eax
  0000d	c3		 ret	 0
__ehhandler$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ENDP ; CCylinderCollisionInstance::Render
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?GetAttribute@CCylinderCollisionInstance@@QBEABUSCylinderData@@XZ
_TEXT	SEGMENT
?GetAttribute@CCylinderCollisionInstance@@QBEABUSCylinderData@@XZ PROC ; CCylinderCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 448  : 	return m_attribute;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 449  : }

  00003	c3		 ret	 0
?GetAttribute@CCylinderCollisionInstance@@QBEABUSCylinderData@@XZ ENDP ; CCylinderCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?GetAttribute@CCylinderCollisionInstance@@QAEAAUSCylinderData@@XZ
_TEXT	SEGMENT
?GetAttribute@CCylinderCollisionInstance@@QAEAAUSCylinderData@@XZ PROC ; CCylinderCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 443  : 	return m_attribute;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 444  : }

  00003	c3		 ret	 0
?GetAttribute@CCylinderCollisionInstance@@QAEAAUSCylinderData@@XZ ENDP ; CCylinderCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0COBBCollisionInstance@@QAE@XZ
_TEXT	SEGMENT
??0COBBCollisionInstance@@QAE@XZ PROC			; COBBCollisionInstance::COBBCollisionInstance, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7COBBCollisionInstance@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0COBBCollisionInstance@@QAE@XZ ENDP			; COBBCollisionInstance::COBBCollisionInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?OnGetCollisionMovementAdjust@COBBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
?OnGetCollisionMovementAdjust@COBBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z PROC ; COBBCollisionInstance::OnGetCollisionMovementAdjust, COMDAT
; _this$ = ecx

; 812  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 180  :     x = fx;

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 181  :     y = fy;

  0000c	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 182  :     z = fz;

  00013	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 816  : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?OnGetCollisionMovementAdjust@COBBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ENDP ; COBBCollisionInstance::OnGetCollisionMovementAdjust
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?OnCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
$T1 = -52						; size = 12
$T2 = -52						; size = 12
$T3 = -52						; size = 12
_v3Point$ = -40						; size = 12
_v3Center$1$ = -28					; size = 4
_v3Center$2$ = -24					; size = 4
_v3Center$3$ = -20					; size = 4
_v3Sphere$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
?OnCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; COBBCollisionInstance::OnCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 776  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00010	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 780  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00018	8d 45 f0	 lea	 eax, DWORD PTR _v3Sphere$[ebp]
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	8b f1		 mov	 esi, ecx
  0001f	57		 push	 edi
  00020	8b 7d 08	 mov	 edi, DWORD PTR _s$[ebp]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00023	f3 0f 10 4e 10	 movss	 xmm1, DWORD PTR [esi+16]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 780  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00028	8d 5e 1c	 lea	 ebx, DWORD PTR [esi+28]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0002b	f3 0f 58 4e 04	 addss	 xmm1, DWORD PTR [esi+4]
  00030	f3 0f 10 56 14	 movss	 xmm2, DWORD PTR [esi+20]
  00035	f3 0f 10 5e 18	 movss	 xmm3, DWORD PTR [esi+24]
  0003a	f3 0f 58 56 08	 addss	 xmm2, DWORD PTR [esi+8]
  0003f	f3 0f 58 5e 0c	 addss	 xmm3, DWORD PTR [esi+12]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00044	f3 0f 59 c8	 mulss	 xmm1, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 780  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00048	53		 push	 ebx
  00049	50		 push	 eax
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0004a	f3 0f 59 d0	 mulss	 xmm2, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 780  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  0004e	50		 push	 eax
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0004f	f3 0f 59 d8	 mulss	 xmm3, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00053	f3 0f 10 07	 movss	 xmm0, DWORD PTR [edi]
  00057	f3 0f 5c c1	 subss	 xmm0, xmm1

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0005b	f3 0f 11 4d e4	 movss	 DWORD PTR _v3Center$1$[ebp], xmm1
  00060	f3 0f 11 55 e8	 movss	 DWORD PTR _v3Center$2$[ebp], xmm2
  00065	f3 0f 11 5d ec	 movss	 DWORD PTR _v3Center$3$[ebp], xmm3

; 180  :     x = fx;

  0006a	f3 0f 11 45 f0	 movss	 DWORD PTR _v3Sphere$[ebp], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0006f	f3 0f 10 47 04	 movss	 xmm0, DWORD PTR [edi+4]
  00074	f3 0f 5c c2	 subss	 xmm0, xmm2

; 181  :     y = fy;

  00078	f3 0f 11 45 f4	 movss	 DWORD PTR _v3Sphere$[ebp+4], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0007d	f3 0f 10 47 08	 movss	 xmm0, DWORD PTR [edi+8]
  00082	f3 0f 5c c3	 subss	 xmm0, xmm3

; 182  :     z = fz;

  00086	f3 0f 11 45 f8	 movss	 DWORD PTR _v3Sphere$[ebp+8], xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 780  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  0008b	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00090	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _v3Sphere$[ebp+8]
  00095	f3 0f 10 75 f0	 movss	 xmm6, DWORD PTR _v3Sphere$[ebp]
  0009a	f3 0f 10 6d ec	 movss	 xmm5, DWORD PTR _v3Center$3$[ebp]
  0009f	f3 0f 10 5d e4	 movss	 xmm3, DWORD PTR _v3Center$1$[ebp]
  000a4	f3 0f 58 c5	 addss	 xmm0, xmm5
  000a8	f3 0f 10 7d f4	 movss	 xmm7, DWORD PTR _v3Sphere$[ebp+4]
  000ad	f3 0f 58 f3	 addss	 xmm6, xmm3
  000b1	f3 0f 10 65 e8	 movss	 xmm4, DWORD PTR _v3Center$2$[ebp]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 784  : 	if(v3Point.x < m_attribute.v3Min.x) { v3Point.x = m_attribute.v3Min.x; }

  000b6	f3 0f 10 56 04	 movss	 xmm2, DWORD PTR [esi+4]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  000bb	f3 0f 58 fc	 addss	 xmm7, xmm4

; 182  :     z = fz;

  000bf	f3 0f 11 45 d4	 movss	 DWORD PTR $T3[ebp+8], xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 784  : 	if(v3Point.x < m_attribute.v3Min.x) { v3Point.x = m_attribute.v3Min.x; }

  000c4	0f 2f d6	 comiss	 xmm2, xmm6
  000c7	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp+8]
  000ca	89 45 e0	 mov	 DWORD PTR _v3Point$[ebp+8], eax
  000cd	0f 28 c6	 movaps	 xmm0, xmm6
  000d0	0f 14 c7	 unpcklps xmm0, xmm7
  000d3	66 0f d6 45 d8	 movq	 QWORD PTR _v3Point$[ebp], xmm0
  000d8	77 05		 ja	 SHORT $LN14@OnCollisio
  000da	f3 0f 10 55 d8	 movss	 xmm2, DWORD PTR _v3Point$[ebp]
$LN14@OnCollisio:

; 785  : 	if(v3Point.x > m_attribute.v3Max.x) { v3Point.x = m_attribute.v3Max.x; }

  000df	f3 0f 10 46 10	 movss	 xmm0, DWORD PTR [esi+16]
  000e4	0f 2f d0	 comiss	 xmm2, xmm0
  000e7	76 03		 jbe	 SHORT $LN13@OnCollisio
  000e9	0f 28 d0	 movaps	 xmm2, xmm0
$LN13@OnCollisio:

; 786  : 	if(v3Point.y < m_attribute.v3Min.y) { v3Point.y = m_attribute.v3Min.y; }

  000ec	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
  000f1	f3 0f 10 4d dc	 movss	 xmm1, DWORD PTR _v3Point$[ebp+4]
  000f6	0f 2f c1	 comiss	 xmm0, xmm1
  000f9	76 03		 jbe	 SHORT $LN12@OnCollisio
  000fb	0f 28 c8	 movaps	 xmm1, xmm0
$LN12@OnCollisio:

; 787  : 	if(v3Point.y > m_attribute.v3Max.y) { v3Point.y = m_attribute.v3Max.y; }

  000fe	f3 0f 10 46 14	 movss	 xmm0, DWORD PTR [esi+20]
  00103	0f 2f c8	 comiss	 xmm1, xmm0
  00106	76 03		 jbe	 SHORT $LN11@OnCollisio
  00108	0f 28 c8	 movaps	 xmm1, xmm0
$LN11@OnCollisio:

; 791  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  0010b	f3 0f 10 47 18	 movss	 xmm0, DWORD PTR [edi+24]
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00110	f3 0f 5c cf	 subss	 xmm1, xmm7
  00114	f3 0f 5c d6	 subss	 xmm2, xmm6
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 791  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  00118	f3 0f 59 c0	 mulss	 xmm0, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  0011c	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00120	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00124	f3 0f 58 ca	 addss	 xmm1, xmm2
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 791  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  00128	0f 2f c1	 comiss	 xmm0, xmm1
  0012b	72 15		 jb	 SHORT $LN8@OnCollisio
  0012d	5f		 pop	 edi
  0012e	5e		 pop	 esi
  0012f	b0 01		 mov	 al, 1
  00131	5b		 pop	 ebx

; 809  : }

  00132	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00135	33 cd		 xor	 ecx, ebp
  00137	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c2 04 00	 ret	 4
$LN8@OnCollisio:
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00142	f3 0f 10 47 14	 movss	 xmm0, DWORD PTR [edi+20]
  00147	f3 0f 10 57 0c	 movss	 xmm2, DWORD PTR [edi+12]
  0014c	f3 0f 5c c5	 subss	 xmm0, xmm5
  00150	f3 0f 10 4f 10	 movss	 xmm1, DWORD PTR [edi+16]
  00155	f3 0f 5c d3	 subss	 xmm2, xmm3
  00159	f3 0f 5c cc	 subss	 xmm1, xmm4
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 794  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  0015d	53		 push	 ebx
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 182  :     z = fz;

  0015e	f3 0f 11 45 d4	 movss	 DWORD PTR $T2[ebp+8], xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 793  : 	v3Sphere = s.v3LastPosition - v3Center;

  00163	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp+8]
  00166	89 45 f8	 mov	 DWORD PTR _v3Sphere$[ebp+8], eax

; 794  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00169	8d 45 f0	 lea	 eax, DWORD PTR _v3Sphere$[ebp]
  0016c	50		 push	 eax
  0016d	0f 14 d1	 unpcklps xmm2, xmm1
  00170	50		 push	 eax
  00171	66 0f d6 55 f0	 movq	 QWORD PTR _v3Sphere$[ebp], xmm2
  00176	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0017b	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _v3Sphere$[ebp+8]
  00180	f3 0f 10 5d f0	 movss	 xmm3, DWORD PTR _v3Sphere$[ebp]
  00185	f3 0f 58 45 ec	 addss	 xmm0, DWORD PTR _v3Center$3$[ebp]
  0018a	f3 0f 58 5d e4	 addss	 xmm3, DWORD PTR _v3Center$1$[ebp]
  0018f	f3 0f 10 65 f4	 movss	 xmm4, DWORD PTR _v3Sphere$[ebp+4]
  00194	f3 0f 58 65 e8	 addss	 xmm4, DWORD PTR _v3Center$2$[ebp]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 798  : 	if(v3Point.x < m_attribute.v3Min.x) { v3Point.x = m_attribute.v3Min.x; }

  00199	f3 0f 10 56 04	 movss	 xmm2, DWORD PTR [esi+4]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 182  :     z = fz;

  0019e	f3 0f 11 45 d4	 movss	 DWORD PTR $T1[ebp+8], xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 798  : 	if(v3Point.x < m_attribute.v3Min.x) { v3Point.x = m_attribute.v3Min.x; }

  001a3	0f 2f d3	 comiss	 xmm2, xmm3
  001a6	8b 45 d4	 mov	 eax, DWORD PTR $T1[ebp+8]
  001a9	89 45 e0	 mov	 DWORD PTR _v3Point$[ebp+8], eax
  001ac	0f 28 c3	 movaps	 xmm0, xmm3
  001af	0f 14 c4	 unpcklps xmm0, xmm4
  001b2	66 0f d6 45 d8	 movq	 QWORD PTR _v3Point$[ebp], xmm0
  001b7	77 05		 ja	 SHORT $LN7@OnCollisio
  001b9	f3 0f 10 55 d8	 movss	 xmm2, DWORD PTR _v3Point$[ebp]
$LN7@OnCollisio:

; 799  : 	if(v3Point.x > m_attribute.v3Max.x) { v3Point.x = m_attribute.v3Max.x; }

  001be	f3 0f 10 46 10	 movss	 xmm0, DWORD PTR [esi+16]
  001c3	0f 2f d0	 comiss	 xmm2, xmm0
  001c6	76 03		 jbe	 SHORT $LN6@OnCollisio
  001c8	0f 28 d0	 movaps	 xmm2, xmm0
$LN6@OnCollisio:

; 800  : 	if(v3Point.y < m_attribute.v3Min.y) { v3Point.y = m_attribute.v3Min.y; }

  001cb	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
  001d0	f3 0f 10 4d dc	 movss	 xmm1, DWORD PTR _v3Point$[ebp+4]
  001d5	0f 2f c1	 comiss	 xmm0, xmm1
  001d8	76 03		 jbe	 SHORT $LN5@OnCollisio
  001da	0f 28 c8	 movaps	 xmm1, xmm0
$LN5@OnCollisio:

; 801  : 	if(v3Point.y > m_attribute.v3Max.y) { v3Point.y = m_attribute.v3Max.y; }

  001dd	f3 0f 10 46 14	 movss	 xmm0, DWORD PTR [esi+20]
  001e2	0f 2f c8	 comiss	 xmm1, xmm0
  001e5	76 03		 jbe	 SHORT $LN4@OnCollisio
  001e7	0f 28 c8	 movaps	 xmm1, xmm0
$LN4@OnCollisio:

; 805  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  001ea	f3 0f 10 47 18	 movss	 xmm0, DWORD PTR [edi+24]
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  001ef	f3 0f 5c d3	 subss	 xmm2, xmm3
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 809  : }

  001f3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  001f6	f3 0f 5c cc	 subss	 xmm1, xmm4
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 805  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  001fa	f3 0f 59 c0	 mulss	 xmm0, xmm0
  001fe	5f		 pop	 edi
  001ff	5e		 pop	 esi
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00200	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00204	5b		 pop	 ebx
  00205	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00209	f3 0f 58 d1	 addss	 xmm2, xmm1
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 805  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  0020d	0f 2f c2	 comiss	 xmm0, xmm2
  00210	0f 93 c0	 setae	 al

; 809  : }

  00213	33 cd		 xor	 ecx, ebp
  00215	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021a	8b e5		 mov	 esp, ebp
  0021c	5d		 pop	 ebp
  0021d	c2 04 00	 ret	 4
?OnCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; COBBCollisionInstance::OnCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?OnMovementCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
$T1 = -52						; size = 12
$T2 = -52						; size = 12
$T3 = -52						; size = 12
_v3Point$ = -40						; size = 12
_v3Center$1$ = -28					; size = 4
_v3Center$2$ = -24					; size = 4
_v3Center$3$ = -20					; size = 4
_v3Sphere$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
?OnMovementCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; COBBCollisionInstance::OnMovementCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 742  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00010	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 745  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00018	8d 45 f0	 lea	 eax, DWORD PTR _v3Sphere$[ebp]
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	8b f1		 mov	 esi, ecx
  0001f	57		 push	 edi
  00020	8b 7d 08	 mov	 edi, DWORD PTR _s$[ebp]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00023	f3 0f 10 4e 10	 movss	 xmm1, DWORD PTR [esi+16]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 745  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00028	8d 5e 1c	 lea	 ebx, DWORD PTR [esi+28]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0002b	f3 0f 58 4e 04	 addss	 xmm1, DWORD PTR [esi+4]
  00030	f3 0f 10 56 14	 movss	 xmm2, DWORD PTR [esi+20]
  00035	f3 0f 10 5e 18	 movss	 xmm3, DWORD PTR [esi+24]
  0003a	f3 0f 58 56 08	 addss	 xmm2, DWORD PTR [esi+8]
  0003f	f3 0f 58 5e 0c	 addss	 xmm3, DWORD PTR [esi+12]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00044	f3 0f 59 c8	 mulss	 xmm1, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 745  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00048	53		 push	 ebx
  00049	50		 push	 eax
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0004a	f3 0f 59 d0	 mulss	 xmm2, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 745  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  0004e	50		 push	 eax
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0004f	f3 0f 59 d8	 mulss	 xmm3, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00053	f3 0f 10 07	 movss	 xmm0, DWORD PTR [edi]
  00057	f3 0f 5c c1	 subss	 xmm0, xmm1

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0005b	f3 0f 11 4d e4	 movss	 DWORD PTR _v3Center$1$[ebp], xmm1
  00060	f3 0f 11 55 e8	 movss	 DWORD PTR _v3Center$2$[ebp], xmm2
  00065	f3 0f 11 5d ec	 movss	 DWORD PTR _v3Center$3$[ebp], xmm3

; 180  :     x = fx;

  0006a	f3 0f 11 45 f0	 movss	 DWORD PTR _v3Sphere$[ebp], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0006f	f3 0f 10 47 04	 movss	 xmm0, DWORD PTR [edi+4]
  00074	f3 0f 5c c2	 subss	 xmm0, xmm2

; 181  :     y = fy;

  00078	f3 0f 11 45 f4	 movss	 DWORD PTR _v3Sphere$[ebp+4], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0007d	f3 0f 10 47 08	 movss	 xmm0, DWORD PTR [edi+8]
  00082	f3 0f 5c c3	 subss	 xmm0, xmm3

; 182  :     z = fz;

  00086	f3 0f 11 45 f8	 movss	 DWORD PTR _v3Sphere$[ebp+8], xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 745  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  0008b	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00090	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _v3Sphere$[ebp+8]
  00095	f3 0f 10 75 f0	 movss	 xmm6, DWORD PTR _v3Sphere$[ebp]
  0009a	f3 0f 10 6d ec	 movss	 xmm5, DWORD PTR _v3Center$3$[ebp]
  0009f	f3 0f 10 5d e4	 movss	 xmm3, DWORD PTR _v3Center$1$[ebp]
  000a4	f3 0f 58 c5	 addss	 xmm0, xmm5
  000a8	f3 0f 10 7d f4	 movss	 xmm7, DWORD PTR _v3Sphere$[ebp+4]
  000ad	f3 0f 58 f3	 addss	 xmm6, xmm3
  000b1	f3 0f 10 65 e8	 movss	 xmm4, DWORD PTR _v3Center$2$[ebp]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 749  : 	if(v3Point.x < m_attribute.v3Min.x) { v3Point.x = m_attribute.v3Min.x; }

  000b6	f3 0f 10 56 04	 movss	 xmm2, DWORD PTR [esi+4]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  000bb	f3 0f 58 fc	 addss	 xmm7, xmm4

; 182  :     z = fz;

  000bf	f3 0f 11 45 d4	 movss	 DWORD PTR $T3[ebp+8], xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 749  : 	if(v3Point.x < m_attribute.v3Min.x) { v3Point.x = m_attribute.v3Min.x; }

  000c4	0f 2f d6	 comiss	 xmm2, xmm6
  000c7	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp+8]
  000ca	89 45 e0	 mov	 DWORD PTR _v3Point$[ebp+8], eax
  000cd	0f 28 c6	 movaps	 xmm0, xmm6
  000d0	0f 14 c7	 unpcklps xmm0, xmm7
  000d3	66 0f d6 45 d8	 movq	 QWORD PTR _v3Point$[ebp], xmm0
  000d8	77 05		 ja	 SHORT $LN14@OnMovement
  000da	f3 0f 10 55 d8	 movss	 xmm2, DWORD PTR _v3Point$[ebp]
$LN14@OnMovement:

; 750  : 	if(v3Point.x > m_attribute.v3Max.x) { v3Point.x = m_attribute.v3Max.x; }

  000df	f3 0f 10 46 10	 movss	 xmm0, DWORD PTR [esi+16]
  000e4	0f 2f d0	 comiss	 xmm2, xmm0
  000e7	76 03		 jbe	 SHORT $LN13@OnMovement
  000e9	0f 28 d0	 movaps	 xmm2, xmm0
$LN13@OnMovement:

; 751  : 	if(v3Point.y < m_attribute.v3Min.y) { v3Point.y = m_attribute.v3Min.y; }

  000ec	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
  000f1	f3 0f 10 4d dc	 movss	 xmm1, DWORD PTR _v3Point$[ebp+4]
  000f6	0f 2f c1	 comiss	 xmm0, xmm1
  000f9	76 03		 jbe	 SHORT $LN12@OnMovement
  000fb	0f 28 c8	 movaps	 xmm1, xmm0
$LN12@OnMovement:

; 752  : 	if(v3Point.y > m_attribute.v3Max.y) { v3Point.y = m_attribute.v3Max.y; }

  000fe	f3 0f 10 46 14	 movss	 xmm0, DWORD PTR [esi+20]
  00103	0f 2f c8	 comiss	 xmm1, xmm0
  00106	76 03		 jbe	 SHORT $LN11@OnMovement
  00108	0f 28 c8	 movaps	 xmm1, xmm0
$LN11@OnMovement:

; 756  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  0010b	f3 0f 10 47 18	 movss	 xmm0, DWORD PTR [edi+24]
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00110	f3 0f 5c cf	 subss	 xmm1, xmm7
  00114	f3 0f 5c d6	 subss	 xmm2, xmm6
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 756  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  00118	f3 0f 59 c0	 mulss	 xmm0, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  0011c	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00120	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00124	f3 0f 58 ca	 addss	 xmm1, xmm2
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 756  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  00128	0f 2f c1	 comiss	 xmm0, xmm1
  0012b	72 15		 jb	 SHORT $LN8@OnMovement
  0012d	5f		 pop	 edi
  0012e	5e		 pop	 esi
  0012f	b0 01		 mov	 al, 1
  00131	5b		 pop	 ebx

; 773  : }

  00132	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00135	33 cd		 xor	 ecx, ebp
  00137	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c2 04 00	 ret	 4
$LN8@OnMovement:
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00142	f3 0f 10 47 14	 movss	 xmm0, DWORD PTR [edi+20]
  00147	f3 0f 10 57 0c	 movss	 xmm2, DWORD PTR [edi+12]
  0014c	f3 0f 5c c5	 subss	 xmm0, xmm5
  00150	f3 0f 10 4f 10	 movss	 xmm1, DWORD PTR [edi+16]
  00155	f3 0f 5c d3	 subss	 xmm2, xmm3
  00159	f3 0f 5c cc	 subss	 xmm1, xmm4
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 759  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  0015d	53		 push	 ebx
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 182  :     z = fz;

  0015e	f3 0f 11 45 d4	 movss	 DWORD PTR $T2[ebp+8], xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 758  : 	v3Sphere = s.v3LastPosition - v3Center;

  00163	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp+8]
  00166	89 45 f8	 mov	 DWORD PTR _v3Sphere$[ebp+8], eax

; 759  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00169	8d 45 f0	 lea	 eax, DWORD PTR _v3Sphere$[ebp]
  0016c	50		 push	 eax
  0016d	0f 14 d1	 unpcklps xmm2, xmm1
  00170	50		 push	 eax
  00171	66 0f d6 55 f0	 movq	 QWORD PTR _v3Sphere$[ebp], xmm2
  00176	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0017b	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _v3Sphere$[ebp+8]
  00180	f3 0f 10 5d f0	 movss	 xmm3, DWORD PTR _v3Sphere$[ebp]
  00185	f3 0f 58 45 ec	 addss	 xmm0, DWORD PTR _v3Center$3$[ebp]
  0018a	f3 0f 58 5d e4	 addss	 xmm3, DWORD PTR _v3Center$1$[ebp]
  0018f	f3 0f 10 65 f4	 movss	 xmm4, DWORD PTR _v3Sphere$[ebp+4]
  00194	f3 0f 58 65 e8	 addss	 xmm4, DWORD PTR _v3Center$2$[ebp]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 763  : 	if(v3Point.x < m_attribute.v3Min.x) { v3Point.x = m_attribute.v3Min.x; }

  00199	f3 0f 10 56 04	 movss	 xmm2, DWORD PTR [esi+4]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 182  :     z = fz;

  0019e	f3 0f 11 45 d4	 movss	 DWORD PTR $T1[ebp+8], xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 763  : 	if(v3Point.x < m_attribute.v3Min.x) { v3Point.x = m_attribute.v3Min.x; }

  001a3	0f 2f d3	 comiss	 xmm2, xmm3
  001a6	8b 45 d4	 mov	 eax, DWORD PTR $T1[ebp+8]
  001a9	89 45 e0	 mov	 DWORD PTR _v3Point$[ebp+8], eax
  001ac	0f 28 c3	 movaps	 xmm0, xmm3
  001af	0f 14 c4	 unpcklps xmm0, xmm4
  001b2	66 0f d6 45 d8	 movq	 QWORD PTR _v3Point$[ebp], xmm0
  001b7	77 05		 ja	 SHORT $LN7@OnMovement
  001b9	f3 0f 10 55 d8	 movss	 xmm2, DWORD PTR _v3Point$[ebp]
$LN7@OnMovement:

; 764  : 	if(v3Point.x > m_attribute.v3Max.x) { v3Point.x = m_attribute.v3Max.x; }

  001be	f3 0f 10 46 10	 movss	 xmm0, DWORD PTR [esi+16]
  001c3	0f 2f d0	 comiss	 xmm2, xmm0
  001c6	76 03		 jbe	 SHORT $LN6@OnMovement
  001c8	0f 28 d0	 movaps	 xmm2, xmm0
$LN6@OnMovement:

; 765  : 	if(v3Point.y < m_attribute.v3Min.y) { v3Point.y = m_attribute.v3Min.y; }

  001cb	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
  001d0	f3 0f 10 4d dc	 movss	 xmm1, DWORD PTR _v3Point$[ebp+4]
  001d5	0f 2f c1	 comiss	 xmm0, xmm1
  001d8	76 03		 jbe	 SHORT $LN5@OnMovement
  001da	0f 28 c8	 movaps	 xmm1, xmm0
$LN5@OnMovement:

; 766  : 	if(v3Point.y > m_attribute.v3Max.y) { v3Point.y = m_attribute.v3Max.y; }

  001dd	f3 0f 10 46 14	 movss	 xmm0, DWORD PTR [esi+20]
  001e2	0f 2f c8	 comiss	 xmm1, xmm0
  001e5	76 03		 jbe	 SHORT $LN4@OnMovement
  001e7	0f 28 c8	 movaps	 xmm1, xmm0
$LN4@OnMovement:

; 770  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  001ea	f3 0f 10 47 18	 movss	 xmm0, DWORD PTR [edi+24]
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  001ef	f3 0f 5c d3	 subss	 xmm2, xmm3
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 773  : }

  001f3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  001f6	f3 0f 5c cc	 subss	 xmm1, xmm4
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 770  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  001fa	f3 0f 59 c0	 mulss	 xmm0, xmm0
  001fe	5f		 pop	 edi
  001ff	5e		 pop	 esi
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00200	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00204	5b		 pop	 ebx
  00205	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00209	f3 0f 58 d1	 addss	 xmm2, xmm1
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 770  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  0020d	0f 2f c2	 comiss	 xmm0, xmm2
  00210	0f 93 c0	 setae	 al

; 773  : }

  00213	33 cd		 xor	 ecx, ebp
  00215	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021a	8b e5		 mov	 esp, ebp
  0021c	5d		 pop	 ebp
  0021d	c2 04 00	 ret	 4
?OnMovementCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; COBBCollisionInstance::OnMovementCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?OnDestroy@COBBCollisionInstance@@MAEXXZ
_TEXT	SEGMENT
_pkData$ = -4						; size = 4
?OnDestroy@COBBCollisionInstance@@MAEXXZ PROC		; COBBCollisionInstance::OnDestroy, COMDAT
; _this$ = ecx

; 827  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 81   : 			m_kVct_pkFree.push_back(pkData);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _pkData$[ebp]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 828  : 	gs_oci.Free(this);

  00007	89 4d fc	 mov	 DWORD PTR _pkData$[ebp], ecx
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 81   : 			m_kVct_pkFree.push_back(pkData);

  0000a	50		 push	 eax
  0000b	b9 10 00 00 00	 mov	 ecx, OFFSET ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+16
  00010	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXABQAVCOBBCollisionInstance@@@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::push_back
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 829  : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?OnDestroy@COBBCollisionInstance@@MAEXXZ ENDP		; COBBCollisionInstance::OnDestroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_d3dFillMode$ = 8					; size = 4
?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z PROC ; COBBCollisionInstance::Render, COMDAT
; _this$ = ecx

; 819  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 820  : 	static CScreen s;

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S5@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA
  0002a	a8 01		 test	 al, 1
  0002c	75 2d		 jne	 SHORT $LN1@Render
  0002e	83 c8 01	 or	 eax, 1
  00031	a3 00 00 00 00	 mov	 DWORD PTR ?$S5@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA, eax
  00036	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00042	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  00047	68 00 00 00 00	 push	 OFFSET ??__Fs@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ; `COBBCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
  0004c	e8 00 00 00 00	 call	 _atexit
  00051	83 c4 04	 add	 esp, 4
  00054	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
$LN1@Render:

; 821  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, 0xffffffff);

  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00061	6a ff		 push	 -1
  00063	6a 3c		 push	 60			; 0000003cH
  00065	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 822  : 	s.RenderCube(m_attribute.v3Min.x, m_attribute.v3Min.y, m_attribute.v3Min.z, m_attribute.v3Max.x, m_attribute.v3Max.y, m_attribute.v3Max.z, m_attribute.matRot);

  0006a	f3 0f 6f 46 1c	 movdqu	 xmm0, XMMWORD PTR [esi+28]
  0006f	83 ec 40	 sub	 esp, 64			; 00000040H
  00072	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00077	8b c4		 mov	 eax, esp
  00079	83 ec 18	 sub	 esp, 24			; 00000018H
  0007c	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  00080	f3 0f 6f 46 2c	 movdqu	 xmm0, XMMWORD PTR [esi+44]
  00085	f3 0f 7f 40 10	 movdqu	 XMMWORD PTR [eax+16], xmm0
  0008a	f3 0f 6f 46 3c	 movdqu	 xmm0, XMMWORD PTR [esi+60]
  0008f	f3 0f 7f 40 20	 movdqu	 XMMWORD PTR [eax+32], xmm0
  00094	f3 0f 6f 46 4c	 movdqu	 xmm0, XMMWORD PTR [esi+76]
  00099	f3 0f 7f 40 30	 movdqu	 XMMWORD PTR [eax+48], xmm0
  0009e	0f 10 46 0c	 movups	 xmm0, XMMWORD PTR [esi+12]
  000a2	0f 11 44 24 08	 movups	 XMMWORD PTR [esp+8], xmm0
  000a7	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
  000ac	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000b2	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]
  000b7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bc	e8 00 00 00 00	 call	 ?RenderCube@CScreen@@QAEXMMMMMMUD3DXMATRIX@@@Z ; CScreen::RenderCube

; 823  : 	return;
; 824  : }

  000c1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000cb	59		 pop	 ecx
  000cc	5e		 pop	 esi
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0:
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S5@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA
  00005	83 e0 fe	 and	 eax, -2			; fffffffeH
  00008	a3 00 00 00 00	 mov	 DWORD PTR ?$S5@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA, eax
  0000d	c3		 ret	 0
__ehhandler$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ENDP ; COBBCollisionInstance::Render
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?GetAttribute@COBBCollisionInstance@@QBEABUSOBBData@@XZ
_TEXT	SEGMENT
?GetAttribute@COBBCollisionInstance@@QBEABUSOBBData@@XZ PROC ; COBBCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 737  : 
; 738  : 	return m_attribute;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 739  : }

  00003	c3		 ret	 0
?GetAttribute@COBBCollisionInstance@@QBEABUSOBBData@@XZ ENDP ; COBBCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?GetAttribute@COBBCollisionInstance@@QAEAAUSOBBData@@XZ
_TEXT	SEGMENT
?GetAttribute@COBBCollisionInstance@@QAEAAUSOBBData@@XZ PROC ; COBBCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 732  : 	return m_attribute;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 733  : }

  00003	c3		 ret	 0
?GetAttribute@COBBCollisionInstance@@QAEAAUSOBBData@@XZ ENDP ; COBBCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0CAABBCollisionInstance@@QAE@XZ
_TEXT	SEGMENT
??0CAABBCollisionInstance@@QAE@XZ PROC			; CAABBCollisionInstance::CAABBCollisionInstance, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CAABBCollisionInstance@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0CAABBCollisionInstance@@QAE@XZ ENDP			; CAABBCollisionInstance::CAABBCollisionInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?OnGetCollisionMovementAdjust@CAABBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
?OnGetCollisionMovementAdjust@CAABBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z PROC ; CAABBCollisionInstance::OnGetCollisionMovementAdjust, COMDAT
; _this$ = ecx

; 662  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 663  : 	
; 664  : 	//Tracef("OnGetCollisionMovementAdjust	v3Min.x = %f, v3Max.x = %f\n", m_attribute.v3Min.x, m_attribute.v3Max.x);
; 665  : 	/*
; 666  : 	float fARadius = D3DXVec3Length(&(m_attribute.v3Min - m_attribute.v3Max));
; 667  : 	if (D3DXVec3LengthSq(&(s.v3Position-(m_attribute.v3Max + m_attribute.v3Min)))>=(s.fRadius+fARadius)*(fARadius+s.fRadius))
; 668  : 		return D3DXVECTOR3(0.0f,0.0f,0.0f);
; 669  : 	D3DXVECTOR3 c;
; 670  : 	D3DXVec3Cross(&c, &(s.v3Position-s.v3LastPosition), &D3DXVECTOR3(0.0f,0.0f,1.0f) );
; 671  : 	
; 672  : 	float sum = - D3DXVec3Dot(&c,&(s.v3Position-(m_attribute.v3Max + m_attribute.v3Min)));
; 673  : 	float mul = (s.fRadius+fARadius)*(s.fRadius+fARadius)-D3DXVec3LengthSq(&(s.v3Position-(m_attribute.v3Max + m_attribute.v3Min)));
; 674  : 
; 675  : 	if (sum*sum-4*mul<=0)
; 676  : 		return D3DXVECTOR3(0.0f,0.0f,0.0f);
; 677  : 	float sq = sqrt(sum*sum-4*mul);
; 678  : 	float t1=-sum-sq, t2=-sum+sq;
; 679  : 	t1*=0.5f;
; 680  : 	t2*=0.5f;
; 681  : 
; 682  : 	if (fabs(t1)<=fabs(t2))
; 683  : 	{
; 684  : 		return (gc_fReduceMove*t1)*c;
; 685  : 	}
; 686  : 	else
; 687  : 		return (gc_fReduceMove*t2)*c;
; 688  : 	*/
; 689  : 	
; 690  : 	D3DXVECTOR3 v3Temp;
; 691  : 	if(s.v3Position.x + s.fRadius <= m_attribute.v3Min.x)		{ v3Temp.x = m_attribute.v3Min.x; }

  00003	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00006	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0000b	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  0000f	f3 0f 10 60 18	 movss	 xmm4, DWORD PTR [eax+24]
  00014	0f 28 ca	 movaps	 xmm1, xmm2
  00017	f3 0f 58 cc	 addss	 xmm1, xmm4
  0001b	0f 2f c1	 comiss	 xmm0, xmm1
  0001e	73 25		 jae	 SHORT $LN14@OnGetColli

; 692  : 	else if(s.v3Position.x - s.fRadius >= m_attribute.v3Max.x)	{ v3Temp.x = m_attribute.v3Max.x; }

  00020	f3 0f 10 59 10	 movss	 xmm3, DWORD PTR [ecx+16]
  00025	f3 0f 5c d4	 subss	 xmm2, xmm4
  00029	0f 2f d3	 comiss	 xmm2, xmm3
  0002c	72 05		 jb	 SHORT $LN17@OnGetColli
  0002e	0f 28 c3	 movaps	 xmm0, xmm3
  00031	eb 12		 jmp	 SHORT $LN14@OnGetColli
$LN17@OnGetColli:

; 693  : 	else if(s.v3Position.x + s.fRadius >= m_attribute.v3Min.x && s.v3Position.x + s.fRadius <= m_attribute.v3Max.x) { v3Temp.x = s.v3Position.x + s.fRadius; }

  00033	0f 2f c8	 comiss	 xmm1, xmm0
  00036	72 0a		 jb	 SHORT $LN15@OnGetColli
  00038	0f 2f d9	 comiss	 xmm3, xmm1
  0003b	72 05		 jb	 SHORT $LN15@OnGetColli
  0003d	0f 28 c1	 movaps	 xmm0, xmm1
  00040	eb 03		 jmp	 SHORT $LN14@OnGetColli
$LN15@OnGetColli:

; 694  : 	else																											{ v3Temp.x = s.v3Position.x - s.fRadius; }

  00042	0f 28 c2	 movaps	 xmm0, xmm2
$LN14@OnGetColli:

; 695  : 
; 696  : 	if(s.v3Position.y + s.fRadius <= m_attribute.v3Min.y)		{ v3Temp.y = m_attribute.v3Min.y; }

  00045	f3 0f 10 58 04	 movss	 xmm3, DWORD PTR [eax+4]
  0004a	f3 0f 10 51 08	 movss	 xmm2, DWORD PTR [ecx+8]
  0004f	0f 28 cb	 movaps	 xmm1, xmm3
  00052	f3 0f 58 cc	 addss	 xmm1, xmm4
  00056	0f 2f d1	 comiss	 xmm2, xmm1
  00059	73 25		 jae	 SHORT $LN8@OnGetColli

; 697  : 	else if(s.v3Position.y - s.fRadius >= m_attribute.v3Max.y)	{ v3Temp.y = m_attribute.v3Max.y; }

  0005b	f3 0f 10 69 14	 movss	 xmm5, DWORD PTR [ecx+20]
  00060	f3 0f 5c dc	 subss	 xmm3, xmm4
  00064	0f 2f dd	 comiss	 xmm3, xmm5
  00067	72 05		 jb	 SHORT $LN11@OnGetColli
  00069	0f 28 d5	 movaps	 xmm2, xmm5
  0006c	eb 12		 jmp	 SHORT $LN8@OnGetColli
$LN11@OnGetColli:

; 698  : 	else if(s.v3Position.y + s.fRadius >= m_attribute.v3Min.y && s.v3Position.y + s.fRadius <= m_attribute.v3Max.y) { v3Temp.y = s.v3Position.y + s.fRadius; }

  0006e	0f 2f ca	 comiss	 xmm1, xmm2
  00071	72 0a		 jb	 SHORT $LN9@OnGetColli
  00073	0f 2f e9	 comiss	 xmm5, xmm1
  00076	72 05		 jb	 SHORT $LN9@OnGetColli
  00078	0f 28 d1	 movaps	 xmm2, xmm1
  0007b	eb 03		 jmp	 SHORT $LN8@OnGetColli
$LN9@OnGetColli:

; 699  : 	else																											{ v3Temp.y = s.v3Position.y - s.fRadius; }

  0007d	0f 28 d3	 movaps	 xmm2, xmm3
$LN8@OnGetColli:

; 700  : 	
; 701  : 	if(s.v3Position.z + s.fRadius <= m_attribute.v3Min.z)		{ v3Temp.z = m_attribute.v3Min.z; }

  00080	f3 0f 10 78 08	 movss	 xmm7, DWORD PTR [eax+8]
  00085	f3 0f 10 49 0c	 movss	 xmm1, DWORD PTR [ecx+12]
  0008a	0f 28 df	 movaps	 xmm3, xmm7
  0008d	f3 0f 58 dc	 addss	 xmm3, xmm4
  00091	0f 2f cb	 comiss	 xmm1, xmm3
  00094	73 28		 jae	 SHORT $LN2@OnGetColli

; 702  : 	else if(s.v3Position.z - s.fRadius >= m_attribute.v3Max.z)	{ v3Temp.z = m_attribute.v3Max.z; }

  00096	f3 0f 10 71 18	 movss	 xmm6, DWORD PTR [ecx+24]
  0009b	0f 28 ef	 movaps	 xmm5, xmm7
  0009e	f3 0f 5c ec	 subss	 xmm5, xmm4
  000a2	0f 2f ee	 comiss	 xmm5, xmm6
  000a5	72 05		 jb	 SHORT $LN5@OnGetColli
  000a7	0f 28 ce	 movaps	 xmm1, xmm6
  000aa	eb 12		 jmp	 SHORT $LN2@OnGetColli
$LN5@OnGetColli:

; 703  : 	else if(s.v3Position.z + s.fRadius >= m_attribute.v3Min.z && s.v3Position.z + s.fRadius <= m_attribute.v3Max.z) { v3Temp.z = s.v3Position.z + s.fRadius; }

  000ac	0f 2f d9	 comiss	 xmm3, xmm1
  000af	72 0a		 jb	 SHORT $LN3@OnGetColli
  000b1	0f 2f f3	 comiss	 xmm6, xmm3
  000b4	72 05		 jb	 SHORT $LN3@OnGetColli
  000b6	0f 28 cb	 movaps	 xmm1, xmm3
  000b9	eb 03		 jmp	 SHORT $LN2@OnGetColli
$LN3@OnGetColli:

; 704  : 	else																											{ v3Temp.z = s.v3Position.z - s.fRadius; }

  000bb	0f 28 cd	 movaps	 xmm1, xmm5
$LN2@OnGetColli:
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000be	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  000c2	f3 0f 5c 50 04	 subss	 xmm2, DWORD PTR [eax+4]

; 180  :     x = fx;

  000c7	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000ca	f3 0f 5c cf	 subss	 xmm1, xmm7
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 707  : 	if(D3DXVec3LengthSq(&(v3Temp - s.v3Position)) < s.fRadius * s.fRadius)

  000ce	f3 0f 59 e4	 mulss	 xmm4, xmm4
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000d2	f3 0f 59 c0	 mulss	 xmm0, xmm0

; 180  :     x = fx;

  000d6	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000dc	f3 0f 59 d2	 mulss	 xmm2, xmm2

; 181  :     y = fy;

  000e0	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000e7	f3 0f 59 c9	 mulss	 xmm1, xmm1

; 182  :     z = fz;

  000eb	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000f2	f3 0f 58 c2	 addss	 xmm0, xmm2
  000f6	f3 0f 58 c1	 addss	 xmm0, xmm1
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 712  : }

  000fa	5d		 pop	 ebp
  000fb	c2 08 00	 ret	 8
?OnGetCollisionMovementAdjust@CAABBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ENDP ; CAABBCollisionInstance::OnGetCollisionMovementAdjust
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?OnCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_v$ = -12						; size = 12
tv733 = 8						; size = 4
_s$ = 8							; size = 4
?OnCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CAABBCollisionInstance::OnCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 621  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 622  : 	D3DXVECTOR3 v;
; 623  : 	memcpy(&v, &s.v3Position, sizeof(D3DXVECTOR3));

  00006	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]

; 624  : 
; 625  : 	if(v.x < m_attribute.v3Min.x) v.x = m_attribute.v3Min.x;

  00009	f3 0f 10 69 04	 movss	 xmm5, DWORD PTR [ecx+4]
  0000e	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  00012	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00015	66 0f d6 45 f4	 movq	 QWORD PTR _v$[ebp], xmm0
  0001a	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v$[ebp]
  0001f	0f 2f e8	 comiss	 xmm5, xmm0
  00022	89 45 fc	 mov	 DWORD PTR _v$[ebp+8], eax
  00025	76 03		 jbe	 SHORT $LN16@OnCollisio
  00027	0f 28 c5	 movaps	 xmm0, xmm5
$LN16@OnCollisio:

; 626  : 	if(v.x > m_attribute.v3Max.x) v.x = m_attribute.v3Max.x;

  0002a	f3 0f 10 59 10	 movss	 xmm3, DWORD PTR [ecx+16]
  0002f	0f 2f c3	 comiss	 xmm0, xmm3
  00032	76 03		 jbe	 SHORT $LN15@OnCollisio
  00034	0f 28 c3	 movaps	 xmm0, xmm3
$LN15@OnCollisio:

; 627  : 	if(v.y < m_attribute.v3Min.y) v.x = m_attribute.v3Min.y;

  00037	f3 0f 10 61 08	 movss	 xmm4, DWORD PTR [ecx+8]
  0003c	f3 0f 10 55 f8	 movss	 xmm2, DWORD PTR _v$[ebp+4]
  00041	0f 2f e2	 comiss	 xmm4, xmm2
  00044	76 03		 jbe	 SHORT $LN14@OnCollisio
  00046	0f 28 c4	 movaps	 xmm0, xmm4
$LN14@OnCollisio:

; 628  : 	if(v.y > m_attribute.v3Max.y) v.x = m_attribute.v3Max.y;

  00049	f3 0f 10 71 14	 movss	 xmm6, DWORD PTR [ecx+20]
  0004e	0f 2f d6	 comiss	 xmm2, xmm6
  00051	76 03		 jbe	 SHORT $LN13@OnCollisio
  00053	0f 28 c6	 movaps	 xmm0, xmm6
$LN13@OnCollisio:

; 629  : 	if(v.z < m_attribute.v3Min.z) v.z = m_attribute.v3Min.z;

  00056	f3 0f 10 79 0c	 movss	 xmm7, DWORD PTR [ecx+12]
  0005b	f3 0f 10 4d fc	 movss	 xmm1, DWORD PTR _v$[ebp+8]
  00060	0f 2f f9	 comiss	 xmm7, xmm1
  00063	76 03		 jbe	 SHORT $LN12@OnCollisio
  00065	0f 28 cf	 movaps	 xmm1, xmm7
$LN12@OnCollisio:

; 630  : 	if(v.z > m_attribute.v3Max.z) v.z = m_attribute.v3Max.z;

  00068	f3 0f 10 79 18	 movss	 xmm7, DWORD PTR [ecx+24]
  0006d	0f 2f cf	 comiss	 xmm1, xmm7
  00070	76 03		 jbe	 SHORT $LN11@OnCollisio
  00072	0f 28 cf	 movaps	 xmm1, xmm7
$LN11@OnCollisio:

; 631  : 
; 632  : 	if(v.x > m_attribute.v3Min.x && v.x < m_attribute.v3Max.x &&
; 633  : 		v.y > m_attribute.v3Min.y && v.y < m_attribute.v3Max.y &&
; 634  : 		v.z > m_attribute.v3Min.z && v.z < m_attribute.v3Max.z) { return true; }

  00075	0f 2f c5	 comiss	 xmm0, xmm5
  00078	76 22		 jbe	 SHORT $LN10@OnCollisio
  0007a	0f 2f d8	 comiss	 xmm3, xmm0
  0007d	76 1d		 jbe	 SHORT $LN10@OnCollisio
  0007f	0f 2f d4	 comiss	 xmm2, xmm4
  00082	76 18		 jbe	 SHORT $LN10@OnCollisio
  00084	0f 2f f2	 comiss	 xmm6, xmm2
  00087	76 13		 jbe	 SHORT $LN10@OnCollisio
  00089	0f 2f 49 0c	 comiss	 xmm1, DWORD PTR [ecx+12]
  0008d	76 0d		 jbe	 SHORT $LN10@OnCollisio
  0008f	0f 2f f9	 comiss	 xmm7, xmm1
  00092	76 08		 jbe	 SHORT $LN10@OnCollisio
$LN25@OnCollisio:
  00094	b0 01		 mov	 al, 1

; 655  : 
; 656  : 	
; 657  : 
; 658  : 	return false;
; 659  : }

  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c2 04 00	 ret	 4
$LN10@OnCollisio:
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  0009c	f3 0f 5c 02	 subss	 xmm0, DWORD PTR [edx]
  000a0	f3 0f 5c 52 04	 subss	 xmm2, DWORD PTR [edx+4]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 636  : 	if(GetVector3Distance(v, s.v3Position) <= s.fRadius * s.fRadius) { return true; }

  000a5	f3 0f 10 4a 18	 movss	 xmm1, DWORD PTR [edx+24]
  000aa	f3 0f 59 c9	 mulss	 xmm1, xmm1
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  000ae	f3 0f 59 c0	 mulss	 xmm0, xmm0
  000b2	f3 0f 59 d2	 mulss	 xmm2, xmm2
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 636  : 	if(GetVector3Distance(v, s.v3Position) <= s.fRadius * s.fRadius) { return true; }

  000b6	f3 0f 11 4d 08	 movss	 DWORD PTR tv733[ebp], xmm1
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  000bb	f3 0f 58 c2	 addss	 xmm0, xmm2
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 636  : 	if(GetVector3Distance(v, s.v3Position) <= s.fRadius * s.fRadius) { return true; }

  000bf	0f 2f c8	 comiss	 xmm1, xmm0
  000c2	73 d0		 jae	 SHORT $LN25@OnCollisio

; 637  : 
; 638  : 
; 639  : 	memcpy(&v, &s.v3LastPosition, sizeof(D3DXVECTOR3));

  000c4	f3 0f 7e 42 0c	 movq	 xmm0, QWORD PTR [edx+12]
  000c9	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000cc	66 0f d6 45 f4	 movq	 QWORD PTR _v$[ebp], xmm0

; 640  : 
; 641  : 	if(v.x < m_attribute.v3Min.x) v.x = m_attribute.v3Min.x;

  000d1	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v$[ebp]
  000d6	0f 2f e8	 comiss	 xmm5, xmm0
  000d9	89 45 fc	 mov	 DWORD PTR _v$[ebp+8], eax
  000dc	76 03		 jbe	 SHORT $LN8@OnCollisio
  000de	0f 28 c5	 movaps	 xmm0, xmm5
$LN8@OnCollisio:

; 642  : 	if(v.x > m_attribute.v3Max.x) v.x = m_attribute.v3Max.x;

  000e1	0f 2f c3	 comiss	 xmm0, xmm3
  000e4	76 03		 jbe	 SHORT $LN7@OnCollisio
  000e6	0f 28 c3	 movaps	 xmm0, xmm3
$LN7@OnCollisio:

; 643  : 	if(v.y < m_attribute.v3Min.y) v.x = m_attribute.v3Min.y;

  000e9	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _v$[ebp+4]
  000ee	0f 2f e1	 comiss	 xmm4, xmm1
  000f1	76 03		 jbe	 SHORT $LN6@OnCollisio
  000f3	0f 28 c4	 movaps	 xmm0, xmm4
$LN6@OnCollisio:

; 644  : 	if(v.y > m_attribute.v3Max.y) v.x = m_attribute.v3Max.y;

  000f6	0f 2f ce	 comiss	 xmm1, xmm6
  000f9	76 03		 jbe	 SHORT $LN5@OnCollisio
  000fb	0f 28 c6	 movaps	 xmm0, xmm6
$LN5@OnCollisio:

; 645  : 	if(v.z < m_attribute.v3Min.z) v.z = m_attribute.v3Min.z;

  000fe	f3 0f 10 79 0c	 movss	 xmm7, DWORD PTR [ecx+12]
  00103	f3 0f 10 55 fc	 movss	 xmm2, DWORD PTR _v$[ebp+8]
  00108	0f 2f fa	 comiss	 xmm7, xmm2
  0010b	f3 0f 10 79 18	 movss	 xmm7, DWORD PTR [ecx+24]
  00110	76 05		 jbe	 SHORT $LN4@OnCollisio
  00112	f3 0f 10 51 0c	 movss	 xmm2, DWORD PTR [ecx+12]
$LN4@OnCollisio:

; 646  : 	if(v.z > m_attribute.v3Max.z) v.z = m_attribute.v3Max.z;

  00117	0f 2f d7	 comiss	 xmm2, xmm7
  0011a	76 03		 jbe	 SHORT $LN3@OnCollisio
  0011c	0f 28 d7	 movaps	 xmm2, xmm7
$LN3@OnCollisio:

; 647  : 	
; 648  : 
; 649  : 
; 650  : 	if(v.x > m_attribute.v3Min.x && v.x < m_attribute.v3Max.x &&
; 651  : 		v.y > m_attribute.v3Min.y && v.y < m_attribute.v3Max.y &&
; 652  : 		v.z > m_attribute.v3Min.z && v.z < m_attribute.v3Max.z) { return true; }

  0011f	0f 2f c5	 comiss	 xmm0, xmm5
  00122	76 1e		 jbe	 SHORT $LN2@OnCollisio
  00124	0f 2f d8	 comiss	 xmm3, xmm0
  00127	76 19		 jbe	 SHORT $LN2@OnCollisio
  00129	0f 2f cc	 comiss	 xmm1, xmm4
  0012c	76 14		 jbe	 SHORT $LN2@OnCollisio
  0012e	0f 2f f1	 comiss	 xmm6, xmm1
  00131	76 0f		 jbe	 SHORT $LN2@OnCollisio
  00133	0f 2f 51 0c	 comiss	 xmm2, DWORD PTR [ecx+12]
  00137	76 09		 jbe	 SHORT $LN2@OnCollisio
  00139	0f 2f fa	 comiss	 xmm7, xmm2
  0013c	0f 87 52 ff ff
	ff		 ja	 $LN25@OnCollisio
$LN2@OnCollisio:
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00142	f3 0f 5c 4a 10	 subss	 xmm1, DWORD PTR [edx+16]
  00147	f3 0f 5c 42 0c	 subss	 xmm0, DWORD PTR [edx+12]
  0014c	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00150	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00154	f3 0f 58 c1	 addss	 xmm0, xmm1
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 654  : 	if(GetVector3Distance(v, s.v3LastPosition) <= s.fRadius * s.fRadius) { return true; }

  00158	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR tv733[ebp]
  0015d	0f 2f c8	 comiss	 xmm1, xmm0
  00160	0f 93 c0	 setae	 al

; 655  : 
; 656  : 	
; 657  : 
; 658  : 	return false;
; 659  : }

  00163	8b e5		 mov	 esp, ebp
  00165	5d		 pop	 ebp
  00166	c2 04 00	 ret	 4
?OnCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CAABBCollisionInstance::OnCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?OnMovementCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_v$ = -12						; size = 12
_s$ = 8							; size = 4
?OnMovementCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CAABBCollisionInstance::OnMovementCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 582  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 583  : 	D3DXVECTOR3 v;
; 584  : 	D3DXVECTOR3 v3center = (m_attribute.v3Min + m_attribute.v3Max) * 0.5f;
; 585  : 
; 586  : 	memcpy(&v, &s.v3Position, sizeof(D3DXVECTOR3));

  00006	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]

; 587  : 
; 588  : 	if(v.x < m_attribute.v3Min.x) v.x = m_attribute.v3Min.x;

  00009	f3 0f 10 69 04	 movss	 xmm5, DWORD PTR [ecx+4]
  0000e	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  00012	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00015	66 0f d6 45 f4	 movq	 QWORD PTR _v$[ebp], xmm0
  0001a	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v$[ebp]
  0001f	0f 2f e8	 comiss	 xmm5, xmm0
  00022	89 45 fc	 mov	 DWORD PTR _v$[ebp+8], eax
  00025	76 03		 jbe	 SHORT $LN14@OnMovement
  00027	0f 28 c5	 movaps	 xmm0, xmm5
$LN14@OnMovement:

; 589  : 	if(v.x > m_attribute.v3Max.x) v.x = m_attribute.v3Max.x;

  0002a	f3 0f 10 49 10	 movss	 xmm1, DWORD PTR [ecx+16]
  0002f	0f 2f c1	 comiss	 xmm0, xmm1
  00032	76 03		 jbe	 SHORT $LN13@OnMovement
  00034	0f 28 c1	 movaps	 xmm0, xmm1
$LN13@OnMovement:

; 590  : 	if(v.y < m_attribute.v3Min.y) v.x = m_attribute.v3Min.y;

  00037	f3 0f 10 59 08	 movss	 xmm3, DWORD PTR [ecx+8]
  0003c	f3 0f 10 65 f8	 movss	 xmm4, DWORD PTR _v$[ebp+4]
  00041	0f 2f dc	 comiss	 xmm3, xmm4
  00044	76 03		 jbe	 SHORT $LN12@OnMovement
  00046	0f 28 c3	 movaps	 xmm0, xmm3
$LN12@OnMovement:

; 591  : 	if(v.y > m_attribute.v3Max.y) v.x = m_attribute.v3Max.y;

  00049	f3 0f 10 51 14	 movss	 xmm2, DWORD PTR [ecx+20]
  0004e	0f 2f e2	 comiss	 xmm4, xmm2
  00051	76 03		 jbe	 SHORT $LN11@OnMovement
  00053	0f 28 c2	 movaps	 xmm0, xmm2
$LN11@OnMovement:
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00056	f3 0f 5c 02	 subss	 xmm0, DWORD PTR [edx]
  0005a	f3 0f 5c 62 04	 subss	 xmm4, DWORD PTR [edx+4]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 595  : 	if(GetVector3Distance(v, s.v3Position) <= s.fRadius * s.fRadius)

  0005f	f3 0f 10 72 18	 movss	 xmm6, DWORD PTR [edx+24]
  00064	f3 0f 59 f6	 mulss	 xmm6, xmm6
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00068	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0006c	f3 0f 59 e4	 mulss	 xmm4, xmm4
  00070	f3 0f 58 c4	 addss	 xmm0, xmm4
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 595  : 	if(GetVector3Distance(v, s.v3Position) <= s.fRadius * s.fRadius)

  00074	0f 2f f0	 comiss	 xmm6, xmm0
  00077	72 08		 jb	 SHORT $LN8@OnMovement

; 596  : 	{
; 597  : 		
; 598  : 		return true;

  00079	b0 01		 mov	 al, 1

; 612  : 	{
; 613  : 		
; 614  : 		return true;
; 615  : 	}
; 616  : 
; 617  : 	return false;
; 618  : }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
$LN8@OnMovement:

; 599  : 	}
; 600  : 
; 601  : 
; 602  : 	memcpy(&v, &s.v3LastPosition, sizeof(D3DXVECTOR3));

  00081	f3 0f 7e 42 0c	 movq	 xmm0, QWORD PTR [edx+12]
  00086	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00089	66 0f d6 45 f4	 movq	 QWORD PTR _v$[ebp], xmm0

; 603  : 
; 604  : 	if(v.x < m_attribute.v3Min.x) v.x = m_attribute.v3Min.x;

  0008e	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v$[ebp]
  00093	0f 2f e8	 comiss	 xmm5, xmm0
  00096	89 45 fc	 mov	 DWORD PTR _v$[ebp+8], eax
  00099	76 03		 jbe	 SHORT $LN7@OnMovement
  0009b	0f 28 c5	 movaps	 xmm0, xmm5
$LN7@OnMovement:

; 605  : 	if(v.x > m_attribute.v3Max.x) v.x = m_attribute.v3Max.x;

  0009e	0f 2f c1	 comiss	 xmm0, xmm1
  000a1	76 03		 jbe	 SHORT $LN6@OnMovement
  000a3	0f 28 c1	 movaps	 xmm0, xmm1
$LN6@OnMovement:

; 606  : 	if(v.y < m_attribute.v3Min.y) v.x = m_attribute.v3Min.y;

  000a6	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _v$[ebp+4]
  000ab	0f 2f d9	 comiss	 xmm3, xmm1
  000ae	76 03		 jbe	 SHORT $LN5@OnMovement
  000b0	0f 28 c3	 movaps	 xmm0, xmm3
$LN5@OnMovement:

; 607  : 	if(v.y > m_attribute.v3Max.y) v.x = m_attribute.v3Max.y;

  000b3	0f 2f ca	 comiss	 xmm1, xmm2
  000b6	76 03		 jbe	 SHORT $LN4@OnMovement
  000b8	0f 28 c2	 movaps	 xmm0, xmm2
$LN4@OnMovement:
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  000bb	f3 0f 5c 4a 10	 subss	 xmm1, DWORD PTR [edx+16]
  000c0	f3 0f 5c 42 0c	 subss	 xmm0, DWORD PTR [edx+12]
  000c5	f3 0f 59 c9	 mulss	 xmm1, xmm1
  000c9	f3 0f 59 c0	 mulss	 xmm0, xmm0
  000cd	f3 0f 58 c8	 addss	 xmm1, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 611  : 	if(GetVector3Distance(v, s.v3LastPosition) <= s.fRadius * s.fRadius)

  000d1	0f 2f f1	 comiss	 xmm6, xmm1
  000d4	0f 93 c0	 setae	 al

; 612  : 	{
; 613  : 		
; 614  : 		return true;
; 615  : 	}
; 616  : 
; 617  : 	return false;
; 618  : }

  000d7	8b e5		 mov	 esp, ebp
  000d9	5d		 pop	 ebp
  000da	c2 04 00	 ret	 4
?OnMovementCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CAABBCollisionInstance::OnMovementCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?OnDestroy@CAABBCollisionInstance@@MAEXXZ
_TEXT	SEGMENT
_pkData$ = -4						; size = 4
?OnDestroy@CAABBCollisionInstance@@MAEXXZ PROC		; CAABBCollisionInstance::OnDestroy, COMDAT
; _this$ = ecx

; 723  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 81   : 			m_kVct_pkFree.push_back(pkData);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _pkData$[ebp]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 724  : 	gs_aci.Free(this);

  00007	89 4d fc	 mov	 DWORD PTR _pkData$[ebp], ecx
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 81   : 			m_kVct_pkFree.push_back(pkData);

  0000a	50		 push	 eax
  0000b	b9 10 00 00 00	 mov	 ecx, OFFSET ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+16
  00010	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXABQAVCAABBCollisionInstance@@@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::push_back
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 725  : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?OnDestroy@CAABBCollisionInstance@@MAEXXZ ENDP		; CAABBCollisionInstance::OnDestroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_d3dFillMode$ = 8					; size = 4
?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z PROC ; CAABBCollisionInstance::Render, COMDAT
; _this$ = ecx

; 715  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 716  : 	static CScreen s;

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S4@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA
  0002a	a8 01		 test	 al, 1
  0002c	75 2d		 jne	 SHORT $LN1@Render
  0002e	83 c8 01	 or	 eax, 1
  00031	a3 00 00 00 00	 mov	 DWORD PTR ?$S4@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA, eax
  00036	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00042	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  00047	68 00 00 00 00	 push	 OFFSET ??__Fs@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ; `CAABBCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
  0004c	e8 00 00 00 00	 call	 _atexit
  00051	83 c4 04	 add	 esp, 4
  00054	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
$LN1@Render:

; 717  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, 0xffffffff);

  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00061	6a ff		 push	 -1
  00063	6a 3c		 push	 60			; 0000003cH
  00065	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 718  : 	s.RenderCube(m_attribute.v3Min.x, m_attribute.v3Min.y, m_attribute.v3Min.z, m_attribute.v3Max.x, m_attribute.v3Max.y, m_attribute.v3Max.z);

  0006a	0f 10 46 0c	 movups	 xmm0, XMMWORD PTR [esi+12]
  0006e	83 ec 18	 sub	 esp, 24			; 00000018H
  00071	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00076	0f 11 44 24 08	 movups	 XMMWORD PTR [esp+8], xmm0
  0007b	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
  00080	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00086	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]
  0008b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00090	e8 00 00 00 00	 call	 ?RenderCube@CScreen@@QAEXMMMMMM@Z ; CScreen::RenderCube

; 719  : 	return;
; 720  : }

  00095	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00098	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009f	59		 pop	 ecx
  000a0	5e		 pop	 esi
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0:
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S4@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA
  00005	83 e0 fe	 and	 eax, -2			; fffffffeH
  00008	a3 00 00 00 00	 mov	 DWORD PTR ?$S4@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA, eax
  0000d	c3		 ret	 0
__ehhandler$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ENDP ; CAABBCollisionInstance::Render
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?GetAttribute@CAABBCollisionInstance@@QBEABUSAABBData@@XZ
_TEXT	SEGMENT
?GetAttribute@CAABBCollisionInstance@@QBEABUSAABBData@@XZ PROC ; CAABBCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 577  : 
; 578  : 	return m_attribute;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 579  : }

  00003	c3		 ret	 0
?GetAttribute@CAABBCollisionInstance@@QBEABUSAABBData@@XZ ENDP ; CAABBCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?GetAttribute@CAABBCollisionInstance@@QAEAAUSAABBData@@XZ
_TEXT	SEGMENT
?GetAttribute@CAABBCollisionInstance@@QAEAAUSAABBData@@XZ PROC ; CAABBCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 572  : 	return m_attribute;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 573  : }

  00003	c3		 ret	 0
?GetAttribute@CAABBCollisionInstance@@QAEAAUSAABBData@@XZ ENDP ; CAABBCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0CPlaneCollisionInstance@@QAE@XZ
_TEXT	SEGMENT
??0CPlaneCollisionInstance@@QAE@XZ PROC			; CPlaneCollisionInstance::CPlaneCollisionInstance, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CPlaneCollisionInstance@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0CPlaneCollisionInstance@@QAE@XZ ENDP			; CPlaneCollisionInstance::CPlaneCollisionInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?OnGetCollisionMovementAdjust@CPlaneCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T1 = 12						; size = 4
$T2 = 12						; size = 4
_s$ = 12						; size = 4
?OnGetCollisionMovementAdjust@CPlaneCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z PROC ; CPlaneCollisionInstance::OnGetCollisionMovementAdjust, COMDAT
; _this$ = ecx

; 363  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 364  : 	D3DXVECTOR3 advance = s.v3Position-s.v3LastPosition;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00006	f3 0f 10 41 10	 movss	 xmm0, DWORD PTR [ecx+16]
  0000b	f3 0f 10 51 14	 movss	 xmm2, DWORD PTR [ecx+20]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00010	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  00015	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  00019	0f 28 e9	 movaps	 xmm5, xmm1
  0001c	f3 0f 5c 68 10	 subss	 xmm5, DWORD PTR [eax+16]
  00021	f3 0f 10 78 08	 movss	 xmm7, DWORD PTR [eax+8]
  00026	0f 28 e3	 movaps	 xmm4, xmm3
  00029	f3 0f 5c 60 0c	 subss	 xmm4, DWORD PTR [eax+12]
  0002e	0f 28 f7	 movaps	 xmm6, xmm7
  00031	f3 0f 11 4d 0c	 movss	 DWORD PTR $T2[ebp], xmm1
  00036	f3 0f 5c 70 14	 subss	 xmm6, DWORD PTR [eax+20]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0003b	f3 0f 59 d5	 mulss	 xmm2, xmm5
  0003f	f3 0f 59 c4	 mulss	 xmm0, xmm4
  00043	f3 0f 58 d0	 addss	 xmm2, xmm0
  00047	f3 0f 10 41 18	 movss	 xmm0, DWORD PTR [ecx+24]
  0004c	f3 0f 59 c6	 mulss	 xmm0, xmm6
  00050	f3 0f 58 d0	 addss	 xmm2, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 367  : 	if (d>=-0.0001 && d<=0.0001)

  00054	0f 5a c2	 cvtps2pd xmm0, xmm2
  00057	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@bf1a36e2eb1c432d
  0005f	72 31		 jb	 SHORT $LN3@OnGetColli
  00061	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3f1a36e2eb1c432d
  00069	0f 5a ca	 cvtps2pd xmm1, xmm2
  0006c	66 0f 2f c1	 comisd	 xmm0, xmm1
  00070	72 1b		 jb	 SHORT $LN46@OnGetColli
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 180  :     x = fx;

  00072	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00075	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 181  :     y = fy;

  0007b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 182  :     z = fz;

  00082	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 426  : }

  00089	5d		 pop	 ebp
  0008a	c2 08 00	 ret	 8
$LN46@OnGetColli:
  0008d	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR $T2[ebp]
$LN3@OnGetColli:
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00092	f3 0f 5c 79 0c	 subss	 xmm7, DWORD PTR [ecx+12]
  00097	f3 0f 5c 49 08	 subss	 xmm1, DWORD PTR [ecx+8]
  0009c	f3 0f 5c 59 04	 subss	 xmm3, DWORD PTR [ecx+4]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000a1	f3 0f 10 41 10	 movss	 xmm0, DWORD PTR [ecx+16]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000a6	f3 0f 11 7d 0c	 movss	 DWORD PTR $T1[ebp], xmm7

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000ab	f3 0f 10 79 14	 movss	 xmm7, DWORD PTR [ecx+20]
  000b0	f3 0f 59 f9	 mulss	 xmm7, xmm1
  000b4	f3 0f 59 c3	 mulss	 xmm0, xmm3
  000b8	f3 0f 10 49 14	 movss	 xmm1, DWORD PTR [ecx+20]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  000bd	f3 0f 10 59 18	 movss	 xmm3, DWORD PTR [ecx+24]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000c2	f3 0f 58 f8	 addss	 xmm7, xmm0
  000c6	f3 0f 59 cd	 mulss	 xmm1, xmm5
  000ca	f3 0f 10 41 18	 movss	 xmm0, DWORD PTR [ecx+24]
  000cf	f3 0f 59 45 0c	 mulss	 xmm0, DWORD PTR $T1[ebp]
  000d4	f3 0f 58 f8	 addss	 xmm7, xmm0
  000d8	f3 0f 10 41 10	 movss	 xmm0, DWORD PTR [ecx+16]
  000dd	f3 0f 59 c4	 mulss	 xmm0, xmm4
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 369  : 	float t= - D3DXVec3Dot(&m_attribute.v3Normal, &(s.v3Position-m_attribute.v3Position))/d;

  000e1	f3 0f 5e fa	 divss	 xmm7, xmm2
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  000e5	f3 0f 10 51 14	 movss	 xmm2, DWORD PTR [ecx+20]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000ea	f3 0f 58 c8	 addss	 xmm1, xmm0
  000ee	f3 0f 10 41 18	 movss	 xmm0, DWORD PTR [ecx+24]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 369  : 	float t= - D3DXVec3Dot(&m_attribute.v3Normal, &(s.v3Position-m_attribute.v3Position))/d;

  000f3	0f 57 3d 00 00
	00 00		 xorps	 xmm7, DWORD PTR __xmm@80000000800000008000000080000000
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000fa	f3 0f 59 c6	 mulss	 xmm0, xmm6

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  000fe	f3 0f 59 e7	 mulss	 xmm4, xmm7

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00102	f3 0f 58 c8	 addss	 xmm1, xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00106	f3 0f 59 ef	 mulss	 xmm5, xmm7
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 376  : 		return t*advance -s.fRadius*m_attribute.v3Normal;

  0010a	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 180  :     x = fx;

  0010f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00112	f3 0f 59 f7	 mulss	 xmm6, xmm7
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 373  : 	if (D3DXVec3Dot(&m_attribute.v3Normal, &advance)>=0)

  00116	0f 2f 0d 00 00
	00 00		 comiss	 xmm1, DWORD PTR __real@00000000
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0011d	f3 0f 10 49 10	 movss	 xmm1, DWORD PTR [ecx+16]
  00122	f3 0f 59 d0	 mulss	 xmm2, xmm0
  00126	f3 0f 59 d8	 mulss	 xmm3, xmm0
  0012a	f3 0f 59 c8	 mulss	 xmm1, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 373  : 	if (D3DXVec3Dot(&m_attribute.v3Normal, &advance)>=0)

  0012e	72 1e		 jb	 SHORT $LN2@OnGetColli
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00130	f3 0f 5c e1	 subss	 xmm4, xmm1
  00134	f3 0f 5c ea	 subss	 xmm5, xmm2
  00138	f3 0f 5c f3	 subss	 xmm6, xmm3

; 180  :     x = fx;

  0013c	f3 0f 11 20	 movss	 DWORD PTR [eax], xmm4

; 181  :     y = fy;

  00140	f3 0f 11 68 04	 movss	 DWORD PTR [eax+4], xmm5

; 182  :     z = fz;

  00145	f3 0f 11 70 08	 movss	 DWORD PTR [eax+8], xmm6
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 426  : }

  0014a	5d		 pop	 ebp
  0014b	c2 08 00	 ret	 8
$LN2@OnGetColli:
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0014e	f3 0f 58 e1	 addss	 xmm4, xmm1
  00152	f3 0f 58 ea	 addss	 xmm5, xmm2
  00156	f3 0f 58 f3	 addss	 xmm6, xmm3

; 180  :     x = fx;

  0015a	f3 0f 11 20	 movss	 DWORD PTR [eax], xmm4

; 181  :     y = fy;

  0015e	f3 0f 11 68 04	 movss	 DWORD PTR [eax+4], xmm5

; 182  :     z = fz;

  00163	f3 0f 11 70 08	 movss	 DWORD PTR [eax+8], xmm6
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 426  : }

  00168	5d		 pop	 ebp
  00169	c2 08 00	 ret	 8
?OnGetCollisionMovementAdjust@CPlaneCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ENDP ; CPlaneCollisionInstance::OnGetCollisionMovementAdjust
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?OnCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_v3QuadPosition1$3$ = 8					; size = 4
_s$ = 8							; size = 4
?OnCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CPlaneCollisionInstance::OnCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 335  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00003	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00006	f3 0f 10 71 14	 movss	 xmm6, DWORD PTR [ecx+20]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0000b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00010	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00015	f3 0f 10 38	 movss	 xmm7, DWORD PTR [eax]
  00019	f3 0f 10 58 08	 movss	 xmm3, DWORD PTR [eax+8]
  0001e	0f 28 ef	 movaps	 xmm5, xmm7
  00021	f3 0f 5c 69 04	 subss	 xmm5, DWORD PTR [ecx+4]
  00026	f3 0f 5c 59 0c	 subss	 xmm3, DWORD PTR [ecx+12]
  0002b	f3 0f 10 48 10	 movss	 xmm1, DWORD PTR [eax+16]
  00030	f3 0f 10 60 0c	 movss	 xmm4, DWORD PTR [eax+12]
  00035	f3 0f 5c 49 08	 subss	 xmm1, DWORD PTR [ecx+8]
  0003a	f3 0f 5c 61 04	 subss	 xmm4, DWORD PTR [ecx+4]
  0003f	f3 0f 10 50 14	 movss	 xmm2, DWORD PTR [eax+20]
  00044	f3 0f 5c 51 0c	 subss	 xmm2, DWORD PTR [ecx+12]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00049	f3 0f 59 f0	 mulss	 xmm6, xmm0
  0004d	f3 0f 10 41 10	 movss	 xmm0, DWORD PTR [ecx+16]
  00052	f3 0f 59 c5	 mulss	 xmm0, xmm5
  00056	f3 0f 58 f0	 addss	 xmm6, xmm0
  0005a	f3 0f 10 41 18	 movss	 xmm0, DWORD PTR [ecx+24]
  0005f	f3 0f 59 c3	 mulss	 xmm0, xmm3
  00063	f3 0f 10 59 14	 movss	 xmm3, DWORD PTR [ecx+20]
  00068	f3 0f 59 d9	 mulss	 xmm3, xmm1
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 345  : 		|| (fPosition1) <= s.fRadius && fPosition1 >= -s.fRadius)

  0006c	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00074	f3 0f 58 f0	 addss	 xmm6, xmm0
  00078	f3 0f 10 41 10	 movss	 xmm0, DWORD PTR [ecx+16]
  0007d	f3 0f 59 c4	 mulss	 xmm0, xmm4
  00081	f3 0f 58 d8	 addss	 xmm3, xmm0
  00085	f3 0f 10 41 18	 movss	 xmm0, DWORD PTR [ecx+24]
  0008a	f3 0f 59 c2	 mulss	 xmm0, xmm2
  0008e	f3 0f 58 d8	 addss	 xmm3, xmm0
  00092	0f 57 c0	 xorps	 xmm0, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 345  : 		|| (fPosition1) <= s.fRadius && fPosition1 >= -s.fRadius)

  00095	0f 2f f0	 comiss	 xmm6, xmm0
  00098	76 05		 jbe	 SHORT $LN6@OnCollisio
  0009a	0f 2f c3	 comiss	 xmm0, xmm3
  0009d	77 24		 ja	 SHORT $LN7@OnCollisio
$LN6@OnCollisio:
  0009f	0f 2f c6	 comiss	 xmm0, xmm6
  000a2	76 05		 jbe	 SHORT $LN5@OnCollisio
  000a4	0f 2f d8	 comiss	 xmm3, xmm0
  000a7	77 1a		 ja	 SHORT $LN7@OnCollisio
$LN5@OnCollisio:
  000a9	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  000ae	0f 2f c6	 comiss	 xmm0, xmm6
  000b1	0f 82 ee 00 00
	00		 jb	 $LN1@OnCollisio
  000b7	0f 57 c1	 xorps	 xmm0, xmm1
  000ba	0f 2f f0	 comiss	 xmm6, xmm0
  000bd	0f 82 e2 00 00
	00		 jb	 $LN1@OnCollisio
$LN7@OnCollisio:
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000c3	f3 0f 10 68 08	 movss	 xmm5, DWORD PTR [eax+8]
  000c8	0f 28 df	 movaps	 xmm3, xmm7
  000cb	f3 0f 10 60 04	 movss	 xmm4, DWORD PTR [eax+4]
  000d0	0f 28 c5	 movaps	 xmm0, xmm5
  000d3	f3 0f 5c 41 24	 subss	 xmm0, DWORD PTR [ecx+36]
  000d8	f3 0f 5c 59 1c	 subss	 xmm3, DWORD PTR [ecx+28]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 350  : 		if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[0]) > - s.fRadius/*0.0f*/)

  000dd	f3 0f 10 50 18	 movss	 xmm2, DWORD PTR [eax+24]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000e2	0f 28 f4	 movaps	 xmm6, xmm4
  000e5	f3 0f 5c 71 20	 subss	 xmm6, DWORD PTR [ecx+32]
  000ea	f3 0f 5c 79 40	 subss	 xmm7, DWORD PTR [ecx+64]
  000ef	f3 0f 5c 61 44	 subss	 xmm4, DWORD PTR [ecx+68]
  000f4	f3 0f 5c 69 48	 subss	 xmm5, DWORD PTR [ecx+72]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 350  : 		if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[0]) > - s.fRadius/*0.0f*/)

  000f9	0f 57 d1	 xorps	 xmm2, xmm1
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000fc	f3 0f 11 45 08	 movss	 DWORD PTR _v3QuadPosition1$3$[ebp], xmm0

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00101	f3 0f 10 41 4c	 movss	 xmm0, DWORD PTR [ecx+76]
  00106	f3 0f 10 49 50	 movss	 xmm1, DWORD PTR [ecx+80]
  0010b	f3 0f 59 c3	 mulss	 xmm0, xmm3
  0010f	f3 0f 59 ce	 mulss	 xmm1, xmm6
  00113	f3 0f 58 c8	 addss	 xmm1, xmm0
  00117	f3 0f 10 41 54	 movss	 xmm0, DWORD PTR [ecx+84]
  0011c	f3 0f 59 45 08	 mulss	 xmm0, DWORD PTR _v3QuadPosition1$3$[ebp]
  00121	f3 0f 58 c8	 addss	 xmm1, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 350  : 		if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[0]) > - s.fRadius/*0.0f*/)

  00125	0f 2f ca	 comiss	 xmm1, xmm2
  00128	76 7b		 jbe	 SHORT $LN1@OnCollisio
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0012a	f3 0f 10 49 5c	 movss	 xmm1, DWORD PTR [ecx+92]
  0012f	f3 0f 59 59 58	 mulss	 xmm3, DWORD PTR [ecx+88]
  00134	f3 0f 10 41 60	 movss	 xmm0, DWORD PTR [ecx+96]
  00139	f3 0f 59 45 08	 mulss	 xmm0, DWORD PTR _v3QuadPosition1$3$[ebp]
  0013e	f3 0f 59 ce	 mulss	 xmm1, xmm6
  00142	f3 0f 58 cb	 addss	 xmm1, xmm3
  00146	f3 0f 58 c8	 addss	 xmm1, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 351  : 			if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[1]) > -s.fRadius/*0.0f*/)

  0014a	0f 2f ca	 comiss	 xmm1, xmm2
  0014d	76 56		 jbe	 SHORT $LN1@OnCollisio
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0014f	f3 0f 10 41 64	 movss	 xmm0, DWORD PTR [ecx+100]
  00154	f3 0f 10 49 68	 movss	 xmm1, DWORD PTR [ecx+104]
  00159	f3 0f 59 c7	 mulss	 xmm0, xmm7
  0015d	f3 0f 59 cc	 mulss	 xmm1, xmm4
  00161	f3 0f 58 c8	 addss	 xmm1, xmm0
  00165	f3 0f 10 41 6c	 movss	 xmm0, DWORD PTR [ecx+108]
  0016a	f3 0f 59 c5	 mulss	 xmm0, xmm5
  0016e	f3 0f 58 c8	 addss	 xmm1, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 352  : 				if (D3DXVec3Dot(&v3QuadPosition2, &m_attribute.v3InsideVector[2]) > - s.fRadius/*0.0f*/)

  00172	0f 2f ca	 comiss	 xmm1, xmm2
  00175	76 2e		 jbe	 SHORT $LN1@OnCollisio
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00177	f3 0f 10 41 70	 movss	 xmm0, DWORD PTR [ecx+112]
  0017c	f3 0f 10 49 74	 movss	 xmm1, DWORD PTR [ecx+116]
  00181	f3 0f 59 c7	 mulss	 xmm0, xmm7
  00185	f3 0f 59 cc	 mulss	 xmm1, xmm4
  00189	f3 0f 58 c8	 addss	 xmm1, xmm0
  0018d	f3 0f 10 41 78	 movss	 xmm0, DWORD PTR [ecx+120]
  00192	f3 0f 59 c5	 mulss	 xmm0, xmm5
  00196	f3 0f 58 c8	 addss	 xmm1, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 353  : 					if (D3DXVec3Dot(&v3QuadPosition2, &m_attribute.v3InsideVector[3]) > - s.fRadius/*0.0f*/)

  0019a	0f 2f ca	 comiss	 xmm1, xmm2
  0019d	76 06		 jbe	 SHORT $LN1@OnCollisio

; 354  : 					{
; 355  : 						return true;

  0019f	b0 01		 mov	 al, 1

; 360  : }

  001a1	5d		 pop	 ebp
  001a2	c2 04 00	 ret	 4
$LN1@OnCollisio:

; 356  : 					}
; 357  : 	}
; 358  : 	
; 359  : 	return false;

  001a5	32 c0		 xor	 al, al

; 360  : }

  001a7	5d		 pop	 ebp
  001a8	c2 04 00	 ret	 4
?OnCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CPlaneCollisionInstance::OnCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?OnMovementCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_v3QuadPosition1$3$ = 8					; size = 4
_s$ = 8							; size = 4
?OnMovementCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CPlaneCollisionInstance::OnMovementCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 306  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00003	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00006	f3 0f 10 71 14	 movss	 xmm6, DWORD PTR [ecx+20]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0000b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00010	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00015	f3 0f 10 38	 movss	 xmm7, DWORD PTR [eax]
  00019	f3 0f 10 58 08	 movss	 xmm3, DWORD PTR [eax+8]
  0001e	0f 28 ef	 movaps	 xmm5, xmm7
  00021	f3 0f 5c 69 04	 subss	 xmm5, DWORD PTR [ecx+4]
  00026	f3 0f 5c 59 0c	 subss	 xmm3, DWORD PTR [ecx+12]
  0002b	f3 0f 10 48 10	 movss	 xmm1, DWORD PTR [eax+16]
  00030	f3 0f 10 60 0c	 movss	 xmm4, DWORD PTR [eax+12]
  00035	f3 0f 5c 49 08	 subss	 xmm1, DWORD PTR [ecx+8]
  0003a	f3 0f 5c 61 04	 subss	 xmm4, DWORD PTR [ecx+4]
  0003f	f3 0f 10 50 14	 movss	 xmm2, DWORD PTR [eax+20]
  00044	f3 0f 5c 51 0c	 subss	 xmm2, DWORD PTR [ecx+12]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00049	f3 0f 59 f0	 mulss	 xmm6, xmm0
  0004d	f3 0f 10 41 10	 movss	 xmm0, DWORD PTR [ecx+16]
  00052	f3 0f 59 c5	 mulss	 xmm0, xmm5
  00056	f3 0f 58 f0	 addss	 xmm6, xmm0
  0005a	f3 0f 10 41 18	 movss	 xmm0, DWORD PTR [ecx+24]
  0005f	f3 0f 59 c3	 mulss	 xmm0, xmm3
  00063	f3 0f 10 59 14	 movss	 xmm3, DWORD PTR [ecx+20]
  00068	f3 0f 59 d9	 mulss	 xmm3, xmm1
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 314  : 		|| (fPosition1) <= s.fRadius && fPosition1 >= -s.fRadius)

  0006c	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00074	f3 0f 58 f0	 addss	 xmm6, xmm0
  00078	f3 0f 10 41 10	 movss	 xmm0, DWORD PTR [ecx+16]
  0007d	f3 0f 59 c4	 mulss	 xmm0, xmm4
  00081	f3 0f 58 d8	 addss	 xmm3, xmm0
  00085	f3 0f 10 41 18	 movss	 xmm0, DWORD PTR [ecx+24]
  0008a	f3 0f 59 c2	 mulss	 xmm0, xmm2
  0008e	f3 0f 58 d8	 addss	 xmm3, xmm0
  00092	0f 57 c0	 xorps	 xmm0, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 314  : 		|| (fPosition1) <= s.fRadius && fPosition1 >= -s.fRadius)

  00095	0f 2f f0	 comiss	 xmm6, xmm0
  00098	76 05		 jbe	 SHORT $LN7@OnMovement
  0009a	0f 2f c3	 comiss	 xmm0, xmm3
  0009d	77 24		 ja	 SHORT $LN8@OnMovement
$LN7@OnMovement:
  0009f	0f 2f c6	 comiss	 xmm0, xmm6
  000a2	76 05		 jbe	 SHORT $LN6@OnMovement
  000a4	0f 2f d8	 comiss	 xmm3, xmm0
  000a7	77 1a		 ja	 SHORT $LN8@OnMovement
$LN6@OnMovement:
  000a9	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  000ae	0f 2f c6	 comiss	 xmm0, xmm6
  000b1	0f 82 a5 01 00
	00		 jb	 $LN1@OnMovement
  000b7	0f 57 c1	 xorps	 xmm0, xmm1
  000ba	0f 2f f0	 comiss	 xmm6, xmm0
  000bd	0f 82 99 01 00
	00		 jb	 $LN1@OnMovement
$LN8@OnMovement:
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000c3	f3 0f 10 68 08	 movss	 xmm5, DWORD PTR [eax+8]
  000c8	0f 28 f7	 movaps	 xmm6, xmm7
  000cb	f3 0f 10 60 04	 movss	 xmm4, DWORD PTR [eax+4]
  000d0	0f 28 c5	 movaps	 xmm0, xmm5
  000d3	f3 0f 5c 41 24	 subss	 xmm0, DWORD PTR [ecx+36]
  000d8	f3 0f 5c 71 1c	 subss	 xmm6, DWORD PTR [ecx+28]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 319  : 		if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[0]) > - s.fRadius/*0.0f*/)

  000dd	f3 0f 10 58 18	 movss	 xmm3, DWORD PTR [eax+24]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000e2	0f 28 fc	 movaps	 xmm7, xmm4
  000e5	f3 0f 5c 79 20	 subss	 xmm7, DWORD PTR [ecx+32]
  000ea	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 319  : 		if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[0]) > - s.fRadius/*0.0f*/)

  000ee	0f 57 d9	 xorps	 xmm3, xmm1
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000f1	f3 0f 10 49 50	 movss	 xmm1, DWORD PTR [ecx+80]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000f6	f3 0f 5c 51 40	 subss	 xmm2, DWORD PTR [ecx+64]
  000fb	f3 0f 5c 61 44	 subss	 xmm4, DWORD PTR [ecx+68]
  00100	f3 0f 5c 69 48	 subss	 xmm5, DWORD PTR [ecx+72]
  00105	f3 0f 11 45 08	 movss	 DWORD PTR _v3QuadPosition1$3$[ebp], xmm0

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0010a	0f 28 c6	 movaps	 xmm0, xmm6
  0010d	f3 0f 59 41 4c	 mulss	 xmm0, DWORD PTR [ecx+76]
  00112	f3 0f 59 cf	 mulss	 xmm1, xmm7
  00116	f3 0f 58 c8	 addss	 xmm1, xmm0
  0011a	f3 0f 10 41 54	 movss	 xmm0, DWORD PTR [ecx+84]
  0011f	f3 0f 59 45 08	 mulss	 xmm0, DWORD PTR _v3QuadPosition1$3$[ebp]
  00124	f3 0f 58 c8	 addss	 xmm1, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 319  : 		if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[0]) > - s.fRadius/*0.0f*/)

  00128	0f 2f cb	 comiss	 xmm1, xmm3
  0012b	0f 86 2b 01 00
	00		 jbe	 $LN1@OnMovement
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00131	f3 0f 10 41 58	 movss	 xmm0, DWORD PTR [ecx+88]
  00136	f3 0f 10 49 5c	 movss	 xmm1, DWORD PTR [ecx+92]
  0013b	f3 0f 59 c6	 mulss	 xmm0, xmm6
  0013f	f3 0f 59 cf	 mulss	 xmm1, xmm7
  00143	f3 0f 58 c8	 addss	 xmm1, xmm0
  00147	f3 0f 10 41 60	 movss	 xmm0, DWORD PTR [ecx+96]
  0014c	f3 0f 59 45 08	 mulss	 xmm0, DWORD PTR _v3QuadPosition1$3$[ebp]
  00151	f3 0f 58 c8	 addss	 xmm1, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 320  : 			if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[1]) > -s.fRadius/*0.0f*/)

  00155	0f 2f cb	 comiss	 xmm1, xmm3
  00158	0f 86 fe 00 00
	00		 jbe	 $LN1@OnMovement
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0015e	f3 0f 10 41 64	 movss	 xmm0, DWORD PTR [ecx+100]
  00163	f3 0f 10 49 68	 movss	 xmm1, DWORD PTR [ecx+104]
  00168	f3 0f 59 c2	 mulss	 xmm0, xmm2
  0016c	f3 0f 59 cc	 mulss	 xmm1, xmm4
  00170	f3 0f 58 c8	 addss	 xmm1, xmm0
  00174	f3 0f 10 41 6c	 movss	 xmm0, DWORD PTR [ecx+108]
  00179	f3 0f 59 c5	 mulss	 xmm0, xmm5
  0017d	f3 0f 58 c8	 addss	 xmm1, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 321  : 				if (D3DXVec3Dot(&v3QuadPosition2, &m_attribute.v3InsideVector[2]) > - s.fRadius/*0.0f*/)

  00181	0f 2f cb	 comiss	 xmm1, xmm3
  00184	0f 86 d2 00 00
	00		 jbe	 $LN1@OnMovement
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0018a	f3 0f 10 49 74	 movss	 xmm1, DWORD PTR [ecx+116]
  0018f	f3 0f 59 51 70	 mulss	 xmm2, DWORD PTR [ecx+112]
  00194	f3 0f 10 41 78	 movss	 xmm0, DWORD PTR [ecx+120]
  00199	f3 0f 59 cc	 mulss	 xmm1, xmm4
  0019d	f3 0f 59 c5	 mulss	 xmm0, xmm5
  001a1	f3 0f 58 ca	 addss	 xmm1, xmm2
  001a5	f3 0f 58 c8	 addss	 xmm1, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 322  : 					if (D3DXVec3Dot(&v3QuadPosition2, &m_attribute.v3InsideVector[3]) > - s.fRadius/*0.0f*/)

  001a9	0f 2f cb	 comiss	 xmm1, xmm3
  001ac	0f 86 aa 00 00
	00		 jbe	 $LN1@OnMovement
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001b2	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001b7	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  001bc	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  001c0	f3 0f 5c 51 04	 subss	 xmm2, DWORD PTR [ecx+4]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  001c5	f3 0f 10 49 14	 movss	 xmm1, DWORD PTR [ecx+20]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001ca	f3 0f 10 58 08	 movss	 xmm3, DWORD PTR [eax+8]
  001cf	f3 0f 5c 59 0c	 subss	 xmm3, DWORD PTR [ecx+12]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  001d4	f3 0f 59 c8	 mulss	 xmm1, xmm0
  001d8	f3 0f 10 41 10	 movss	 xmm0, DWORD PTR [ecx+16]
  001dd	f3 0f 59 c2	 mulss	 xmm0, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001e1	f3 0f 10 70 0c	 movss	 xmm6, DWORD PTR [eax+12]
  001e6	f3 0f 10 60 10	 movss	 xmm4, DWORD PTR [eax+16]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  001eb	f3 0f 58 c8	 addss	 xmm1, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001ef	f3 0f 10 68 14	 movss	 xmm5, DWORD PTR [eax+20]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  001f4	f3 0f 10 41 18	 movss	 xmm0, DWORD PTR [ecx+24]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001f9	f3 0f 5c 71 04	 subss	 xmm6, DWORD PTR [ecx+4]
  001fe	f3 0f 5c 61 08	 subss	 xmm4, DWORD PTR [ecx+8]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00203	f3 0f 59 c3	 mulss	 xmm0, xmm3

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00207	f3 0f 5c 69 0c	 subss	 xmm5, DWORD PTR [ecx+12]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0020c	f3 0f 58 c8	 addss	 xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

  00210	0f 5a c1	 cvtps2pd xmm0, xmm1
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00213	f3 0f 10 49 14	 movss	 xmm1, DWORD PTR [ecx+20]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

  00218	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00220	66 0f 5a d8	 cvtpd2ps xmm3, xmm0
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00224	f3 0f 10 41 10	 movss	 xmm0, DWORD PTR [ecx+16]
  00229	f3 0f 59 c6	 mulss	 xmm0, xmm6
  0022d	f3 0f 59 cc	 mulss	 xmm1, xmm4
  00231	f3 0f 58 c8	 addss	 xmm1, xmm0
  00235	f3 0f 10 41 18	 movss	 xmm0, DWORD PTR [ecx+24]
  0023a	f3 0f 59 c5	 mulss	 xmm0, xmm5
  0023e	f3 0f 58 c8	 addss	 xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

  00242	0f 5a c1	 cvtps2pd xmm0, xmm1
  00245	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  0024d	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 326  : 							fabs(D3DXVec3Dot(&(s.v3LastPosition - m_attribute.v3Position), &m_attribute.v3Normal)))

  00251	0f 2f c3	 comiss	 xmm0, xmm3
  00254	76 06		 jbe	 SHORT $LN1@OnMovement

; 327  : 							return true;

  00256	b0 01		 mov	 al, 1

; 332  : }

  00258	5d		 pop	 ebp
  00259	c2 04 00	 ret	 4
$LN1@OnMovement:

; 328  : 					}
; 329  : 	}
; 330  : 
; 331  : 	return false;

  0025c	32 c0		 xor	 al, al

; 332  : }

  0025e	5d		 pop	 ebp
  0025f	c2 04 00	 ret	 4
?OnMovementCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CPlaneCollisionInstance::OnMovementCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?OnDestroy@CPlaneCollisionInstance@@MAEXXZ
_TEXT	SEGMENT
_pkData$ = -4						; size = 4
?OnDestroy@CPlaneCollisionInstance@@MAEXXZ PROC		; CPlaneCollisionInstance::OnDestroy, COMDAT
; _this$ = ecx

; 435  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 81   : 			m_kVct_pkFree.push_back(pkData);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _pkData$[ebp]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 436  : 	gs_pci.Free(this);

  00007	89 4d fc	 mov	 DWORD PTR _pkData$[ebp], ecx
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 81   : 			m_kVct_pkFree.push_back(pkData);

  0000a	50		 push	 eax
  0000b	b9 10 00 00 00	 mov	 ecx, OFFSET ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+16
  00010	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXABQAVCPlaneCollisionInstance@@@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::push_back
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 437  : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?OnDestroy@CPlaneCollisionInstance@@MAEXXZ ENDP		; CPlaneCollisionInstance::OnDestroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z PROC ; CPlaneCollisionInstance::Render, COMDAT
; _this$ = ecx

; 429  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 430  : 	static CScreen s;

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S2@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA
  0002a	a8 01		 test	 al, 1
  0002c	75 2d		 jne	 SHORT $LN1@Render
  0002e	83 c8 01	 or	 eax, 1
  00031	a3 00 00 00 00	 mov	 DWORD PTR ?$S2@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA, eax
  00036	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00042	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  00047	68 00 00 00 00	 push	 OFFSET ??__Fs@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ; `CPlaneCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
  0004c	e8 00 00 00 00	 call	 _atexit
  00051	83 c4 04	 add	 esp, 4
  00054	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
$LN1@Render:

; 431  : 	s.RenderBar3d(m_attribute.v3QuadPosition);

  0005b	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  0005e	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ?RenderBar3d@CScreen@@QAEXPBUD3DXVECTOR3@@@Z ; CScreen::RenderBar3d

; 432  : }

  00069	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00073	59		 pop	 ecx
  00074	5e		 pop	 esi
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0:
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S2@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA
  00005	83 e0 fe	 and	 eax, -2			; fffffffeH
  00008	a3 00 00 00 00	 mov	 DWORD PTR ?$S2@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA, eax
  0000d	c3		 ret	 0
__ehhandler$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ENDP ; CPlaneCollisionInstance::Render
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?GetAttribute@CPlaneCollisionInstance@@QBEABUSPlaneData@@XZ
_TEXT	SEGMENT
?GetAttribute@CPlaneCollisionInstance@@QBEABUSPlaneData@@XZ PROC ; CPlaneCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 302  : 	return m_attribute;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 303  : }

  00003	c3		 ret	 0
?GetAttribute@CPlaneCollisionInstance@@QBEABUSPlaneData@@XZ ENDP ; CPlaneCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?GetAttribute@CPlaneCollisionInstance@@QAEAAUSPlaneData@@XZ
_TEXT	SEGMENT
?GetAttribute@CPlaneCollisionInstance@@QAEAAUSPlaneData@@XZ PROC ; CPlaneCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 297  : 	return m_attribute;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 298  : }

  00003	c3		 ret	 0
?GetAttribute@CPlaneCollisionInstance@@QAEAAUSPlaneData@@XZ ENDP ; CPlaneCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0CSphereCollisionInstance@@QAE@XZ
_TEXT	SEGMENT
??0CSphereCollisionInstance@@QAE@XZ PROC		; CSphereCollisionInstance::CSphereCollisionInstance, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CSphereCollisionInstance@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0CSphereCollisionInstance@@QAE@XZ ENDP		; CSphereCollisionInstance::CSphereCollisionInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?OnGetCollisionMovementAdjust@CSphereCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_v$1$ = -16						; size = 4
_v$2$ = -12						; size = 4
_v$3$ = -8						; size = 4
_sum$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
?OnGetCollisionMovementAdjust@CSphereCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z PROC ; CSphereCollisionInstance::OnGetCollisionMovementAdjust, COMDAT
; _this$ = ecx

; 255  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 255  : {

  00009	83 ec 10	 sub	 esp, 16			; 00000010H
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0000c	f3 0f 10 38	 movss	 xmm7, DWORD PTR [eax]
  00010	f3 0f 10 70 04	 movss	 xmm6, DWORD PTR [eax+4]
  00015	0f 28 d7	 movaps	 xmm2, xmm7
  00018	f3 0f 5c 51 04	 subss	 xmm2, DWORD PTR [ecx+4]
  0001d	f3 0f 10 60 08	 movss	 xmm4, DWORD PTR [eax+8]
  00022	0f 28 ce	 movaps	 xmm1, xmm6
  00025	f3 0f 5c 49 08	 subss	 xmm1, DWORD PTR [ecx+8]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 256  : 	if (D3DXVec3LengthSq(&(s.v3Position-m_attribute.v3Position))>=(s.fRadius+m_attribute.fRadius)*(m_attribute.fRadius+s.fRadius))

  0002a	f3 0f 10 58 18	 movss	 xmm3, DWORD PTR [eax+24]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0002f	0f 28 c4	 movaps	 xmm0, xmm4
  00032	f3 0f 5c 41 0c	 subss	 xmm0, DWORD PTR [ecx+12]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 256  : 	if (D3DXVec3LengthSq(&(s.v3Position-m_attribute.v3Position))>=(s.fRadius+m_attribute.fRadius)*(m_attribute.fRadius+s.fRadius))

  00037	f3 0f 58 59 10	 addss	 xmm3, DWORD PTR [ecx+16]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0003c	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00040	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00044	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00048	f3 0f 58 ca	 addss	 xmm1, xmm2
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 256  : 	if (D3DXVec3LengthSq(&(s.v3Position-m_attribute.v3Position))>=(s.fRadius+m_attribute.fRadius)*(m_attribute.fRadius+s.fRadius))

  0004c	f3 0f 59 db	 mulss	 xmm3, xmm3
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00050	f3 0f 58 c8	 addss	 xmm1, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 256  : 	if (D3DXVec3LengthSq(&(s.v3Position-m_attribute.v3Position))>=(s.fRadius+m_attribute.fRadius)*(m_attribute.fRadius+s.fRadius))

  00054	0f 2f cb	 comiss	 xmm1, xmm3
  00057	72 1d		 jb	 SHORT $LN4@OnGetColli
$LN62@OnGetColli:
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 180  :     x = fx;

  00059	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 181  :     y = fy;

  00062	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 182  :     z = fz;

  00069	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 291  : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 08 00	 ret	 8
$LN4@OnGetColli:
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00076	f3 0f 5c 60 14	 subss	 xmm4, DWORD PTR [eax+20]
  0007b	0f 28 c6	 movaps	 xmm0, xmm6
  0007e	0f 57 d2	 xorps	 xmm2, xmm2
  00081	f3 0f 5c 40 10	 subss	 xmm0, DWORD PTR [eax+16]
  00086	f3 0f 5c 71 08	 subss	 xmm6, DWORD PTR [ecx+8]
  0008b	0f 28 ef	 movaps	 xmm5, xmm7
  0008e	f3 0f 5c 68 0c	 subss	 xmm5, DWORD PTR [eax+12]

; 1265 : }
; 1266 : 
; 1267 : D3DXINLINE D3DXVECTOR3* D3DXVec3Cross
; 1268 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1269 : {
; 1270 :     D3DXVECTOR3 v;
; 1271 : 
; 1272 : #ifdef D3DX_DEBUG
; 1273 :     if(!pOut || !pV1 || !pV2)
; 1274 :         return NULL;
; 1275 : #endif
; 1276 : 
; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00093	f3 0f 59 e2	 mulss	 xmm4, xmm2
  00097	0f 28 c8	 movaps	 xmm1, xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  0009a	f3 0f 59 c2	 mulss	 xmm0, xmm2
  0009e	f3 0f 5c cc	 subss	 xmm1, xmm4
  000a2	f3 0f 5c e5	 subss	 xmm4, xmm5
  000a6	f3 0f 59 ea	 mulss	 xmm5, xmm2
  000aa	f3 0f 11 0c 24	 movss	 DWORD PTR _v$1$[esp+16], xmm1
  000af	f3 0f 5c e8	 subss	 xmm5, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000b3	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000b8	0f 28 cf	 movaps	 xmm1, xmm7
  000bb	f3 0f 5c 49 04	 subss	 xmm1, DWORD PTR [ecx+4]
  000c0	f3 0f 5c 41 0c	 subss	 xmm0, DWORD PTR [ecx+12]
  000c5	f3 0f 5c 79 04	 subss	 xmm7, DWORD PTR [ecx+4]

; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000ca	f3 0f 59 f4	 mulss	 xmm6, xmm4
  000ce	f3 0f 59 0c 24	 mulss	 xmm1, DWORD PTR _v$1$[esp+16]
  000d3	f3 0f 59 c5	 mulss	 xmm0, xmm5
  000d7	f3 0f 58 f1	 addss	 xmm6, xmm1

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000db	f3 0f 59 ff	 mulss	 xmm7, xmm7

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000df	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  000e4	f3 0f 5c 49 0c	 subss	 xmm1, DWORD PTR [ecx+12]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  000e9	f3 0f 11 64 24
	04		 movss	 DWORD PTR _v$2$[esp+16], xmm4

; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000ef	f3 0f 58 f0	 addss	 xmm6, xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  000f3	f3 0f 11 6c 24
	08		 movss	 DWORD PTR _v$3$[esp+16], xmm5

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000f9	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000fe	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00103	f3 0f 59 c9	 mulss	 xmm1, xmm1
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 261  : 	float sum = - D3DXVec3Dot(&c,&(s.v3Position-m_attribute.v3Position));

  00107	0f 57 35 00 00
	00 00		 xorps	 xmm6, DWORD PTR __xmm@80000000800000008000000080000000
  0010e	f3 0f 11 74 24
	0c		 movss	 DWORD PTR _sum$1$[esp+16], xmm6
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00114	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00118	f3 0f 58 f8	 addss	 xmm7, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 264  : 	if (sum*sum-4*mul<=0)

  0011c	0f 28 c6	 movaps	 xmm0, xmm6
  0011f	f3 0f 59 c6	 mulss	 xmm0, xmm6
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00123	f3 0f 58 f9	 addss	 xmm7, xmm1
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 262  : 	float mul = (s.fRadius+m_attribute.fRadius)*(s.fRadius+m_attribute.fRadius)-D3DXVec3LengthSq(&(s.v3Position-m_attribute.v3Position));

  00127	f3 0f 5c df	 subss	 xmm3, xmm7

; 264  : 	if (sum*sum-4*mul<=0)

  0012b	f3 0f 59 1d 00
	00 00 00	 mulss	 xmm3, DWORD PTR __real@40800000
  00133	f3 0f 5c c3	 subss	 xmm0, xmm3
  00137	0f 2f d0	 comiss	 xmm2, xmm0
  0013a	0f 83 19 ff ff
	ff		 jae	 $LN62@OnGetColli
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  00140	0f 5a c0	 cvtps2pd xmm0, xmm0
  00143	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 267  : 	float t1=-sum-sq, t2=-sum+sq;

  00148	f3 0f 10 5c 24
	0c		 movss	 xmm3, DWORD PTR _sum$1$[esp+16]
  0014e	0f 57 e4	 xorps	 xmm4, xmm4
  00151	0f 57 1d 00 00
	00 00		 xorps	 xmm3, DWORD PTR __xmm@80000000800000008000000080000000

; 268  : 	t1*=0.5f;

  00158	f3 0f 10 2d 00
	00 00 00	 movss	 xmm5, DWORD PTR __real@3f000000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  00160	f2 0f 5a e0	 cvtsd2ss xmm4, xmm0
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 180  :     x = fx;

  00164	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00167	0f 57 c0	 xorps	 xmm0, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 267  : 	float t1=-sum-sq, t2=-sum+sq;

  0016a	f3 0f 5c dc	 subss	 xmm3, xmm4
  0016e	f3 0f 5c 64 24
	0c		 subss	 xmm4, DWORD PTR _sum$1$[esp+16]

; 268  : 	t1*=0.5f;

  00174	f3 0f 59 dd	 mulss	 xmm3, xmm5

; 269  : 	t2*=0.5f;

  00178	f3 0f 59 e5	 mulss	 xmm4, xmm5
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

  0017c	f3 0f 5a c3	 cvtss2sd xmm0, xmm3
  00180	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00188	66 0f 5a d0	 cvtpd2ps xmm2, xmm0
  0018c	0f 5a c4	 cvtps2pd xmm0, xmm4
  0018f	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00197	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 271  : 	if (fabs(t1)<=fabs(t2))

  0019b	0f 2f c2	 comiss	 xmm0, xmm2
  0019e	72 2f		 jb	 SHORT $LN2@OnGetColli

; 272  : 	{
; 273  : 		return (gc_fReduceMove*t1)*c;

  001a0	f3 0f 59 dd	 mulss	 xmm3, xmm5
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001a4	0f 28 c3	 movaps	 xmm0, xmm3
  001a7	f3 0f 59 04 24	 mulss	 xmm0, DWORD PTR _v$1$[esp+16]

; 180  :     x = fx;

  001ac	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001b0	0f 28 c3	 movaps	 xmm0, xmm3
  001b3	f3 0f 59 5c 24
	08		 mulss	 xmm3, DWORD PTR _v$3$[esp+16]
  001b9	f3 0f 59 44 24
	04		 mulss	 xmm0, DWORD PTR _v$2$[esp+16]

; 182  :     z = fz;

  001bf	f3 0f 11 58 08	 movss	 DWORD PTR [eax+8], xmm3

; 181  :     y = fy;

  001c4	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 291  : }

  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c2 08 00	 ret	 8
$LN2@OnGetColli:

; 274  : 	}
; 275  : 	else
; 276  : 		return (gc_fReduceMove*t2)*c;

  001cf	f3 0f 59 e5	 mulss	 xmm4, xmm5
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001d3	0f 28 c4	 movaps	 xmm0, xmm4
  001d6	f3 0f 59 04 24	 mulss	 xmm0, DWORD PTR _v$1$[esp+16]

; 180  :     x = fx;

  001db	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001df	0f 28 c4	 movaps	 xmm0, xmm4
  001e2	f3 0f 59 64 24
	08		 mulss	 xmm4, DWORD PTR _v$3$[esp+16]
  001e8	f3 0f 59 44 24
	04		 mulss	 xmm0, DWORD PTR _v$2$[esp+16]

; 182  :     z = fz;

  001ee	f3 0f 11 60 08	 movss	 DWORD PTR [eax+8], xmm4
  001f3	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 291  : }

  001f8	8b e5		 mov	 esp, ebp
  001fa	5d		 pop	 ebp
  001fb	c2 08 00	 ret	 8
?OnGetCollisionMovementAdjust@CSphereCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ENDP ; CSphereCollisionInstance::OnGetCollisionMovementAdjust
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?OnCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_l$1$ = -8						; size = 4
$T1 = -4						; size = 4
$T2 = 8							; size = 4
_s$ = 8							; size = 4
?OnCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CSphereCollisionInstance::OnCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 246  : 	if (square_distance_between_linesegment_and_point(s.v3LastPosition,s.v3Position,m_attribute.v3Position)<(m_attribute.fRadius+s.fRadius)*(m_attribute.fRadius+s.fRadius))

  00006	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00009	f3 0f 10 59 08	 movss	 xmm3, DWORD PTR [ecx+8]
  0000e	f3 0f 10 51 0c	 movss	 xmm2, DWORD PTR [ecx+12]
  00013	0f 28 fa	 movaps	 xmm7, xmm2
  00016	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0001a	f3 0f 5c 40 0c	 subss	 xmm0, DWORD PTR [eax+12]
  0001f	f3 0f 10 60 04	 movss	 xmm4, DWORD PTR [eax+4]
  00024	f3 0f 5c 60 10	 subss	 xmm4, DWORD PTR [eax+16]
  00029	f3 0f 10 68 08	 movss	 xmm5, DWORD PTR [eax+8]
  0002e	f3 0f 5c 68 14	 subss	 xmm5, DWORD PTR [eax+20]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00033	0f 28 f0	 movaps	 xmm6, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00036	f3 0f 11 45 fc	 movss	 DWORD PTR $T1[ebp], xmm0

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0003b	f3 0f 59 f0	 mulss	 xmm6, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0003f	f3 0f 5c 58 10	 subss	 xmm3, DWORD PTR [eax+16]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00044	0f 28 c4	 movaps	 xmm0, xmm4

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00047	f3 0f 11 6d 08	 movss	 DWORD PTR $T2[ebp], xmm5

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0004c	f3 0f 59 c4	 mulss	 xmm0, xmm4

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00050	f3 0f 5c 78 14	 subss	 xmm7, DWORD PTR [eax+20]

; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00055	0f 28 cb	 movaps	 xmm1, xmm3

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00058	f3 0f 58 f0	 addss	 xmm6, xmm0

; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0005c	f3 0f 59 cc	 mulss	 xmm1, xmm4

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00060	0f 28 c5	 movaps	 xmm0, xmm5
  00063	f3 0f 59 c5	 mulss	 xmm0, xmm5

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00067	f3 0f 10 69 04	 movss	 xmm5, DWORD PTR [ecx+4]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0006c	f3 0f 58 f0	 addss	 xmm6, xmm0
  00070	f3 0f 11 75 f8	 movss	 DWORD PTR _l$1$[ebp], xmm6

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00075	0f 28 f5	 movaps	 xmm6, xmm5
  00078	f3 0f 5c 70 0c	 subss	 xmm6, DWORD PTR [eax+12]

; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0007d	0f 28 c6	 movaps	 xmm0, xmm6
  00080	f3 0f 59 45 fc	 mulss	 xmm0, DWORD PTR $T1[ebp]
  00085	f3 0f 58 c8	 addss	 xmm1, xmm0
  00089	0f 28 c7	 movaps	 xmm0, xmm7
  0008c	f3 0f 59 45 08	 mulss	 xmm0, DWORD PTR $T2[ebp]
  00091	f3 0f 58 c8	 addss	 xmm1, xmm0
  00095	0f 57 c0	 xorps	 xmm0, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 84   : 	if (d<=0.0f)

  00098	0f 2f c1	 comiss	 xmm0, xmm1
  0009b	72 16		 jb	 SHORT $LN7@OnCollisio
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0009d	f3 0f 59 db	 mulss	 xmm3, xmm3
  000a1	f3 0f 59 f6	 mulss	 xmm6, xmm6
  000a5	f3 0f 59 ff	 mulss	 xmm7, xmm7
  000a9	f3 0f 58 de	 addss	 xmm3, xmm6
  000ad	f3 0f 58 df	 addss	 xmm3, xmm7
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 86   : 		return D3DXVec3LengthSq(&(x-p1));

  000b1	eb 7f		 jmp	 SHORT $LN4@OnCollisio
$LN7@OnCollisio:

; 87   : 	}
; 88   : 	else if (d>=l)

  000b3	0f 2f 4d f8	 comiss	 xmm1, DWORD PTR _l$1$[ebp]
  000b7	72 29		 jb	 SHORT $LN5@OnCollisio
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000b9	f3 0f 10 59 08	 movss	 xmm3, DWORD PTR [ecx+8]
  000be	f3 0f 5c 58 04	 subss	 xmm3, DWORD PTR [eax+4]
  000c3	f3 0f 5c 28	 subss	 xmm5, DWORD PTR [eax]
  000c7	f3 0f 5c 50 08	 subss	 xmm2, DWORD PTR [eax+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000cc	f3 0f 59 db	 mulss	 xmm3, xmm3
  000d0	f3 0f 59 ed	 mulss	 xmm5, xmm5
  000d4	f3 0f 59 d2	 mulss	 xmm2, xmm2
  000d8	f3 0f 58 dd	 addss	 xmm3, xmm5
  000dc	f3 0f 58 da	 addss	 xmm3, xmm2
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 90   : 		return D3DXVec3LengthSq(&(x-p2));

  000e0	eb 50		 jmp	 SHORT $LN4@OnCollisio
$LN5@OnCollisio:
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  000e2	f3 0f 10 6d 08	 movss	 xmm5, DWORD PTR $T2[ebp]

; 181  :     y = fy;

  000e7	0f 28 cb	 movaps	 xmm1, xmm3

; 182  :     z = fz;

  000ea	0f 28 df	 movaps	 xmm3, xmm7

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  000ed	0f 28 d1	 movaps	 xmm2, xmm1

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;
; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  000f0	f3 0f 59 4d fc	 mulss	 xmm1, DWORD PTR $T1[ebp]
  000f5	0f 28 c3	 movaps	 xmm0, xmm3
  000f8	f3 0f 59 5d fc	 mulss	 xmm3, DWORD PTR $T1[ebp]
  000fd	f3 0f 59 d5	 mulss	 xmm2, xmm5
  00101	f3 0f 59 c4	 mulss	 xmm0, xmm4
  00105	f3 0f 59 ee	 mulss	 xmm5, xmm6
  00109	f3 0f 5c d0	 subss	 xmm2, xmm0
  0010d	f3 0f 59 e6	 mulss	 xmm4, xmm6
  00111	f3 0f 5c dd	 subss	 xmm3, xmm5
  00115	f3 0f 5c e1	 subss	 xmm4, xmm1

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00119	f3 0f 59 d2	 mulss	 xmm2, xmm2
  0011d	f3 0f 59 db	 mulss	 xmm3, xmm3
  00121	f3 0f 59 e4	 mulss	 xmm4, xmm4
  00125	f3 0f 58 da	 addss	 xmm3, xmm2
  00129	f3 0f 58 dc	 addss	 xmm3, xmm4
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 95   : 		return D3DXVec3LengthSq(D3DXVec3Cross(&c,&(x-p1),&(p2-p1)))/l;

  0012d	f3 0f 5e 5d f8	 divss	 xmm3, DWORD PTR _l$1$[ebp]
$LN4@OnCollisio:
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 246  : 	if (square_distance_between_linesegment_and_point(s.v3LastPosition,s.v3Position,m_attribute.v3Position)<(m_attribute.fRadius+s.fRadius)*(m_attribute.fRadius+s.fRadius))

  00132	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00137	f3 0f 58 41 10	 addss	 xmm0, DWORD PTR [ecx+16]
  0013c	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00140	0f 2f c3	 comiss	 xmm0, xmm3
  00143	0f 97 c0	 seta	 al

; 247  : 	{
; 248  : 		return true;
; 249  : 	}
; 250  : 	
; 251  : 	return false;
; 252  : }

  00146	8b e5		 mov	 esp, ebp
  00148	5d		 pop	 ebp
  00149	c2 04 00	 ret	 4
?OnCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CSphereCollisionInstance::OnCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?OnMovementCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_d$1$ = -8						; size = 4
$T4 = -4						; size = 4
_l$1$ = 8						; size = 4
_s$ = 8							; size = 4
?OnMovementCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CSphereCollisionInstance::OnMovementCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 230  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 231  : 	if (square_distance_between_linesegment_and_point(s.v3LastPosition,s.v3Position,m_attribute.v3Position) < (m_attribute.fRadius+s.fRadius)*(m_attribute.fRadius+s.fRadius))

  00006	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00009	f3 0f 10 51 0c	 movss	 xmm2, DWORD PTR [ecx+12]
  0000e	f3 0f 10 59 08	 movss	 xmm3, DWORD PTR [ecx+8]
  00013	f3 0f 10 20	 movss	 xmm4, DWORD PTR [eax]
  00017	f3 0f 10 68 04	 movss	 xmm5, DWORD PTR [eax+4]
  0001c	0f 28 c4	 movaps	 xmm0, xmm4
  0001f	f3 0f 5c 40 0c	 subss	 xmm0, DWORD PTR [eax+12]
  00024	f3 0f 10 70 08	 movss	 xmm6, DWORD PTR [eax+8]
  00029	0f 28 fd	 movaps	 xmm7, xmm5
  0002c	f3 0f 5c 78 10	 subss	 xmm7, DWORD PTR [eax+16]
  00031	f3 0f 5c 70 14	 subss	 xmm6, DWORD PTR [eax+20]
  00036	f3 0f 5c 58 10	 subss	 xmm3, DWORD PTR [eax+16]
  0003b	f3 0f 11 45 fc	 movss	 DWORD PTR $T4[ebp], xmm0

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00040	0f 28 c7	 movaps	 xmm0, xmm7
  00043	f3 0f 59 c7	 mulss	 xmm0, xmm7

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00047	f3 0f 11 75 f0	 movss	 DWORD PTR $T2[ebp], xmm6

; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0004c	0f 28 cb	 movaps	 xmm1, xmm3
  0004f	f3 0f 59 cf	 mulss	 xmm1, xmm7

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00053	f3 0f 11 45 08	 movss	 DWORD PTR _l$1$[ebp], xmm0
  00058	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR $T4[ebp]
  0005d	f3 0f 10 75 08	 movss	 xmm6, DWORD PTR _l$1$[ebp]
  00062	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00066	f3 0f 58 f0	 addss	 xmm6, xmm0
  0006a	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR $T2[ebp]
  0006f	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00073	f3 0f 58 f0	 addss	 xmm6, xmm0
  00077	f3 0f 11 75 08	 movss	 DWORD PTR _l$1$[ebp], xmm6

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0007c	f3 0f 10 71 04	 movss	 xmm6, DWORD PTR [ecx+4]
  00081	0f 28 c6	 movaps	 xmm0, xmm6
  00084	f3 0f 5c 40 0c	 subss	 xmm0, DWORD PTR [eax+12]
  00089	f3 0f 11 45 ec	 movss	 DWORD PTR $T1[ebp], xmm0
  0008e	0f 28 c2	 movaps	 xmm0, xmm2
  00091	f3 0f 5c 40 14	 subss	 xmm0, DWORD PTR [eax+20]
  00096	f3 0f 11 45 f4	 movss	 DWORD PTR $T3[ebp], xmm0

; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0009b	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR $T1[ebp]
  000a0	f3 0f 59 45 fc	 mulss	 xmm0, DWORD PTR $T4[ebp]
  000a5	f3 0f 58 c8	 addss	 xmm1, xmm0
  000a9	f3 0f 11 4d f8	 movss	 DWORD PTR _d$1$[ebp], xmm1
  000ae	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR $T3[ebp]
  000b3	0f 28 c1	 movaps	 xmm0, xmm1
  000b6	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _d$1$[ebp]
  000bb	f3 0f 59 45 f0	 mulss	 xmm0, DWORD PTR $T2[ebp]
  000c0	f3 0f 58 c8	 addss	 xmm1, xmm0
  000c4	0f 57 c0	 xorps	 xmm0, xmm0
  000c7	f3 0f 11 4d f8	 movss	 DWORD PTR _d$1$[ebp], xmm1
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 84   : 	if (d<=0.0f)

  000cc	0f 2f c1	 comiss	 xmm0, xmm1
  000cf	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR $T3[ebp]
  000d4	72 1e		 jb	 SHORT $LN8@OnMovement
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000d6	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR $T1[ebp]
  000db	f3 0f 59 db	 mulss	 xmm3, xmm3
  000df	f3 0f 59 c0	 mulss	 xmm0, xmm0
  000e3	f3 0f 59 c9	 mulss	 xmm1, xmm1
  000e7	f3 0f 58 d8	 addss	 xmm3, xmm0
  000eb	f3 0f 58 d9	 addss	 xmm3, xmm1
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 86   : 		return D3DXVec3LengthSq(&(x-p1));

  000ef	e9 87 00 00 00	 jmp	 $LN5@OnMovement
$LN8@OnMovement:

; 87   : 	}
; 88   : 	else if (d>=l)

  000f4	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _d$1$[ebp]
  000f9	0f 2f 45 08	 comiss	 xmm0, DWORD PTR _l$1$[ebp]
  000fd	72 28		 jb	 SHORT $LN6@OnMovement
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000ff	f3 0f 10 59 08	 movss	 xmm3, DWORD PTR [ecx+8]
  00104	f3 0f 5c f4	 subss	 xmm6, xmm4
  00108	f3 0f 5c 50 08	 subss	 xmm2, DWORD PTR [eax+8]
  0010d	f3 0f 5c dd	 subss	 xmm3, xmm5

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00111	f3 0f 59 f6	 mulss	 xmm6, xmm6
  00115	f3 0f 59 db	 mulss	 xmm3, xmm3
  00119	f3 0f 59 d2	 mulss	 xmm2, xmm2
  0011d	f3 0f 58 de	 addss	 xmm3, xmm6
  00121	f3 0f 58 da	 addss	 xmm3, xmm2
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 90   : 		return D3DXVec3LengthSq(&(x-p2));

  00125	eb 54		 jmp	 SHORT $LN5@OnMovement
$LN6@OnMovement:
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00127	f3 0f 10 75 f0	 movss	 xmm6, DWORD PTR $T2[ebp]

; 181  :     y = fy;

  0012c	0f 28 cb	 movaps	 xmm1, xmm3

; 182  :     z = fz;

  0012f	f3 0f 10 5d f4	 movss	 xmm3, DWORD PTR $T3[ebp]

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00134	0f 28 d1	 movaps	 xmm2, xmm1

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;
; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00137	f3 0f 59 4d fc	 mulss	 xmm1, DWORD PTR $T4[ebp]
  0013c	0f 28 c3	 movaps	 xmm0, xmm3
  0013f	f3 0f 59 5d fc	 mulss	 xmm3, DWORD PTR $T4[ebp]
  00144	f3 0f 59 d6	 mulss	 xmm2, xmm6
  00148	f3 0f 59 75 ec	 mulss	 xmm6, DWORD PTR $T1[ebp]
  0014d	f3 0f 59 c7	 mulss	 xmm0, xmm7
  00151	f3 0f 59 7d ec	 mulss	 xmm7, DWORD PTR $T1[ebp]
  00156	f3 0f 5c de	 subss	 xmm3, xmm6
  0015a	f3 0f 5c d0	 subss	 xmm2, xmm0
  0015e	f3 0f 5c f9	 subss	 xmm7, xmm1

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00162	f3 0f 59 db	 mulss	 xmm3, xmm3
  00166	f3 0f 59 d2	 mulss	 xmm2, xmm2
  0016a	f3 0f 59 ff	 mulss	 xmm7, xmm7
  0016e	f3 0f 58 da	 addss	 xmm3, xmm2
  00172	f3 0f 58 df	 addss	 xmm3, xmm7
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 95   : 		return D3DXVec3LengthSq(D3DXVec3Cross(&c,&(x-p1),&(p2-p1)))/l;

  00176	f3 0f 5e 5d 08	 divss	 xmm3, DWORD PTR _l$1$[ebp]
$LN5@OnMovement:
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 231  : 	if (square_distance_between_linesegment_and_point(s.v3LastPosition,s.v3Position,m_attribute.v3Position) < (m_attribute.fRadius+s.fRadius)*(m_attribute.fRadius+s.fRadius))

  0017b	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00180	f3 0f 58 41 10	 addss	 xmm0, DWORD PTR [ecx+16]
  00185	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00189	0f 2f c3	 comiss	 xmm0, xmm3
  0018c	76 43		 jbe	 SHORT $LN1@OnMovement
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  0018e	f3 0f 10 48 10	 movss	 xmm1, DWORD PTR [eax+16]
  00193	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00198	f3 0f 5c 61 04	 subss	 xmm4, DWORD PTR [ecx+4]
  0019d	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  001a2	f3 0f 5c 69 08	 subss	 xmm5, DWORD PTR [ecx+8]
  001a7	f3 0f 5c 49 08	 subss	 xmm1, DWORD PTR [ecx+8]
  001ac	f3 0f 59 e4	 mulss	 xmm4, xmm4
  001b0	f3 0f 59 ed	 mulss	 xmm5, xmm5
  001b4	f3 0f 59 c0	 mulss	 xmm0, xmm0
  001b8	f3 0f 59 c9	 mulss	 xmm1, xmm1
  001bc	f3 0f 58 e5	 addss	 xmm4, xmm5
  001c0	f3 0f 58 c1	 addss	 xmm0, xmm1
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 235  : 			GetVector3Distance(s.v3LastPosition, m_attribute.v3Position))

  001c4	0f 2f c4	 comiss	 xmm0, xmm4
  001c7	76 08		 jbe	 SHORT $LN1@OnMovement

; 236  : 			return true;

  001c9	b0 01		 mov	 al, 1

; 240  : }

  001cb	8b e5		 mov	 esp, ebp
  001cd	5d		 pop	 ebp
  001ce	c2 04 00	 ret	 4
$LN1@OnMovement:

; 237  : 	}
; 238  : 
; 239  : 	return false;

  001d1	32 c0		 xor	 al, al

; 240  : }

  001d3	8b e5		 mov	 esp, ebp
  001d5	5d		 pop	 ebp
  001d6	c2 04 00	 ret	 4
?OnMovementCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CSphereCollisionInstance::OnMovementCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?OnDestroy@CSphereCollisionInstance@@MAEXXZ
_TEXT	SEGMENT
_pkData$ = -4						; size = 4
?OnDestroy@CSphereCollisionInstance@@MAEXXZ PROC	; CSphereCollisionInstance::OnDestroy, COMDAT
; _this$ = ecx

; 225  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 81   : 			m_kVct_pkFree.push_back(pkData);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _pkData$[ebp]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 226  : 	gs_sci.Free(this);

  00007	89 4d fc	 mov	 DWORD PTR _pkData$[ebp], ecx
; File c:\gamepackages\client\tools\patcher2017\eterlib\pool.h

; 81   : 			m_kVct_pkFree.push_back(pkData);

  0000a	50		 push	 eax
  0000b	b9 10 00 00 00	 mov	 ecx, OFFSET ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+16
  00010	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXABQAVCSphereCollisionInstance@@@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::push_back
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 227  : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?OnDestroy@CSphereCollisionInstance@@MAEXXZ ENDP	; CSphereCollisionInstance::OnDestroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_d3dFillMode$ = 8					; size = 4
?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z PROC ; CSphereCollisionInstance::Render, COMDAT
; _this$ = ecx

; 218  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 219  : 	static CScreen s;

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA
  0002a	a8 01		 test	 al, 1
  0002c	75 2d		 jne	 SHORT $LN1@Render
  0002e	83 c8 01	 or	 eax, 1
  00031	a3 00 00 00 00	 mov	 DWORD PTR ?$S1@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA, eax
  00036	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00042	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  00047	68 00 00 00 00	 push	 OFFSET ??__Fs@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ; `CSphereCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
  0004c	e8 00 00 00 00	 call	 _atexit
  00051	83 c4 04	 add	 esp, 4
  00054	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
$LN1@Render:

; 220  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, 0xffffffff);

  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00061	6a ff		 push	 -1
  00063	6a 3c		 push	 60			; 0000003cH
  00065	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 221  : 	s.RenderSphere(NULL, m_attribute.v3Position.x, m_attribute.v3Position.y, m_attribute.v3Position.z, m_attribute.fRadius, d3dFillMode);

  0006a	ff 75 08	 push	 DWORD PTR _d3dFillMode$[ebp]
  0006d	0f 10 46 04	 movups	 xmm0, XMMWORD PTR [esi+4]
  00071	83 ec 10	 sub	 esp, 16			; 00000010H
  00074	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00079	0f 11 04 24	 movups	 XMMWORD PTR [esp], xmm0
  0007d	6a 00		 push	 0
  0007f	e8 00 00 00 00	 call	 ?RenderSphere@CScreen@@QAEXPBUD3DXMATRIX@@MMMMW4_D3DFILLMODE@@@Z ; CScreen::RenderSphere

; 222  : }

  00084	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00087	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008e	59		 pop	 ecx
  0008f	5e		 pop	 esi
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0:
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA
  00005	83 e0 fe	 and	 eax, -2			; fffffffeH
  00008	a3 00 00 00 00	 mov	 DWORD PTR ?$S1@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4IA, eax
  0000d	c3		 ret	 0
__ehhandler$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ENDP ; CSphereCollisionInstance::Render
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?GetAttribute@CSphereCollisionInstance@@QBEABUSSphereData@@XZ
_TEXT	SEGMENT
?GetAttribute@CSphereCollisionInstance@@QBEABUSSphereData@@XZ PROC ; CSphereCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 214  : 	return m_attribute;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 215  : }

  00003	c3		 ret	 0
?GetAttribute@CSphereCollisionInstance@@QBEABUSSphereData@@XZ ENDP ; CSphereCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?GetAttribute@CSphereCollisionInstance@@QAEAAUSSphereData@@XZ
_TEXT	SEGMENT
?GetAttribute@CSphereCollisionInstance@@QAEAAUSSphereData@@XZ PROC ; CSphereCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 209  : 	return m_attribute;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 210  : }

  00003	c3		 ret	 0
?GetAttribute@CSphereCollisionInstance@@QAEAAUSSphereData@@XZ ENDP ; CSphereCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0CBaseCollisionInstance@@QAE@XZ
_TEXT	SEGMENT
??0CBaseCollisionInstance@@QAE@XZ PROC			; CBaseCollisionInstance::CBaseCollisionInstance, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CBaseCollisionInstance@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0CBaseCollisionInstance@@QAE@XZ ENDP			; CBaseCollisionInstance::CBaseCollisionInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?BuildCollisionInstance@CBaseCollisionInstance@@SAPAV1@PBVCStaticCollisionData@@PBUD3DXMATRIX@@@Z
_TEXT	SEGMENT
$T1 = -468						; size = 16
_v$2 = -464						; size = 12
_v$3 = -464						; size = 12
_v$4 = -464						; size = 12
_v$5 = -464						; size = 12
_v$6 = -464						; size = 12
_v3Position$1$ = -452					; size = 4
_v3Pos$3$ = -452					; size = 4
_v3Position$3$ = -448					; size = 4
_v3Pos$1$ = -448					; size = 4
_PlaneData$1$ = -448					; size = 4
_v3Position$2$ = -444					; size = 4
_c_pCollisionData$GSCopy$1$ = -444			; size = 4
_ppci$1$ = -444						; size = 4
_v3Pos$2$ = -440					; size = 4
_pMat$GSCopy$1$ = -440					; size = 4
$T7 = -436						; size = 64
_matTranslationLocal$8 = -372				; size = 64
_matTransform$9 = -372					; size = 64
$T10 = -308						; size = 64
$T11 = -244						; size = 64
_matRotation$12 = -180					; size = 64
_matTranslationLocal$13 = -180				; size = 64
_matTranslationLocal$14 = -180				; size = 64
_matTranslationLocal$15 = -116				; size = 64
_matTranslationLocal$16 = -116				; size = 64
_matTransform$17 = -116					; size = 64
_matRotation$18 = -116					; size = 64
_v3Line1$19 = -52					; size = 12
_v3Line0$20 = -40					; size = 12
_v3Min$21 = -28						; size = 12
_v3Line2$22 = -28					; size = 12
_v3Max$23 = -16						; size = 12
_v3Line3$24 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_c_pCollisionData$ = 8					; size = 4
_pMat$ = 12						; size = 4
?BuildCollisionInstance@CBaseCollisionInstance@@SAPAV1@PBVCStaticCollisionData@@PBUD3DXMATRIX@@@Z PROC ; CBaseCollisionInstance::BuildCollisionInstance, COMDAT

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 01 00
	00		 sub	 esp, 468		; 000001d4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _pMat$[ebp]
  00017	57		 push	 edi
  00018	8b 7d 08	 mov	 edi, DWORD PTR _c_pCollisionData$[ebp]
  0001b	89 bd 44 fe ff
	ff		 mov	 DWORD PTR _c_pCollisionData$GSCopy$1$[ebp], edi
  00021	89 b5 48 fe ff
	ff		 mov	 DWORD PTR _pMat$GSCopy$1$[ebp], esi

; 37   : 	switch(c_pCollisionData->dwType)

  00027	8b 07		 mov	 eax, DWORD PTR [edi]
  00029	83 f8 05	 cmp	 eax, 5
  0002c	0f 87 f6 08 00
	00		 ja	 $LN10@BuildColli
  00032	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN105@BuildColli[eax*4]
$LN9@BuildColli:

; 38   : 	{
; 39   : 		case COLLISION_TYPE_PLANE:
; 40   : 			{
; 41   : 				CPlaneCollisionInstance * ppci = gs_pci.Alloc();

  00039	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A ; gs_pci
  0003e	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEPAVCPlaneCollisionInstance@@XZ ; CDynamicPool<CPlaneCollisionInstance>::Alloc

; 42   : 				D3DXMATRIX matRotation;
; 43   : 				D3DXMATRIX matTranslationLocal;
; 44   : 				D3DXMatrixRotationQuaternion(&matRotation, &c_pCollisionData->quatRotation);

  00043	8d 4f 40	 lea	 ecx, DWORD PTR [edi+64]
  00046	89 85 44 fe ff
	ff		 mov	 DWORD PTR _ppci$1$[ebp], eax
  0004c	51		 push	 ecx
  0004d	8d 45 8c	 lea	 eax, DWORD PTR _matRotation$18[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 _D3DXMatrixRotationQuaternion@8

; 45   : 				D3DXMatrixTranslation(&matTranslationLocal, c_pCollisionData->v3Position.x, c_pCollisionData->v3Position.y, c_pCollisionData->v3Position.z);

  00056	f3 0f 10 47 30	 movss	 xmm0, DWORD PTR [edi+48]
  0005b	8d 77 28	 lea	 esi, DWORD PTR [edi+40]
  0005e	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00061	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _matTranslationLocal$14[ebp]
  00067	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0006d	f3 0f 10 47 2c	 movss	 xmm0, DWORD PTR [edi+44]
  00072	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00078	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  0007c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  00087	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _matTranslationLocal$14[ebp]
  0008d	50		 push	 eax
  0008e	8d 45 8c	 lea	 eax, DWORD PTR _matRotation$18[ebp]
  00091	50		 push	 eax
  00092	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12
  0009e	ff b5 48 fe ff
	ff		 push	 DWORD PTR _pMat$GSCopy$1$[ebp]
  000a4	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  000aa	50		 push	 eax
  000ab	8d 85 8c fe ff
	ff		 lea	 eax, DWORD PTR _matTransform$9[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 48   : 				TPlaneData & PlaneData = ppci->GetAttribute();

  000b7	8b 8d 44 fe ff
	ff		 mov	 ecx, DWORD PTR _ppci$1$[ebp]
  000bd	e8 00 00 00 00	 call	 ?GetAttribute@CPlaneCollisionInstance@@QAEAAUSPlaneData@@XZ ; CPlaneCollisionInstance::GetAttribute

; 49   : 				D3DXVec3TransformCoord(&PlaneData.v3Position, &c_pCollisionData->v3Position, pMat);

  000c2	ff b5 48 fe ff
	ff		 push	 DWORD PTR _pMat$GSCopy$1$[ebp]
  000c8	89 85 40 fe ff
	ff		 mov	 DWORD PTR _PlaneData$1$[ebp], eax
  000ce	56		 push	 esi
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12

; 50   : 				float fHalfWidth = c_pCollisionData->fDimensions[0] / 2.0f;

  000d5	f3 0f 10 67 34	 movss	 xmm4, DWORD PTR [edi+52]

; 51   : 				float fHalfLength = c_pCollisionData->fDimensions[1] / 2.0f;

  000da	f3 0f 10 5f 38	 movss	 xmm3, DWORD PTR [edi+56]

; 52   : 
; 53   : 				PlaneData.v3QuadPosition[0].x = -fHalfWidth;

  000df	8b bd 40 fe ff
	ff		 mov	 edi, DWORD PTR _PlaneData$1$[ebp]
  000e5	f3 0f 59 25 00
	00 00 00	 mulss	 xmm4, DWORD PTR __real@3f000000
  000ed	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  000f0	f3 0f 59 1d 00
	00 00 00	 mulss	 xmm3, DWORD PTR __real@3f000000

; 54   : 				PlaneData.v3QuadPosition[0].y = -fHalfLength;
; 55   : 				PlaneData.v3QuadPosition[0].z = 0.0f;

  000f8	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], 0
  000ff	0f 28 d4	 movaps	 xmm2, xmm4

; 56   : 				PlaneData.v3QuadPosition[1].x = +fHalfWidth;

  00102	f3 0f 11 67 24	 movss	 DWORD PTR [edi+36], xmm4
  00107	0f 57 15 00 00
	00 00		 xorps	 xmm2, DWORD PTR __xmm@80000000800000008000000080000000
  0010e	0f 28 cb	 movaps	 xmm1, xmm3

; 57   : 				PlaneData.v3QuadPosition[1].y = -fHalfLength;
; 58   : 				PlaneData.v3QuadPosition[1].z = 0.0f;

  00111	c7 47 2c 00 00
	00 00		 mov	 DWORD PTR [edi+44], 0
  00118	0f 57 0d 00 00
	00 00		 xorps	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
  0011f	f3 0f 11 4f 1c	 movss	 DWORD PTR [edi+28], xmm1
  00124	f3 0f 11 4f 28	 movss	 DWORD PTR [edi+40], xmm1

; 59   : 				PlaneData.v3QuadPosition[2].x = -fHalfWidth;

  00129	f3 0f 11 57 30	 movss	 DWORD PTR [edi+48], xmm2

; 60   : 				PlaneData.v3QuadPosition[2].y = +fHalfLength;

  0012e	f3 0f 11 5f 34	 movss	 DWORD PTR [edi+52], xmm3

; 61   : 				PlaneData.v3QuadPosition[2].z = 0.0f;

  00133	c7 47 38 00 00
	00 00		 mov	 DWORD PTR [edi+56], 0

; 62   : 				PlaneData.v3QuadPosition[3].x = +fHalfWidth;

  0013a	f3 0f 11 67 3c	 movss	 DWORD PTR [edi+60], xmm4

; 63   : 				PlaneData.v3QuadPosition[3].y = +fHalfLength;

  0013f	f3 0f 11 5f 40	 movss	 DWORD PTR [edi+64], xmm3

; 64   : 				PlaneData.v3QuadPosition[3].z = 0.0f;

  00144	c7 47 44 00 00
	00 00		 mov	 DWORD PTR [edi+68], 0
  0014b	bf 04 00 00 00	 mov	 edi, 4
  00150	f3 0f 11 16	 movss	 DWORD PTR [esi], xmm2
$LL8@BuildColli:

; 65   : 				for (DWORD i = 0; i < 4; ++i)
; 66   : 					D3DXVec3TransformCoord(&PlaneData.v3QuadPosition[i], &PlaneData.v3QuadPosition[i], &matTransform);

  00154	8d 85 8c fe ff
	ff		 lea	 eax, DWORD PTR _matTransform$9[ebp]
  0015a	50		 push	 eax
  0015b	56		 push	 esi
  0015c	56		 push	 esi
  0015d	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
  00162	83 c6 0c	 add	 esi, 12			; 0000000cH
  00165	4f		 dec	 edi
  00166	75 ec		 jne	 SHORT $LL8@BuildColli
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00168	8b bd 40 fe ff
	ff		 mov	 edi, DWORD PTR _PlaneData$1$[ebp]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 71   : 				D3DXVec3Normalize(&v3Line0, &v3Line0);

  0016e	8d 45 d8	 lea	 eax, DWORD PTR _v3Line0$20[ebp]
  00171	50		 push	 eax
  00172	50		 push	 eax
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00173	f3 0f 10 57 28	 movss	 xmm2, DWORD PTR [edi+40]
  00178	f3 0f 5c 57 1c	 subss	 xmm2, DWORD PTR [edi+28]
  0017d	f3 0f 10 4f 2c	 movss	 xmm1, DWORD PTR [edi+44]
  00182	f3 0f 5c 4f 20	 subss	 xmm1, DWORD PTR [edi+32]
  00187	f3 0f 10 47 24	 movss	 xmm0, DWORD PTR [edi+36]
  0018c	f3 0f 5c 47 18	 subss	 xmm0, DWORD PTR [edi+24]

; 181  :     y = fy;

  00191	f3 0f 11 55 dc	 movss	 DWORD PTR _v3Line0$20[ebp+4], xmm2

; 182  :     z = fz;

  00196	f3 0f 11 4d e0	 movss	 DWORD PTR _v3Line0$20[ebp+8], xmm1
  0019b	f3 0f 11 45 d8	 movss	 DWORD PTR _v3Line0$20[ebp], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001a0	f3 0f 10 57 34	 movss	 xmm2, DWORD PTR [edi+52]
  001a5	f3 0f 5c 57 1c	 subss	 xmm2, DWORD PTR [edi+28]
  001aa	f3 0f 10 4f 38	 movss	 xmm1, DWORD PTR [edi+56]
  001af	f3 0f 5c 4f 20	 subss	 xmm1, DWORD PTR [edi+32]
  001b4	f3 0f 10 47 30	 movss	 xmm0, DWORD PTR [edi+48]
  001b9	f3 0f 5c 47 18	 subss	 xmm0, DWORD PTR [edi+24]

; 181  :     y = fy;

  001be	f3 0f 11 55 d0	 movss	 DWORD PTR _v3Line1$19[ebp+4], xmm2

; 182  :     z = fz;

  001c3	f3 0f 11 4d d4	 movss	 DWORD PTR _v3Line1$19[ebp+8], xmm1
  001c8	f3 0f 11 45 cc	 movss	 DWORD PTR _v3Line1$19[ebp], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001cd	f3 0f 10 57 28	 movss	 xmm2, DWORD PTR [edi+40]
  001d2	f3 0f 10 4f 2c	 movss	 xmm1, DWORD PTR [edi+44]
  001d7	f3 0f 10 47 24	 movss	 xmm0, DWORD PTR [edi+36]
  001dc	f3 0f 5c 57 40	 subss	 xmm2, DWORD PTR [edi+64]
  001e1	f3 0f 5c 4f 44	 subss	 xmm1, DWORD PTR [edi+68]
  001e6	f3 0f 5c 47 3c	 subss	 xmm0, DWORD PTR [edi+60]

; 181  :     y = fy;

  001eb	f3 0f 11 55 e8	 movss	 DWORD PTR _v3Line2$22[ebp+4], xmm2

; 182  :     z = fz;

  001f0	f3 0f 11 4d ec	 movss	 DWORD PTR _v3Line2$22[ebp+8], xmm1
  001f5	f3 0f 11 45 e4	 movss	 DWORD PTR _v3Line2$22[ebp], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001fa	f3 0f 10 57 34	 movss	 xmm2, DWORD PTR [edi+52]
  001ff	f3 0f 10 4f 38	 movss	 xmm1, DWORD PTR [edi+56]
  00204	f3 0f 10 47 30	 movss	 xmm0, DWORD PTR [edi+48]
  00209	f3 0f 5c 57 40	 subss	 xmm2, DWORD PTR [edi+64]
  0020e	f3 0f 5c 4f 44	 subss	 xmm1, DWORD PTR [edi+68]
  00213	f3 0f 5c 47 3c	 subss	 xmm0, DWORD PTR [edi+60]

; 181  :     y = fy;

  00218	f3 0f 11 55 f4	 movss	 DWORD PTR _v3Line3$24[ebp+4], xmm2

; 182  :     z = fz;

  0021d	f3 0f 11 4d f8	 movss	 DWORD PTR _v3Line3$24[ebp+8], xmm1
  00222	f3 0f 11 45 f0	 movss	 DWORD PTR _v3Line3$24[ebp], xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 71   : 				D3DXVec3Normalize(&v3Line0, &v3Line0);

  00227	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 72   : 				D3DXVec3Normalize(&v3Line1, &v3Line1);

  0022c	8d 45 cc	 lea	 eax, DWORD PTR _v3Line1$19[ebp]
  0022f	50		 push	 eax
  00230	50		 push	 eax
  00231	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 73   : 				D3DXVec3Normalize(&v3Line2, &v3Line2);

  00236	8d 45 e4	 lea	 eax, DWORD PTR _v3Line2$22[ebp]
  00239	50		 push	 eax
  0023a	50		 push	 eax
  0023b	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 74   : 				D3DXVec3Normalize(&v3Line3, &v3Line3);

  00240	8d 45 f0	 lea	 eax, DWORD PTR _v3Line3$24[ebp]
  00243	50		 push	 eax
  00244	50		 push	 eax
  00245	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  0024a	f3 0f 10 5d d0	 movss	 xmm3, DWORD PTR _v3Line1$19[ebp+4]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 75   : 				D3DXVec3Cross(&PlaneData.v3Normal, &v3Line0, &v3Line1);

  0024f	8d 77 0c	 lea	 esi, DWORD PTR [edi+12]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00252	f3 0f 10 55 d4	 movss	 xmm2, DWORD PTR _v3Line1$19[ebp+8]
  00257	0f 28 c3	 movaps	 xmm0, xmm3
  0025a	f3 0f 10 6d e0	 movss	 xmm5, DWORD PTR _v3Line0$20[ebp+8]
  0025f	0f 28 f2	 movaps	 xmm6, xmm2
  00262	f3 0f 10 65 dc	 movss	 xmm4, DWORD PTR _v3Line0$20[ebp+4]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00267	f3 0f 59 55 d8	 mulss	 xmm2, DWORD PTR _v3Line0$20[ebp]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 76   : 				D3DXVec3Normalize(&PlaneData.v3Normal, &PlaneData.v3Normal);

  0026c	56		 push	 esi
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  0026d	f3 0f 59 5d d8	 mulss	 xmm3, DWORD PTR _v3Line0$20[ebp]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 76   : 				D3DXVec3Normalize(&PlaneData.v3Normal, &PlaneData.v3Normal);

  00272	56		 push	 esi
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00273	f3 0f 59 c5	 mulss	 xmm0, xmm5

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00277	f3 0f 59 6d cc	 mulss	 xmm5, DWORD PTR _v3Line1$19[ebp]
  0027c	f3 0f 59 f4	 mulss	 xmm6, xmm4

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00280	f3 0f 59 65 cc	 mulss	 xmm4, DWORD PTR _v3Line1$19[ebp]
  00285	f3 0f 5c ea	 subss	 xmm5, xmm2
  00289	f3 0f 5c f0	 subss	 xmm6, xmm0
  0028d	f3 0f 5c dc	 subss	 xmm3, xmm4

; 1280 : 
; 1281 :     *pOut = v;

  00291	0f 14 f5	 unpcklps xmm6, xmm5
  00294	66 0f d6 36	 movq	 QWORD PTR [esi], xmm6
  00298	f3 0f 11 9d 38
	fe ff ff	 movss	 DWORD PTR _v$6[ebp+8], xmm3
  002a0	8b 85 38 fe ff
	ff		 mov	 eax, DWORD PTR _v$6[ebp+8]
  002a6	89 46 08	 mov	 DWORD PTR [esi+8], eax
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 76   : 				D3DXVec3Normalize(&PlaneData.v3Normal, &PlaneData.v3Normal);

  002a9	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  002ae	f3 0f 10 5d e0	 movss	 xmm3, DWORD PTR _v3Line0$20[ebp+8]
  002b3	f3 0f 10 6d dc	 movss	 xmm5, DWORD PTR _v3Line0$20[ebp+4]
  002b8	0f 28 fb	 movaps	 xmm7, xmm3
  002bb	f3 0f 59 7e 04	 mulss	 xmm7, DWORD PTR [esi+4]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  002c0	f3 0f 10 4d d8	 movss	 xmm1, DWORD PTR _v3Line0$20[ebp]
  002c5	0f 28 c5	 movaps	 xmm0, xmm5
  002c8	f3 0f 59 46 08	 mulss	 xmm0, DWORD PTR [esi+8]
  002cd	0f 28 e1	 movaps	 xmm4, xmm1

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  002d0	f3 0f 59 4e 04	 mulss	 xmm1, DWORD PTR [esi+4]
  002d5	f3 0f 59 2e	 mulss	 xmm5, DWORD PTR [esi]
  002d9	f3 0f 5c f8	 subss	 xmm7, xmm0
  002dd	f3 0f 59 66 08	 mulss	 xmm4, DWORD PTR [esi+8]
  002e2	f3 0f 59 1e	 mulss	 xmm3, DWORD PTR [esi]
  002e6	f3 0f 5c e9	 subss	 xmm5, xmm1
  002ea	f3 0f 5c e3	 subss	 xmm4, xmm3
  002ee	f3 0f 11 ad 38
	fe ff ff	 movss	 DWORD PTR _v$5[ebp+8], xmm5

; 1280 : 
; 1281 :     *pOut = v;

  002f6	8b 85 38 fe ff
	ff		 mov	 eax, DWORD PTR _v$5[ebp+8]
  002fc	0f 14 fc	 unpcklps xmm7, xmm4
  002ff	66 0f d6 7f 48	 movq	 QWORD PTR [edi+72], xmm7
  00304	89 47 50	 mov	 DWORD PTR [edi+80], eax

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00307	f3 0f 10 6d d0	 movss	 xmm5, DWORD PTR _v3Line1$19[ebp+4]
  0030c	f3 0f 10 75 d4	 movss	 xmm6, DWORD PTR _v3Line1$19[ebp+8]
  00311	0f 28 fd	 movaps	 xmm7, xmm5
  00314	f3 0f 59 7e 08	 mulss	 xmm7, DWORD PTR [esi+8]
  00319	0f 28 c6	 movaps	 xmm0, xmm6
  0031c	f3 0f 59 46 04	 mulss	 xmm0, DWORD PTR [esi+4]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00321	f3 0f 10 4d cc	 movss	 xmm1, DWORD PTR _v3Line1$19[ebp]

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00326	f3 0f 59 2e	 mulss	 xmm5, DWORD PTR [esi]
  0032a	f3 0f 59 36	 mulss	 xmm6, DWORD PTR [esi]
  0032e	f3 0f 5c f8	 subss	 xmm7, xmm0
  00332	0f 28 c1	 movaps	 xmm0, xmm1
  00335	f3 0f 59 4e 04	 mulss	 xmm1, DWORD PTR [esi+4]
  0033a	f3 0f 59 46 08	 mulss	 xmm0, DWORD PTR [esi+8]
  0033f	f3 0f 5c cd	 subss	 xmm1, xmm5
  00343	f3 0f 5c f0	 subss	 xmm6, xmm0
  00347	f3 0f 11 8d 38
	fe ff ff	 movss	 DWORD PTR _v$4[ebp+8], xmm1

; 1280 : 
; 1281 :     *pOut = v;

  0034f	8b 85 38 fe ff
	ff		 mov	 eax, DWORD PTR _v$4[ebp+8]
  00355	0f 14 fe	 unpcklps xmm7, xmm6
  00358	66 0f d6 7f 54	 movq	 QWORD PTR [edi+84], xmm7
  0035d	89 47 5c	 mov	 DWORD PTR [edi+92], eax

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00360	f3 0f 10 6d e8	 movss	 xmm5, DWORD PTR _v3Line2$22[ebp+4]
  00365	f3 0f 10 75 ec	 movss	 xmm6, DWORD PTR _v3Line2$22[ebp+8]
  0036a	0f 28 fd	 movaps	 xmm7, xmm5
  0036d	f3 0f 59 7e 08	 mulss	 xmm7, DWORD PTR [esi+8]
  00372	0f 28 c6	 movaps	 xmm0, xmm6
  00375	f3 0f 59 46 04	 mulss	 xmm0, DWORD PTR [esi+4]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0037a	f3 0f 10 4d e4	 movss	 xmm1, DWORD PTR _v3Line2$22[ebp]

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  0037f	f3 0f 59 2e	 mulss	 xmm5, DWORD PTR [esi]
  00383	f3 0f 59 36	 mulss	 xmm6, DWORD PTR [esi]
  00387	f3 0f 5c f8	 subss	 xmm7, xmm0
  0038b	0f 28 c1	 movaps	 xmm0, xmm1
  0038e	f3 0f 59 4e 04	 mulss	 xmm1, DWORD PTR [esi+4]
  00393	f3 0f 59 46 08	 mulss	 xmm0, DWORD PTR [esi+8]
  00398	f3 0f 5c cd	 subss	 xmm1, xmm5
  0039c	f3 0f 5c f0	 subss	 xmm6, xmm0
  003a0	f3 0f 11 8d 38
	fe ff ff	 movss	 DWORD PTR _v$3[ebp+8], xmm1

; 1280 : 
; 1281 :     *pOut = v;

  003a8	8b 85 38 fe ff
	ff		 mov	 eax, DWORD PTR _v$3[ebp+8]
  003ae	0f 14 fe	 unpcklps xmm7, xmm6
  003b1	66 0f d6 7f 60	 movq	 QWORD PTR [edi+96], xmm7
  003b6	89 47 68	 mov	 DWORD PTR [edi+104], eax

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  003b9	f3 0f 10 5d f8	 movss	 xmm3, DWORD PTR _v3Line3$24[ebp+8]
  003be	f3 0f 10 6d f4	 movss	 xmm5, DWORD PTR _v3Line3$24[ebp+4]
  003c3	0f 28 fb	 movaps	 xmm7, xmm3

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  003c6	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _v3Line3$24[ebp]
  003cb	0f 28 c5	 movaps	 xmm0, xmm5
  003ce	f3 0f 59 7e 04	 mulss	 xmm7, DWORD PTR [esi+4]
  003d3	0f 28 e1	 movaps	 xmm4, xmm1
  003d6	f3 0f 59 46 08	 mulss	 xmm0, DWORD PTR [esi+8]
  003db	f3 0f 59 66 08	 mulss	 xmm4, DWORD PTR [esi+8]
  003e0	f3 0f 59 1e	 mulss	 xmm3, DWORD PTR [esi]
  003e4	f3 0f 5c f8	 subss	 xmm7, xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  003e8	f3 0f 59 2e	 mulss	 xmm5, DWORD PTR [esi]
  003ec	f3 0f 59 4e 04	 mulss	 xmm1, DWORD PTR [esi+4]
  003f1	f3 0f 5c e3	 subss	 xmm4, xmm3
  003f5	f3 0f 5c e9	 subss	 xmm5, xmm1

; 1280 : 
; 1281 :     *pOut = v;

  003f9	0f 14 fc	 unpcklps xmm7, xmm4
  003fc	66 0f d6 7f 6c	 movq	 QWORD PTR [edi+108], xmm7
  00401	f3 0f 11 ad 38
	fe ff ff	 movss	 DWORD PTR _v$2[ebp+8], xmm5
  00409	8b 85 38 fe ff
	ff		 mov	 eax, DWORD PTR _v$2[ebp+8]
  0040f	89 47 74	 mov	 DWORD PTR [edi+116], eax
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 83   : 				return ppci;

  00412	8b 85 44 fe ff
	ff		 mov	 eax, DWORD PTR _ppci$1$[ebp]
  00418	5f		 pop	 edi
  00419	5e		 pop	 esi

; 192  : 			}
; 193  : 			break;
; 194  : 	}
; 195  : 	assert(false && "NOT_REACHED");
; 196  : 	return 0;
; 197  : }

  0041a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0041d	33 cd		 xor	 ecx, ebp
  0041f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00424	8b e5		 mov	 esp, ebp
  00426	5d		 pop	 ebp
  00427	c3		 ret	 0
$LN4@BuildColli:

; 84   : 			}
; 85   : 			break;
; 86   : 		case COLLISION_TYPE_BOX:
; 87   : 			assert(false && "COLLISION_TYPE_BOX not implemented");
; 88   : 			break;
; 89   : 		case COLLISION_TYPE_AABB:
; 90   : 			{
; 91   : 				CAABBCollisionInstance * paci = gs_aci.Alloc();

  00428	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A ; gs_aci
  0042d	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEPAVCAABBCollisionInstance@@XZ ; CDynamicPool<CAABBCollisionInstance>::Alloc
  00432	8b f8		 mov	 edi, eax

; 92   : 				
; 93   : 				D3DXMATRIX matTranslationLocal;
; 94   : 				D3DXMatrixTranslation(&matTranslationLocal, c_pCollisionData->v3Position.x, c_pCollisionData->v3Position.y, c_pCollisionData->v3Position.z);

  00434	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00437	8b 85 44 fe ff
	ff		 mov	 eax, DWORD PTR _c_pCollisionData$GSCopy$1$[ebp]
  0043d	f3 0f 10 40 30	 movss	 xmm0, DWORD PTR [eax+48]
  00442	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00448	f3 0f 10 40 2c	 movss	 xmm0, DWORD PTR [eax+44]
  0044d	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00453	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [eax+40]
  00458	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _matTranslationLocal$13[ebp]
  0045e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00463	50		 push	 eax
  00464	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16

; 95   : 				D3DXMATRIX matTransform = *pMat;

  00469	f3 0f 6f 06	 movdqu	 xmm0, XMMWORD PTR [esi]

; 96   : 
; 97   : 				D3DXVECTOR3 v3Pos;
; 98   : 				v3Pos.x = matTranslationLocal._41;
; 99   : 				v3Pos.y = matTranslationLocal._42;
; 100  : 				v3Pos.z = matTranslationLocal._43;
; 101  : 
; 102  : 				TAABBData & AABBData = paci->GetAttribute();

  0046d	8b cf		 mov	 ecx, edi
  0046f	f3 0f 7f 45 8c	 movdqu	 XMMWORD PTR _matTransform$17[ebp], xmm0
  00474	f3 0f 6f 46 10	 movdqu	 xmm0, XMMWORD PTR [esi+16]
  00479	f3 0f 7f 45 9c	 movdqu	 XMMWORD PTR _matTransform$17[ebp+16], xmm0
  0047e	f3 0f 6f 46 20	 movdqu	 xmm0, XMMWORD PTR [esi+32]
  00483	f3 0f 7f 45 ac	 movdqu	 XMMWORD PTR _matTransform$17[ebp+32], xmm0
  00488	f3 0f 6f 46 30	 movdqu	 xmm0, XMMWORD PTR [esi+48]
  0048d	f3 0f 7f 45 bc	 movdqu	 XMMWORD PTR _matTransform$17[ebp+48], xmm0
  00492	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _matTranslationLocal$13[ebp+48]
  0049a	f3 0f 11 85 40
	fe ff ff	 movss	 DWORD PTR _v3Pos$1$[ebp], xmm0
  004a2	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _matTranslationLocal$13[ebp+52]
  004a7	f3 0f 11 85 48
	fe ff ff	 movss	 DWORD PTR _v3Pos$2$[ebp], xmm0
  004af	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _matTranslationLocal$13[ebp+56]
  004b4	f3 0f 11 85 3c
	fe ff ff	 movss	 DWORD PTR _v3Pos$3$[ebp], xmm0
  004bc	e8 00 00 00 00	 call	 ?GetAttribute@CAABBCollisionInstance@@QAEAAUSAABBData@@XZ ; CAABBCollisionInstance::GetAttribute

; 103  : 				AABBData.v3Min.x = v3Pos.x - c_pCollisionData->fDimensions[0];

  004c1	8b 8d 44 fe ff
	ff		 mov	 ecx, DWORD PTR _c_pCollisionData$GSCopy$1$[ebp]

; 104  : 				AABBData.v3Min.y = v3Pos.y - c_pCollisionData->fDimensions[1];
; 105  : 				AABBData.v3Min.z = v3Pos.z - c_pCollisionData->fDimensions[2];
; 106  : 				AABBData.v3Max.x = v3Pos.x + c_pCollisionData->fDimensions[0];

  004c7	8d 70 0c	 lea	 esi, DWORD PTR [eax+12]
  004ca	f3 0f 10 85 40
	fe ff ff	 movss	 xmm0, DWORD PTR _v3Pos$1$[ebp]
  004d2	f3 0f 10 9d 3c
	fe ff ff	 movss	 xmm3, DWORD PTR _v3Pos$3$[ebp]
  004da	f3 0f 5c 41 34	 subss	 xmm0, DWORD PTR [ecx+52]
  004df	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  004e3	f3 0f 10 85 48
	fe ff ff	 movss	 xmm0, DWORD PTR _v3Pos$2$[ebp]
  004eb	f3 0f 5c 41 38	 subss	 xmm0, DWORD PTR [ecx+56]
  004f0	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  004f5	0f 28 c3	 movaps	 xmm0, xmm3
  004f8	f3 0f 5c 41 3c	 subss	 xmm0, DWORD PTR [ecx+60]
  004fd	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
  00502	f3 0f 10 41 34	 movss	 xmm0, DWORD PTR [ecx+52]
  00507	f3 0f 58 85 40
	fe ff ff	 addss	 xmm0, DWORD PTR _v3Pos$1$[ebp]
  0050f	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0

; 107  : 				AABBData.v3Max.y = v3Pos.y + c_pCollisionData->fDimensions[1];

  00513	f3 0f 10 41 38	 movss	 xmm0, DWORD PTR [ecx+56]
  00518	f3 0f 58 85 48
	fe ff ff	 addss	 xmm0, DWORD PTR _v3Pos$2$[ebp]
  00520	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 108  : 				AABBData.v3Max.z = v3Pos.z + c_pCollisionData->fDimensions[2];

  00525	f3 0f 58 59 3c	 addss	 xmm3, DWORD PTR [ecx+60]

; 109  : 
; 110  : 				D3DXVec3TransformCoord(&AABBData.v3Min, &AABBData.v3Min, &matTransform);

  0052a	8d 4d 8c	 lea	 ecx, DWORD PTR _matTransform$17[ebp]
  0052d	51		 push	 ecx
  0052e	50		 push	 eax
  0052f	50		 push	 eax
  00530	f3 0f 11 58 14	 movss	 DWORD PTR [eax+20], xmm3
  00535	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12

; 111  : 				D3DXVec3TransformCoord(&AABBData.v3Max, &AABBData.v3Max, &matTransform);

  0053a	8d 45 8c	 lea	 eax, DWORD PTR _matTransform$17[ebp]
  0053d	50		 push	 eax
  0053e	56		 push	 esi
  0053f	56		 push	 esi
  00540	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12

; 112  : 
; 113  : 				return paci;

  00545	8b c7		 mov	 eax, edi
  00547	5f		 pop	 edi
  00548	5e		 pop	 esi

; 192  : 			}
; 193  : 			break;
; 194  : 	}
; 195  : 	assert(false && "NOT_REACHED");
; 196  : 	return 0;
; 197  : }

  00549	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0054c	33 cd		 xor	 ecx, ebp
  0054e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00553	8b e5		 mov	 esp, ebp
  00555	5d		 pop	 ebp
  00556	c3		 ret	 0
$LN3@BuildColli:

; 114  : 			}
; 115  : 			break;
; 116  : 			case COLLISION_TYPE_OBB:
; 117  : 			{
; 118  : 				COBBCollisionInstance * poci = gs_oci.Alloc();

  00557	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A ; gs_oci
  0055c	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEPAVCOBBCollisionInstance@@XZ ; CDynamicPool<COBBCollisionInstance>::Alloc

; 119  : 				
; 120  : 				D3DXMATRIX matTranslationLocal; D3DXMatrixTranslation(&matTranslationLocal, c_pCollisionData->v3Position.x, c_pCollisionData->v3Position.y, c_pCollisionData->v3Position.z);

  00561	f3 0f 10 47 30	 movss	 xmm0, DWORD PTR [edi+48]
  00566	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00569	8b f0		 mov	 esi, eax
  0056b	8d 85 8c fe ff
	ff		 lea	 eax, DWORD PTR _matTranslationLocal$8[ebp]
  00571	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00577	f3 0f 10 47 2c	 movss	 xmm0, DWORD PTR [edi+44]
  0057c	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00582	f3 0f 10 47 28	 movss	 xmm0, DWORD PTR [edi+40]
  00587	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0058c	50		 push	 eax
  0058d	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16

; 121  : 				D3DXMATRIX matRotation; D3DXMatrixRotationQuaternion(&matRotation, &c_pCollisionData->quatRotation);

  00592	8d 47 40	 lea	 eax, DWORD PTR [edi+64]
  00595	50		 push	 eax
  00596	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _matRotation$12[ebp]
  0059c	50		 push	 eax
  0059d	e8 00 00 00 00	 call	 _D3DXMatrixRotationQuaternion@8

; 122  : 				
; 123  : 				D3DXMATRIX matTranslationWorld; D3DXMatrixIdentity(&matTranslationWorld);
; 124  : 				matTranslationWorld._41 = pMat->_41; matTranslationWorld._42 = pMat->_42; matTranslationWorld._43 = pMat->_43; matTranslationWorld._44 = pMat->_44;
; 125  : 				
; 126  : 				D3DXVECTOR3 v3Min, v3Max;
; 127  : 				v3Min.x = c_pCollisionData->v3Position.x - c_pCollisionData->fDimensions[0];

  005a2	f3 0f 10 6f 34	 movss	 xmm5, DWORD PTR [edi+52]

; 128  : 				v3Min.y = c_pCollisionData->v3Position.y - c_pCollisionData->fDimensions[1];
; 129  : 				v3Min.z = c_pCollisionData->v3Position.z - c_pCollisionData->fDimensions[2];
; 130  : 				v3Max.x = c_pCollisionData->v3Position.x + c_pCollisionData->fDimensions[0];
; 131  : 				v3Max.y = c_pCollisionData->v3Position.y + c_pCollisionData->fDimensions[1];
; 132  : 				v3Max.z = c_pCollisionData->v3Position.z + c_pCollisionData->fDimensions[2];
; 133  : 
; 134  : 				D3DXVec3TransformCoord(&v3Min, &v3Min, pMat);

  005a7	8d 45 e4	 lea	 eax, DWORD PTR _v3Min$21[ebp]
  005aa	f3 0f 10 47 28	 movss	 xmm0, DWORD PTR [edi+40]
  005af	f3 0f 10 5f 38	 movss	 xmm3, DWORD PTR [edi+56]
  005b4	f3 0f 5c c5	 subss	 xmm0, xmm5
  005b8	f3 0f 10 4f 3c	 movss	 xmm1, DWORD PTR [edi+60]
  005bd	ff b5 48 fe ff
	ff		 push	 DWORD PTR _pMat$GSCopy$1$[ebp]
  005c3	f3 0f 58 6f 28	 addss	 xmm5, DWORD PTR [edi+40]
  005c8	50		 push	 eax
  005c9	f3 0f 11 45 e4	 movss	 DWORD PTR _v3Min$21[ebp], xmm0
  005ce	f3 0f 10 47 2c	 movss	 xmm0, DWORD PTR [edi+44]
  005d3	f3 0f 5c c3	 subss	 xmm0, xmm3
  005d7	f3 0f 58 5f 2c	 addss	 xmm3, DWORD PTR [edi+44]
  005dc	50		 push	 eax
  005dd	f3 0f 11 6d f0	 movss	 DWORD PTR _v3Max$23[ebp], xmm5
  005e2	f3 0f 11 45 e8	 movss	 DWORD PTR _v3Min$21[ebp+4], xmm0
  005e7	f3 0f 10 47 30	 movss	 xmm0, DWORD PTR [edi+48]
  005ec	f3 0f 5c c1	 subss	 xmm0, xmm1
  005f0	f3 0f 11 5d f4	 movss	 DWORD PTR _v3Max$23[ebp+4], xmm3
  005f5	f3 0f 58 4f 30	 addss	 xmm1, DWORD PTR [edi+48]
  005fa	f3 0f 11 45 ec	 movss	 DWORD PTR _v3Min$21[ebp+8], xmm0
  005ff	f3 0f 11 4d f8	 movss	 DWORD PTR _v3Max$23[ebp+8], xmm1
  00604	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12

; 135  : 				D3DXVec3TransformCoord(&v3Max, &v3Max, pMat);

  00609	ff b5 48 fe ff
	ff		 push	 DWORD PTR _pMat$GSCopy$1$[ebp]
  0060f	8d 45 f0	 lea	 eax, DWORD PTR _v3Max$23[ebp]
  00612	50		 push	 eax
  00613	50		 push	 eax
  00614	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00619	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _v3Max$23[ebp]
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 138  : 				TOBBData & OBBData = poci->GetAttribute();

  0061e	8b ce		 mov	 ecx, esi
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00620	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR _v3Max$23[ebp+4]
  00625	f3 0f 10 5d f8	 movss	 xmm3, DWORD PTR _v3Max$23[ebp+8]
  0062a	f3 0f 58 4d e4	 addss	 xmm1, DWORD PTR _v3Min$21[ebp]
  0062f	f3 0f 58 55 e8	 addss	 xmm2, DWORD PTR _v3Min$21[ebp+4]
  00634	f3 0f 58 5d ec	 addss	 xmm3, DWORD PTR _v3Min$21[ebp+8]

; 264  : }
; 265  : 
; 266  : D3DXINLINE D3DXVECTOR3
; 267  : D3DXVECTOR3::operator * ( FLOAT f ) const
; 268  : {
; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00639	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00641	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00645	f3 0f 59 d0	 mulss	 xmm2, xmm0
  00649	f3 0f 59 d8	 mulss	 xmm3, xmm0
  0064d	f3 0f 11 8d 3c
	fe ff ff	 movss	 DWORD PTR _v3Position$1$[ebp], xmm1
  00655	f3 0f 11 95 44
	fe ff ff	 movss	 DWORD PTR _v3Position$2$[ebp], xmm2
  0065d	f3 0f 11 9d 40
	fe ff ff	 movss	 DWORD PTR _v3Position$3$[ebp], xmm3
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 138  : 				TOBBData & OBBData = poci->GetAttribute();

  00665	e8 00 00 00 00	 call	 ?GetAttribute@COBBCollisionInstance@@QAEAAUSOBBData@@XZ ; COBBCollisionInstance::GetAttribute

; 139  : 				OBBData.v3Min.x = v3Position.x - c_pCollisionData->fDimensions[0];

  0066a	f3 0f 10 85 3c
	fe ff ff	 movss	 xmm0, DWORD PTR _v3Position$1$[ebp]
  00672	f3 0f 5c 47 34	 subss	 xmm0, DWORD PTR [edi+52]

; 140  : 				OBBData.v3Min.y = v3Position.y - c_pCollisionData->fDimensions[1];
; 141  : 				OBBData.v3Min.z = v3Position.z - c_pCollisionData->fDimensions[2];

  00677	f3 0f 10 9d 40
	fe ff ff	 movss	 xmm3, DWORD PTR _v3Position$3$[ebp]
  0067f	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00683	f3 0f 10 85 44
	fe ff ff	 movss	 xmm0, DWORD PTR _v3Position$2$[ebp]
  0068b	f3 0f 5c 47 38	 subss	 xmm0, DWORD PTR [edi+56]
  00690	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00695	0f 28 c3	 movaps	 xmm0, xmm3
  00698	f3 0f 5c 47 3c	 subss	 xmm0, DWORD PTR [edi+60]
  0069d	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 142  : 				OBBData.v3Max.x = v3Position.x + c_pCollisionData->fDimensions[0];

  006a2	f3 0f 10 47 34	 movss	 xmm0, DWORD PTR [edi+52]
  006a7	f3 0f 58 85 3c
	fe ff ff	 addss	 xmm0, DWORD PTR _v3Position$1$[ebp]
  006af	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 143  : 				OBBData.v3Max.y = v3Position.y + c_pCollisionData->fDimensions[1];

  006b4	f3 0f 10 47 38	 movss	 xmm0, DWORD PTR [edi+56]
  006b9	f3 0f 58 85 44
	fe ff ff	 addss	 xmm0, DWORD PTR _v3Position$2$[ebp]
  006c1	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 144  : 				OBBData.v3Max.z = v3Position.z + c_pCollisionData->fDimensions[2];

  006c6	f3 0f 58 5f 3c	 addss	 xmm3, DWORD PTR [edi+60]
  006cb	f3 0f 11 58 14	 movss	 DWORD PTR [eax+20], xmm3
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;

  006d0	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0
  006d7	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], 0
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 150  : 				D3DXMatrixIdentity(&OBBData.matRot); OBBData.matRot = *pMat;

  006de	8b 8d 48 fe ff
	ff		 mov	 ecx, DWORD PTR _pMat$GSCopy$1$[ebp]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;

  006e4	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0
  006eb	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0
  006f2	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0
  006f9	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
  00700	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0
  00707	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
  0070e	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
  00715	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
  0071c	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
  00723	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  0072a	c7 40 54 00 00
	80 3f		 mov	 DWORD PTR [eax+84], 1065353216 ; 3f800000H
  00731	c7 40 40 00 00
	80 3f		 mov	 DWORD PTR [eax+64], 1065353216 ; 3f800000H
  00738	c7 40 2c 00 00
	80 3f		 mov	 DWORD PTR [eax+44], 1065353216 ; 3f800000H
  0073f	c7 40 18 00 00
	80 3f		 mov	 DWORD PTR [eax+24], 1065353216 ; 3f800000H
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 150  : 				D3DXMatrixIdentity(&OBBData.matRot); OBBData.matRot = *pMat;

  00746	f3 0f 6f 01	 movdqu	 xmm0, XMMWORD PTR [ecx]
  0074a	5f		 pop	 edi
  0074b	f3 0f 7f 40 18	 movdqu	 XMMWORD PTR [eax+24], xmm0
  00750	f3 0f 6f 41 10	 movdqu	 xmm0, XMMWORD PTR [ecx+16]
  00755	f3 0f 7f 40 28	 movdqu	 XMMWORD PTR [eax+40], xmm0
  0075a	f3 0f 6f 41 20	 movdqu	 xmm0, XMMWORD PTR [ecx+32]
  0075f	f3 0f 7f 40 38	 movdqu	 XMMWORD PTR [eax+56], xmm0
  00764	f3 0f 6f 41 30	 movdqu	 xmm0, XMMWORD PTR [ecx+48]
  00769	f3 0f 7f 40 48	 movdqu	 XMMWORD PTR [eax+72], xmm0

; 151  : 				OBBData.matRot._41 = 0; OBBData.matRot._42 = 0; OBBData.matRot._43 = 0; OBBData.matRot._44 = 1;

  0076e	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0
  00775	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], 0
  0077c	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0
  00783	c7 40 54 00 00
	80 3f		 mov	 DWORD PTR [eax+84], 1065353216 ; 3f800000H

; 152  : 
; 153  : 
; 154  : 
; 155  : 
; 156  : 				return poci;

  0078a	8b c6		 mov	 eax, esi
  0078c	5e		 pop	 esi

; 192  : 			}
; 193  : 			break;
; 194  : 	}
; 195  : 	assert(false && "NOT_REACHED");
; 196  : 	return 0;
; 197  : }

  0078d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00790	33 cd		 xor	 ecx, ebp
  00792	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00797	8b e5		 mov	 esp, ebp
  00799	5d		 pop	 ebp
  0079a	c3		 ret	 0
$LN2@BuildColli:

; 157  : 			}
; 158  : 			break;
; 159  : 		case COLLISION_TYPE_SPHERE:
; 160  : 			{
; 161  : 				CSphereCollisionInstance * psci = gs_sci.Alloc();

  0079b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A ; gs_sci
  007a0	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEPAVCSphereCollisionInstance@@XZ ; CDynamicPool<CSphereCollisionInstance>::Alloc

; 162  : 
; 163  : 				D3DXMATRIX matTranslationLocal;
; 164  : 				D3DXMatrixTranslation(&matTranslationLocal, c_pCollisionData->v3Position.x, c_pCollisionData->v3Position.y, c_pCollisionData->v3Position.z);

  007a5	f3 0f 10 47 30	 movss	 xmm0, DWORD PTR [edi+48]
  007aa	83 ec 0c	 sub	 esp, 12			; 0000000cH
  007ad	8b f0		 mov	 esi, eax
  007af	8d 45 8c	 lea	 eax, DWORD PTR _matTranslationLocal$16[ebp]
  007b2	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  007b8	f3 0f 10 47 2c	 movss	 xmm0, DWORD PTR [edi+44]
  007bd	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  007c3	f3 0f 10 47 28	 movss	 xmm0, DWORD PTR [edi+40]
  007c8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007cd	50		 push	 eax
  007ce	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  007d3	ff b5 48 fe ff
	ff		 push	 DWORD PTR _pMat$GSCopy$1$[ebp]
  007d9	8d 45 8c	 lea	 eax, DWORD PTR _matTranslationLocal$16[ebp]
  007dc	50		 push	 eax
  007dd	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  007e3	50		 push	 eax
  007e4	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 165  : 				matTranslationLocal = matTranslationLocal * *pMat;

  007e9	f3 0f 6f 85 cc
	fe ff ff	 movdqu	 xmm0, XMMWORD PTR $T10[ebp]

; 166  : 
; 167  : 				TSphereData & SphereData = psci->GetAttribute();

  007f1	8b ce		 mov	 ecx, esi
  007f3	f3 0f 7f 45 8c	 movdqu	 XMMWORD PTR _matTranslationLocal$16[ebp], xmm0
  007f8	f3 0f 6f 85 dc
	fe ff ff	 movdqu	 xmm0, XMMWORD PTR $T10[ebp+16]
  00800	f3 0f 7f 45 9c	 movdqu	 XMMWORD PTR _matTranslationLocal$16[ebp+16], xmm0
  00805	f3 0f 6f 85 ec
	fe ff ff	 movdqu	 xmm0, XMMWORD PTR $T10[ebp+32]
  0080d	f3 0f 7f 45 ac	 movdqu	 XMMWORD PTR _matTranslationLocal$16[ebp+32], xmm0
  00812	f3 0f 6f 85 fc
	fe ff ff	 movdqu	 xmm0, XMMWORD PTR $T10[ebp+48]
  0081a	f3 0f 7f 85 2c
	fe ff ff	 movdqu	 XMMWORD PTR $T1[ebp], xmm0
  00822	f3 0f 7f 45 bc	 movdqu	 XMMWORD PTR _matTranslationLocal$16[ebp+48], xmm0
  00827	e8 00 00 00 00	 call	 ?GetAttribute@CSphereCollisionInstance@@QAEAAUSSphereData@@XZ ; CSphereCollisionInstance::GetAttribute

; 168  : 				SphereData.v3Position.x = matTranslationLocal._41;

  0082c	f3 0f 6f 85 2c
	fe ff ff	 movdqu	 xmm0, XMMWORD PTR $T1[ebp]
  00834	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 169  : 				SphereData.v3Position.y = matTranslationLocal._42;

  00838	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _matTranslationLocal$16[ebp+52]
  0083d	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 170  : 				SphereData.v3Position.z = matTranslationLocal._43;

  00842	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _matTranslationLocal$16[ebp+56]
  00847	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 171  : 				SphereData.fRadius = c_pCollisionData->fDimensions[0];

  0084c	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  0084f	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 172  : 
; 173  : 				return psci;

  00852	8b c6		 mov	 eax, esi
  00854	5f		 pop	 edi
  00855	5e		 pop	 esi

; 192  : 			}
; 193  : 			break;
; 194  : 	}
; 195  : 	assert(false && "NOT_REACHED");
; 196  : 	return 0;
; 197  : }

  00856	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00859	33 cd		 xor	 ecx, ebp
  0085b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00860	8b e5		 mov	 esp, ebp
  00862	5d		 pop	 ebp
  00863	c3		 ret	 0
$LN1@BuildColli:

; 174  : 			}
; 175  : 			break;
; 176  : 		case COLLISION_TYPE_CYLINDER:
; 177  : 			{
; 178  : 				CCylinderCollisionInstance * pcci = gs_cci.Alloc();

  00864	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A ; gs_cci
  00869	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEPAVCCylinderCollisionInstance@@XZ ; CDynamicPool<CCylinderCollisionInstance>::Alloc

; 179  : 
; 180  : 				D3DXMATRIX matTranslationLocal;
; 181  : 				D3DXMatrixTranslation(&matTranslationLocal, c_pCollisionData->v3Position.x, c_pCollisionData->v3Position.y, c_pCollisionData->v3Position.z);

  0086e	f3 0f 10 47 30	 movss	 xmm0, DWORD PTR [edi+48]
  00873	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00876	8b f0		 mov	 esi, eax
  00878	8d 45 8c	 lea	 eax, DWORD PTR _matTranslationLocal$15[ebp]
  0087b	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00881	f3 0f 10 47 2c	 movss	 xmm0, DWORD PTR [edi+44]
  00886	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0088c	f3 0f 10 47 28	 movss	 xmm0, DWORD PTR [edi+40]
  00891	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00896	50		 push	 eax
  00897	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  0089c	ff b5 48 fe ff
	ff		 push	 DWORD PTR _pMat$GSCopy$1$[ebp]
  008a2	8d 45 8c	 lea	 eax, DWORD PTR _matTranslationLocal$15[ebp]
  008a5	50		 push	 eax
  008a6	8d 85 0c ff ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  008ac	50		 push	 eax
  008ad	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 182  : 				matTranslationLocal = matTranslationLocal * *pMat;

  008b2	f3 0f 6f 85 0c
	ff ff ff	 movdqu	 xmm0, XMMWORD PTR $T11[ebp]

; 183  : 
; 184  : 				TCylinderData & CylinderData = pcci->GetAttribute();

  008ba	8b ce		 mov	 ecx, esi
  008bc	f3 0f 7f 45 8c	 movdqu	 XMMWORD PTR _matTranslationLocal$15[ebp], xmm0
  008c1	f3 0f 6f 85 1c
	ff ff ff	 movdqu	 xmm0, XMMWORD PTR $T11[ebp+16]
  008c9	f3 0f 7f 45 9c	 movdqu	 XMMWORD PTR _matTranslationLocal$15[ebp+16], xmm0
  008ce	f3 0f 6f 85 2c
	ff ff ff	 movdqu	 xmm0, XMMWORD PTR $T11[ebp+32]
  008d6	f3 0f 7f 45 ac	 movdqu	 XMMWORD PTR _matTranslationLocal$15[ebp+32], xmm0
  008db	f3 0f 6f 85 3c
	ff ff ff	 movdqu	 xmm0, XMMWORD PTR $T11[ebp+48]
  008e3	f3 0f 7f 45 bc	 movdqu	 XMMWORD PTR _matTranslationLocal$15[ebp+48], xmm0
  008e8	e8 00 00 00 00	 call	 ?GetAttribute@CCylinderCollisionInstance@@QAEAAUSCylinderData@@XZ ; CCylinderCollisionInstance::GetAttribute

; 185  : 				CylinderData.fRadius = c_pCollisionData->fDimensions[0];

  008ed	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  008f0	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 186  : 				CylinderData.fHeight = c_pCollisionData->fDimensions[1];

  008f3	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
  008f6	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 187  : 				CylinderData.v3Position.x = matTranslationLocal._41;

  008f9	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _matTranslationLocal$15[ebp+48]
  008fe	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 188  : 				CylinderData.v3Position.y = matTranslationLocal._42;

  00902	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _matTranslationLocal$15[ebp+52]
  00907	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 189  : 				CylinderData.v3Position.z = matTranslationLocal._43 /*+ CylinderData.fHeight/2.0f*/;

  0090c	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _matTranslationLocal$15[ebp+56]
  00911	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 190  : 
; 191  : 				return pcci;

  00916	8b c6		 mov	 eax, esi
  00918	5f		 pop	 edi
  00919	5e		 pop	 esi

; 192  : 			}
; 193  : 			break;
; 194  : 	}
; 195  : 	assert(false && "NOT_REACHED");
; 196  : 	return 0;
; 197  : }

  0091a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0091d	33 cd		 xor	 ecx, ebp
  0091f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00924	8b e5		 mov	 esp, ebp
  00926	5d		 pop	 ebp
  00927	c3		 ret	 0
$LN10@BuildColli:
  00928	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0092b	33 c0		 xor	 eax, eax
  0092d	5f		 pop	 edi
  0092e	33 cd		 xor	 ecx, ebp
  00930	5e		 pop	 esi
  00931	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00936	8b e5		 mov	 esp, ebp
  00938	5d		 pop	 ebp
  00939	c3		 ret	 0
  0093a	8b ff		 npad	 2
$LN105@BuildColli:
  0093c	00 00 00 00	 DD	 $LN9@BuildColli
  00940	00 00 00 00	 DD	 $LN10@BuildColli
  00944	00 00 00 00	 DD	 $LN2@BuildColli
  00948	00 00 00 00	 DD	 $LN1@BuildColli
  0094c	00 00 00 00	 DD	 $LN4@BuildColli
  00950	00 00 00 00	 DD	 $LN3@BuildColli
?BuildCollisionInstance@CBaseCollisionInstance@@SAPAV1@PBVCStaticCollisionData@@PBUD3DXMATRIX@@@Z ENDP ; CBaseCollisionInstance::BuildCollisionInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?Destroy@CBaseCollisionInstance@@QAEXXZ
_TEXT	SEGMENT
?Destroy@CBaseCollisionInstance@@QAEXXZ PROC		; CBaseCollisionInstance::Destroy, COMDAT
; _this$ = ecx

; 201  : 	OnDestroy();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 60 10	 jmp	 DWORD PTR [eax+16]
?Destroy@CBaseCollisionInstance@@QAEXXZ ENDP		; CBaseCollisionInstance::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp
;	COMDAT ?DestroyCollisionInstanceSystem@@YAXXZ
_TEXT	SEGMENT
?DestroyCollisionInstanceSystem@@YAXXZ PROC		; DestroyCollisionInstanceSystem, COMDAT

; 25   : {

  00000	53		 push	 ebx
  00001	8b 1d 08 00 00
	00		 mov	 ebx, DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+8
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+4
  00010	2b de		 sub	 ebx, esi
  00012	83 c3 03	 add	 ebx, 3
  00015	c1 eb 02	 shr	 ebx, 2
  00018	57		 push	 edi
  00019	33 ff		 xor	 edi, edi
  0001b	3b 35 08 00 00
	00		 cmp	 esi, DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+8
  00021	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  00024	85 db		 test	 ebx, ebx
  00026	74 18		 je	 SHORT $LN31@DestroyCol
$LL33@DestroyCol:

; 24   : 		_Func(*_First);

  00028	ff 36		 push	 DWORD PTR [esi]
  0002a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPool@VCSphereCollisionInstance@@@@KAXPAVCSphereCollisionInstance@@@Z ; CDynamicPool<CSphereCollisionInstance>::Delete
  0002f	47		 inc	 edi
  00030	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00033	83 c4 04	 add	 esp, 4
  00036	3b fb		 cmp	 edi, ebx
  00038	75 ee		 jne	 SHORT $LL33@DestroyCol

; 23   : 	for (; _First != _Last; ++_First)

  0003a	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+4
$LN31@DestroyCol:
  00040	8b 1d 08 00 00
	00		 mov	 ebx, DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+8
  00046	33 c9		 xor	 ecx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00048	a1 10 00 00 00	 mov	 eax, DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+16
  0004d	33 ff		 xor	 edi, edi
  0004f	89 35 08 00 00
	00		 mov	 DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+8, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  00055	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+4
  0005b	2b de		 sub	 ebx, esi
  0005d	83 c3 03	 add	 ebx, 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00060	a3 14 00 00 00	 mov	 DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+20, eax
  00065	c1 eb 02	 shr	 ebx, 2
  00068	3b 35 08 00 00
	00		 cmp	 esi, DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+8
  0006e	0f 47 d9	 cmova	 ebx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00071	85 db		 test	 ebx, ebx
  00073	74 18		 je	 SHORT $LN74@DestroyCol
$LL76@DestroyCol:

; 24   : 		_Func(*_First);

  00075	ff 36		 push	 DWORD PTR [esi]
  00077	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPool@VCCylinderCollisionInstance@@@@KAXPAVCCylinderCollisionInstance@@@Z ; CDynamicPool<CCylinderCollisionInstance>::Delete
  0007c	47		 inc	 edi
  0007d	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00080	83 c4 04	 add	 esp, 4
  00083	3b fb		 cmp	 edi, ebx
  00085	75 ee		 jne	 SHORT $LL76@DestroyCol

; 23   : 	for (; _First != _Last; ++_First)

  00087	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+4
$LN74@DestroyCol:
  0008d	8b 1d 08 00 00
	00		 mov	 ebx, DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+8
  00093	33 c9		 xor	 ecx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00095	a1 10 00 00 00	 mov	 eax, DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+16
  0009a	33 ff		 xor	 edi, edi
  0009c	89 35 08 00 00
	00		 mov	 DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+8, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  000a2	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+4
  000a8	2b de		 sub	 ebx, esi
  000aa	83 c3 03	 add	 ebx, 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  000ad	a3 14 00 00 00	 mov	 DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+20, eax
  000b2	c1 eb 02	 shr	 ebx, 2
  000b5	3b 35 08 00 00
	00		 cmp	 esi, DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+8
  000bb	0f 47 d9	 cmova	 ebx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  000be	85 db		 test	 ebx, ebx
  000c0	74 18		 je	 SHORT $LN117@DestroyCol
$LL119@DestroyCol:

; 24   : 		_Func(*_First);

  000c2	ff 36		 push	 DWORD PTR [esi]
  000c4	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPool@VCPlaneCollisionInstance@@@@KAXPAVCPlaneCollisionInstance@@@Z ; CDynamicPool<CPlaneCollisionInstance>::Delete
  000c9	47		 inc	 edi
  000ca	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  000cd	83 c4 04	 add	 esp, 4
  000d0	3b fb		 cmp	 edi, ebx
  000d2	75 ee		 jne	 SHORT $LL119@DestroyCol

; 23   : 	for (; _First != _Last; ++_First)

  000d4	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+4
$LN117@DestroyCol:
  000da	8b 1d 08 00 00
	00		 mov	 ebx, DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+8
  000e0	33 c9		 xor	 ecx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  000e2	a1 10 00 00 00	 mov	 eax, DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+16
  000e7	33 ff		 xor	 edi, edi
  000e9	89 35 08 00 00
	00		 mov	 DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+8, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  000ef	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+4
  000f5	2b de		 sub	 ebx, esi
  000f7	83 c3 03	 add	 ebx, 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  000fa	a3 14 00 00 00	 mov	 DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+20, eax
  000ff	c1 eb 02	 shr	 ebx, 2
  00102	3b 35 08 00 00
	00		 cmp	 esi, DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+8
  00108	0f 47 d9	 cmova	 ebx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  0010b	85 db		 test	 ebx, ebx
  0010d	74 19		 je	 SHORT $LN160@DestroyCol
  0010f	90		 npad	 1
$LL162@DestroyCol:

; 24   : 		_Func(*_First);

  00110	ff 36		 push	 DWORD PTR [esi]
  00112	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPool@VCAABBCollisionInstance@@@@KAXPAVCAABBCollisionInstance@@@Z ; CDynamicPool<CAABBCollisionInstance>::Delete
  00117	47		 inc	 edi
  00118	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0011b	83 c4 04	 add	 esp, 4
  0011e	3b fb		 cmp	 edi, ebx
  00120	75 ee		 jne	 SHORT $LL162@DestroyCol

; 23   : 	for (; _First != _Last; ++_First)

  00122	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+4
$LN160@DestroyCol:
  00128	8b 1d 08 00 00
	00		 mov	 ebx, DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+8
  0012e	33 c9		 xor	 ecx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00130	a1 10 00 00 00	 mov	 eax, DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+16
  00135	33 ff		 xor	 edi, edi
  00137	89 35 08 00 00
	00		 mov	 DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+8, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0013d	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+4
  00143	2b de		 sub	 ebx, esi
  00145	83 c3 03	 add	 ebx, 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00148	a3 14 00 00 00	 mov	 DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+20, eax
  0014d	c1 eb 02	 shr	 ebx, 2
  00150	3b 35 08 00 00
	00		 cmp	 esi, DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+8
  00156	0f 47 d9	 cmova	 ebx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00159	85 db		 test	 ebx, ebx
  0015b	74 2d		 je	 SHORT $LN238@DestroyCol
  0015d	8d 49 00	 npad	 3
$LL205@DestroyCol:

; 24   : 		_Func(*_First);

  00160	ff 36		 push	 DWORD PTR [esi]
  00162	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPool@VCOBBCollisionInstance@@@@KAXPAVCOBBCollisionInstance@@@Z ; CDynamicPool<COBBCollisionInstance>::Delete
  00167	47		 inc	 edi
  00168	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0016b	83 c4 04	 add	 esp, 4
  0016e	3b fb		 cmp	 edi, ebx
  00170	75 ee		 jne	 SHORT $LL205@DestroyCol
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00172	a1 04 00 00 00	 mov	 eax, DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+4
  00177	5f		 pop	 edi
  00178	a3 08 00 00 00	 mov	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+8, eax
  0017d	a1 10 00 00 00	 mov	 eax, DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+16
  00182	5e		 pop	 esi
  00183	a3 14 00 00 00	 mov	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+20, eax
  00188	5b		 pop	 ebx
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 31   : }

  00189	c3		 ret	 0
$LN238@DestroyCol:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0018a	a1 10 00 00 00	 mov	 eax, DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+16
  0018f	5f		 pop	 edi
  00190	89 35 08 00 00
	00		 mov	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+8, esi
  00196	5e		 pop	 esi
  00197	a3 14 00 00 00	 mov	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+20, eax
  0019c	5b		 pop	 ebx
; File c:\gamepackages\client\tools\patcher2017\eterlib\collisiondata.cpp

; 31   : }

  0019d	c3		 ret	 0
?DestroyCollisionInstanceSystem@@YAXXZ ENDP		; DestroyCollisionInstanceSystem
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SCylinderData@@QAE@XZ
_TEXT	SEGMENT
??0SCylinderData@@QAE@XZ PROC				; SCylinderData::SCylinderData, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0SCylinderData@@QAE@XZ ENDP				; SCylinderData::SCylinderData
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SOBBData@@QAE@XZ
_TEXT	SEGMENT
??0SOBBData@@QAE@XZ PROC				; SOBBData::SOBBData, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0SOBBData@@QAE@XZ ENDP				; SOBBData::SOBBData
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SAABBData@@QAE@XZ
_TEXT	SEGMENT
??0SAABBData@@QAE@XZ PROC				; SAABBData::SAABBData, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0SAABBData@@QAE@XZ ENDP				; SAABBData::SAABBData
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SPlaneData@@QAE@XZ
_TEXT	SEGMENT
??0SPlaneData@@QAE@XZ PROC				; SPlaneData::SPlaneData, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0SPlaneData@@QAE@XZ ENDP				; SPlaneData::SPlaneData
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SSphereData@@QAE@XZ
_TEXT	SEGMENT
??0SSphereData@@QAE@XZ PROC				; SSphereData::SSphereData, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0SSphereData@@QAE@XZ ENDP				; SSphereData::SSphereData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 55   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 65   : 	}

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   : 	return (_Where);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 61   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
;	COMDAT ?D3DXMatrixIdentity@@YAPAUD3DXMATRIX@@PAU1@@Z
_TEXT	SEGMENT
_pOut$ = 8						; size = 4
?D3DXMatrixIdentity@@YAPAUD3DXMATRIX@@PAU1@@Z PROC	; D3DXMatrixIdentity, COMDAT

; 1510 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1511 : #ifdef D3DX_DEBUG
; 1512 :     if(!pOut)
; 1513 :         return NULL;
; 1514 : #endif
; 1515 : 
; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =
; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pOut$[ebp]
  00006	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
  0000d	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0
  00014	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
  0001b	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
  00022	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
  00029	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
  00030	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
  00037	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
  0003e	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  00045	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  0004c	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00053	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  0005a	c7 40 3c 00 00
	80 3f		 mov	 DWORD PTR [eax+60], 1065353216 ; 3f800000H
  00061	c7 40 28 00 00
	80 3f		 mov	 DWORD PTR [eax+40], 1065353216 ; 3f800000H
  00068	c7 40 14 00 00
	80 3f		 mov	 DWORD PTR [eax+20], 1065353216 ; 3f800000H
  0006f	c7 00 00 00 80
	3f		 mov	 DWORD PTR [eax], 1065353216 ; 3f800000H

; 1522 :     return pOut;
; 1523 : }

  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?D3DXMatrixIdentity@@YAPAUD3DXMATRIX@@PAU1@@Z ENDP	; D3DXMatrixIdentity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z
_TEXT	SEGMENT
_v$ = -12						; size = 12
_pOut$ = 8						; size = 4
_pV1$ = 12						; size = 4
_pV2$ = 16						; size = 4
?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z PROC	; D3DXVec3Cross, COMDAT

; 1269 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1270 :     D3DXVECTOR3 v;
; 1271 : 
; 1272 : #ifdef D3DX_DEBUG
; 1273 :     if(!pOut || !pV1 || !pV2)
; 1274 :         return NULL;
; 1275 : #endif
; 1276 : 
; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00006	8b 45 10	 mov	 eax, DWORD PTR _pV2$[ebp]
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _pV1$[ebp]
  0000c	f3 0f 10 78 08	 movss	 xmm7, DWORD PTR [eax+8]
  00011	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00016	f3 0f 59 41 08	 mulss	 xmm0, DWORD PTR [ecx+8]
  0001b	f3 0f 59 79 04	 mulss	 xmm7, DWORD PTR [ecx+4]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00020	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  00024	f3 0f 10 11	 movss	 xmm2, DWORD PTR [ecx]
  00028	0f 28 cb	 movaps	 xmm1, xmm3
  0002b	f3 0f 59 49 08	 mulss	 xmm1, DWORD PTR [ecx+8]
  00030	f3 0f 5c f8	 subss	 xmm7, xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00034	f3 0f 59 59 04	 mulss	 xmm3, DWORD PTR [ecx+4]
  00039	0f 28 c2	 movaps	 xmm0, xmm2
  0003c	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  00041	f3 0f 59 50 04	 mulss	 xmm2, DWORD PTR [eax+4]

; 1280 : 
; 1281 :     *pOut = v;

  00046	8b 45 08	 mov	 eax, DWORD PTR _pOut$[ebp]
  00049	f3 0f 5c c8	 subss	 xmm1, xmm0
  0004d	f3 0f 5c d3	 subss	 xmm2, xmm3
  00051	0f 14 f9	 unpcklps xmm7, xmm1
  00054	66 0f d6 38	 movq	 QWORD PTR [eax], xmm7
  00058	f3 0f 11 55 fc	 movss	 DWORD PTR _v$[ebp+8], xmm2
  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _v$[ebp+8]
  00060	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1282 :     return pOut;
; 1283 : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z ENDP	; D3DXVec3Cross
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
_pV1$ = 8						; size = 4
_pV2$ = 12						; size = 4
?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z PROC		; D3DXVec3Dot, COMDAT

; 1258 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pV1$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR _pV2$[ebp]
  00009	d9 41 04	 fld	 DWORD PTR [ecx+4]
  0000c	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0000f	d9 01		 fld	 DWORD PTR [ecx]
  00011	d8 08		 fmul	 DWORD PTR [eax]
  00013	de c1		 faddp	 ST(1), ST(0)
  00015	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00018	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0001b	de c1		 faddp	 ST(1), ST(0)

; 1265 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z ENDP		; D3DXVec3Dot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
tv160 = 8						; size = 4
_pV$ = 8						; size = 4
?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z PROC		; D3DXVec3LengthSq, COMDAT

; 1247 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pV$[ebp]
  00006	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0000b	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  0000f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00014	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00018	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0001c	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00020	f3 0f 58 d1	 addss	 xmm2, xmm1
  00024	f3 0f 58 d0	 addss	 xmm2, xmm0
  00028	f3 0f 11 55 08	 movss	 DWORD PTR tv160[ebp], xmm2
  0002d	d9 45 08	 fld	 DWORD PTR tv160[ebp]

; 1254 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z ENDP		; D3DXVec3LengthSq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
tv161 = -4						; size = 4
_pV$ = 8						; size = 4
?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z PROC		; D3DXVec3Length, COMDAT

; 1232 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  00009	8b 45 08	 mov	 eax, DWORD PTR _pV$[ebp]
  0000c	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  00011	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  00015	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0001a	f3 0f 59 d2	 mulss	 xmm2, xmm2
  0001e	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00022	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00026	f3 0f 58 d1	 addss	 xmm2, xmm1
  0002a	f3 0f 58 d0	 addss	 xmm2, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  0002e	0f 5a c2	 cvtps2pd xmm0, xmm2
  00031	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00036	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  0003a	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv161[esp+8], xmm0
  00040	d9 44 24 04	 fld	 DWORD PTR tv161[esp+8]

; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z ENDP		; D3DXVec3Length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
;	COMDAT ??DD3DXMATRIX@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_mat$ = 12						; size = 4
??DD3DXMATRIX@@QBE?AU0@ABU0@@Z PROC			; D3DXMATRIX::operator*, COMDAT
; _this$ = ecx

; 578  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  00003	ff 75 0c	 push	 DWORD PTR _mat$[ebp]
  00006	51		 push	 ecx
  00007	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0000a	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 581  :     return matT;

  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 582  : }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??DD3DXMATRIX@@QBE?AU0@ABU0@@Z ENDP			; D3DXMATRIX::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.h
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
??0D3DXMATRIX@@QAE@XZ PROC				; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 177  :     D3DXMATRIX() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
;	COMDAT ??D@YA?AUD3DXVECTOR3@@MABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_f$ = 12						; size = 4
_v$ = 16						; size = 4
??D@YA?AUD3DXVECTOR3@@MABU0@@Z PROC			; operator*, COMDAT

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]

; 180  :     x = fx;

  0000b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0000e	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00012	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 180  :     x = fx;

  00016	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0001a	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0001f	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 181  :     y = fy;

  00023	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00028	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0002d	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 182  :     z = fz;

  00031	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 284  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??D@YA?AUD3DXVECTOR3@@MABU0@@Z ENDP			; operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
;	COMDAT ??KD3DXVECTOR3@@QBE?AU0@M@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_f$ = 12						; size = 4
??KD3DXVECTOR3@@QBE?AU0@M@Z PROC			; D3DXVECTOR3::operator/, COMDAT
; _this$ = ecx

; 274  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 275  :     FLOAT fInv = 1.0f / f;

  00003	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0000b	f3 0f 5e 4d 0c	 divss	 xmm1, DWORD PTR _f$[ebp]

; 180  :     x = fx;

  00010	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);

  00013	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00017	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 180  :     x = fx;

  0001b	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);

  0001f	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00024	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 181  :     y = fy;

  00028	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);

  0002d	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00032	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 182  :     z = fz;

  00036	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 277  : }

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??KD3DXVECTOR3@@QBE?AU0@M@Z ENDP			; D3DXVECTOR3::operator/
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
;	COMDAT ??DD3DXVECTOR3@@QBE?AU0@M@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_f$ = 12						; size = 4
??DD3DXVECTOR3@@QBE?AU0@M@Z PROC			; D3DXVECTOR3::operator*, COMDAT
; _this$ = ecx

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00003	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]
  00008	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]

; 180  :     x = fx;

  0000c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  0000f	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 180  :     x = fx;

  00013	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00017	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0001c	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 181  :     y = fy;

  00020	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00025	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0002a	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 182  :     z = fz;

  0002e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 270  : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??DD3DXVECTOR3@@QBE?AU0@M@Z ENDP			; D3DXVECTOR3::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
;	COMDAT ??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator-, COMDAT
; _this$ = ecx

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]

; 180  :     x = fx;

  0000a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0000d	f3 0f 5c 02	 subss	 xmm0, DWORD PTR [edx]

; 180  :     x = fx;

  00011	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00015	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0001a	f3 0f 5c 42 04	 subss	 xmm0, DWORD PTR [edx+4]

; 181  :     y = fy;

  0001f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00024	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00029	f3 0f 5c 42 08	 subss	 xmm0, DWORD PTR [edx+8]

; 182  :     z = fz;

  0002e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 264  : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
;	COMDAT ??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator+, COMDAT
; _this$ = ecx

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]

; 180  :     x = fx;

  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00009	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  0000d	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]

; 180  :     x = fx;

  00011	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00015	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  0001a	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]

; 181  :     y = fy;

  0001f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00024	f3 0f 10 42 08	 movss	 xmm0, DWORD PTR [edx+8]
  00029	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]

; 182  :     z = fz;

  0002e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 258  : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
;	COMDAT ??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z PROC			; D3DXVECTOR3::operator+=, COMDAT
; _this$ = ecx

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  :     x += v.x;

  00003	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00006	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0000a	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]
  0000e	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 205  :     y += v.y;

  00012	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00017	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]
  0001c	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0

; 206  :     z += v.z;

  00021	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]

; 207  :     return *this;

  00026	8b c1		 mov	 eax, ecx
  00028	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]
  0002d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0

; 208  : }

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 180  :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]

; 181  :     y = fy;
; 182  :     z = fz;
; 183  : }

  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 89   :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
tv65 = -4						; size = 4
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 1136 :         {return (sqrtf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 775  :     return (float)sqrt(_X);

  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00016	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0

; 1136 :         {return (sqrtf(_X)); }

  0001a	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv65[esp+8], xmm0
  00020	d9 44 24 04	 fld	 DWORD PTR tv65[esp+8]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
tv65 = 8						; size = 4
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 1066 :         {return (fabsf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 687  :     return (float)fabs(_X);

  00008	0f 5a c0	 cvtps2pd xmm0, xmm0
  0000b	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00013	66 0f 5a c0	 cvtpd2ps xmm0, xmm0

; 1066 :         {return (fabsf(_X)); }

  00017	f3 0f 11 45 08	 movss	 DWORD PTR tv65[ebp], xmm0
  0001c	d9 45 08	 fld	 DWORD PTR tv65[ebp]
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv68 = -4						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 774  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 775  :     return (float)sqrt(_X);

  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00016	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0001a	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv68[esp+8], xmm0
  00020	d9 44 24 04	 fld	 DWORD PTR tv68[esp+8]

; 776  : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv68 = 8						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 686  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 687  :     return (float)fabs(_X);

  00008	0f 5a c0	 cvtps2pd xmm0, xmm0
  0000b	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00013	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00017	f3 0f 11 45 08	 movss	 DWORD PTR tv68[ebp], xmm0
  0001c	d9 45 08	 fld	 DWORD PTR tv68[ebp]

; 688  : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
_fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	4e		 dec	 esi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	57		 push	 edi
  0000f	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b cf		 mov	 ecx, edi
  00014	ff d3		 call	 ebx
  00016	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  00019	4e		 dec	 esi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5f		 pop	 edi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
