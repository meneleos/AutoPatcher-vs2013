; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\GamePackages\Client\Tools\Patcher2017\EterLib\GrpMath.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_atan2f
PUBLIC	_sqrtf
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
PUBLIC	??DD3DXMATRIX@@QBE?AU0@ABU0@@Z			; D3DXMATRIX::operator*
PUBLIC	??0D3DXQUATERNION@@QAE@XZ			; D3DXQUATERNION::D3DXQUATERNION
PUBLIC	??0D3DXQUATERNION@@QAE@MMMM@Z			; D3DXQUATERNION::D3DXQUATERNION
PUBLIC	?D3DXQuaternionConjugate@@YAPAUD3DXQUATERNION@@PAU1@PBU1@@Z ; D3DXQuaternionConjugate
PUBLIC	?CrossProduct2D@@YAMMMMM@Z			; CrossProduct2D
PUBLIC	?IsInTriangle2D@@YA_NMMMMMMMM@Z			; IsInTriangle2D
PUBLIC	?D3DXVec3Rotation@@YAPAUD3DXVECTOR3@@PAU1@PBU1@PBUD3DXQUATERNION@@@Z ; D3DXVec3Rotation
PUBLIC	?GetRotationFromMatrix@@YAXPAUD3DXVECTOR3@@PBUD3DXMATRIX@@@Z ; GetRotationFromMatrix
PUBLIC	?GetPivotAndRotationFromMatrix@@YAXPAUD3DXMATRIX@@PAUD3DXVECTOR3@@1@Z ; GetPivotAndRotationFromMatrix
PUBLIC	?ExtractMovement@@YAXPAUD3DXMATRIX@@0@Z		; ExtractMovement
PUBLIC	__real@00000000
PUBLIC	__real@3727c5ac
PUBLIC	__real@3f800000
PUBLIC	__real@3fc90fdb
PUBLIC	__real@bfc90fdb
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_D3DXMatrixMultiply@12:PROC
EXTRN	_D3DXMatrixTranslation@16:PROC
EXTRN	_D3DXMatrixRotationX@8:PROC
EXTRN	_D3DXMatrixRotationY@8:PROC
EXTRN	_D3DXMatrixRotationZ@8:PROC
EXTRN	_D3DXQuaternionMultiply@12:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CIatan2:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bfc90fdb
CONST	SEGMENT
__real@bfc90fdb DD 0bfc90fdbr			; -1.5708
CONST	ENDS
;	COMDAT __real@3fc90fdb
CONST	SEGMENT
__real@3fc90fdb DD 03fc90fdbr			; 1.5708
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-005
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
;	COMDAT ?ExtractMovement@@YAXPAUD3DXMATRIX@@0@Z
_TEXT	SEGMENT
_v3Rotation$ = -476					; size = 12
_v3Pivot$ = -464					; size = 12
_matTranslation$ = -452					; size = 64
$T1 = -388						; size = 64
$T2 = -324						; size = 64
_matRotationY$ = -260					; size = 64
_matRotationZ$ = -196					; size = 64
_matRotationX$ = -132					; size = 64
$T3 = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pTargetMatrix$ = 8					; size = 4
_pSourceMatrix$ = 12					; size = 4
?ExtractMovement@@YAXPAUD3DXMATRIX@@0@Z PROC		; ExtractMovement, COMDAT

; 120  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 01 00
	00		 sub	 esp, 476		; 000001dcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _pTargetMatrix$[ebp]

; 121  : 	D3DXVECTOR3 v3Pivot;
; 122  : 	D3DXVECTOR3 v3Rotation;
; 123  : 	GetPivotAndRotationFromMatrix(pSourceMatrix, &v3Pivot, &v3Rotation);

  00017	8d 85 24 fe ff
	ff		 lea	 eax, DWORD PTR _v3Rotation$[ebp]
  0001d	50		 push	 eax
  0001e	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR _v3Pivot$[ebp]
  00024	50		 push	 eax
  00025	ff 75 0c	 push	 DWORD PTR _pSourceMatrix$[ebp]
  00028	e8 00 00 00 00	 call	 ?GetPivotAndRotationFromMatrix@@YAXPAUD3DXMATRIX@@PAUD3DXVECTOR3@@1@Z ; GetPivotAndRotationFromMatrix

; 124  : 
; 125  : 	D3DXMATRIX matRotationX;
; 126  : 	D3DXMatrixRotationX(&matRotationX, v3Rotation.x);

  0002d	f3 0f 10 85 24
	fe ff ff	 movss	 xmm0, DWORD PTR _v3Rotation$[ebp]
  00035	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _matRotationX$[ebp]
  0003b	83 c4 08	 add	 esp, 8
  0003e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 _D3DXMatrixRotationX@8

; 127  : 	D3DXMATRIX matRotationY;
; 128  : 	D3DXMatrixRotationY(&matRotationY, v3Rotation.y);

  00049	f3 0f 10 85 28
	fe ff ff	 movss	 xmm0, DWORD PTR _v3Rotation$[ebp+4]
  00051	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _matRotationY$[ebp]
  00057	51		 push	 ecx
  00058	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _D3DXMatrixRotationY@8

; 129  : 	D3DXMATRIX matRotationZ;
; 130  : 	D3DXMatrixRotationZ(&matRotationZ, v3Rotation.z);

  00063	f3 0f 10 85 2c
	fe ff ff	 movss	 xmm0, DWORD PTR _v3Rotation$[ebp+8]
  0006b	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _matRotationZ$[ebp]
  00071	51		 push	 ecx
  00072	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 _D3DXMatrixRotationZ@8

; 131  : 
; 132  : 	D3DXMATRIX matTranslation;
; 133  : 	D3DXMatrixTranslation(&matTranslation, v3Pivot.x, v3Pivot.y, v3Pivot.z);

  0007d	f3 0f 10 85 38
	fe ff ff	 movss	 xmm0, DWORD PTR _v3Pivot$[ebp+8]
  00085	8d 85 3c fe ff
	ff		 lea	 eax, DWORD PTR _matTranslation$[ebp]
  0008b	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0008e	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00094	f3 0f 10 85 34
	fe ff ff	 movss	 xmm0, DWORD PTR _v3Pivot$[ebp+4]
  0009c	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000a2	f3 0f 10 85 30
	fe ff ff	 movss	 xmm0, DWORD PTR _v3Pivot$[ebp]
  000aa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  000b5	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _matRotationY$[ebp]
  000bb	50		 push	 eax
  000bc	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _matRotationX$[ebp]
  000c2	50		 push	 eax
  000c3	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12
  000cf	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _matRotationZ$[ebp]
  000d5	50		 push	 eax
  000d6	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000dc	50		 push	 eax
  000dd	8d 85 7c fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12
  000e9	8d 85 3c fe ff
	ff		 lea	 eax, DWORD PTR _matTranslation$[ebp]
  000ef	50		 push	 eax
  000f0	8d 85 7c fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  000f6	50		 push	 eax
  000f7	8d 45 bc	 lea	 eax, DWORD PTR $T3[ebp]
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp

; 135  : 	*pTargetMatrix = matRotationX * matRotationY * matRotationZ * matTranslation;

  00100	f3 0f 6f 45 bc	 movdqu	 xmm0, XMMWORD PTR $T3[ebp]

; 136  : }

  00105	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00108	33 cd		 xor	 ecx, ebp
  0010a	f3 0f 7f 06	 movdqu	 XMMWORD PTR [esi], xmm0
  0010e	f3 0f 6f 45 cc	 movdqu	 xmm0, XMMWORD PTR $T3[ebp+16]
  00113	f3 0f 7f 46 10	 movdqu	 XMMWORD PTR [esi+16], xmm0
  00118	f3 0f 6f 45 dc	 movdqu	 xmm0, XMMWORD PTR $T3[ebp+32]
  0011d	f3 0f 7f 46 20	 movdqu	 XMMWORD PTR [esi+32], xmm0
  00122	f3 0f 6f 45 ec	 movdqu	 xmm0, XMMWORD PTR $T3[ebp+48]
  00127	f3 0f 7f 46 30	 movdqu	 XMMWORD PTR [esi+48], xmm0
  0012c	5e		 pop	 esi
  0012d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c3		 ret	 0
?ExtractMovement@@YAXPAUD3DXMATRIX@@0@Z ENDP		; ExtractMovement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
;	COMDAT ?GetPivotAndRotationFromMatrix@@YAXPAUD3DXMATRIX@@PAUD3DXVECTOR3@@1@Z
_TEXT	SEGMENT
_x$1$ = -16						; size = 4
_x$ = -16						; size = 4
_y$ = -12						; size = 4
tv307 = -8						; size = 8
tv304 = -8						; size = 8
tv295 = -8						; size = 8
tv292 = -8						; size = 8
tv284 = -8						; size = 8
tv281 = -8						; size = 8
tv273 = -8						; size = 8
tv270 = -8						; size = 8
_z$ = -8						; size = 4
_pMatrix$ = 8						; size = 4
_pPivot$ = 12						; size = 4
_pRotation$ = 16					; size = 4
?GetPivotAndRotationFromMatrix@@YAXPAUD3DXMATRIX@@PAUD3DXVECTOR3@@1@Z PROC ; GetPivotAndRotationFromMatrix, COMDAT

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 88   : 	float sx = pMatrix->_32;
; 89   : 	float cx = sqrtf(1.0f - sx * sx);

  00006	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0000e	83 ec 14	 sub	 esp, 20			; 00000014H
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _pMatrix$[ebp]
  00015	f3 0f 10 4e 24	 movss	 xmm1, DWORD PTR [esi+36]
  0001a	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0001e	f3 0f 5c c1	 subss	 xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  00022	0f 5a c0	 cvtps2pd xmm0, xmm0
  00025	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  0002a	0f 57 c9	 xorps	 xmm1, xmm1
  0002d	f2 0f 5a c8	 cvtsd2ss xmm1, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp

; 92   : 	if (cx < 0.00001f)

  00031	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3727c5ac
  00039	0f 2f c1	 comiss	 xmm0, xmm1

; 93   : 	{
; 94   : 		if (sx > 0)

  0003c	f3 0f 10 46 24	 movss	 xmm0, DWORD PTR [esi+36]
  00041	76 55		 jbe	 SHORT $LN4@GetPivotAn
  00043	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0004a	76 0a		 jbe	 SHORT $LN3@GetPivotAn

; 95   : 			x = D3DX_PI / 2;

  0004c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3fc90fdb

; 96   : 		else

  00054	eb 08		 jmp	 SHORT $LN17@GetPivotAn
$LN3@GetPivotAn:

; 97   : 			x = -D3DX_PI / 2;

  00056	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bfc90fdb
$LN17@GetPivotAn:
  0005e	f3 0f 11 44 24
	08		 movss	 DWORD PTR _x$1$[esp+24], xmm0
  00064	f3 0f 10 46 20	 movss	 xmm0, DWORD PTR [esi+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 649  :     return (float)atan2(_Y, _X);

  00069	0f 5a c0	 cvtps2pd xmm0, xmm0
  0006c	f2 0f 11 44 24
	10		 movsd	 QWORD PTR tv307[esp+24], xmm0
  00072	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  00076	dd 44 24 10	 fld	 QWORD PTR tv307[esp+24]
  0007a	0f 5a c0	 cvtps2pd xmm0, xmm0
  0007d	f2 0f 11 44 24
	10		 movsd	 QWORD PTR tv304[esp+24], xmm0
  00083	dd 44 24 10	 fld	 QWORD PTR tv304[esp+24]
  00087	e8 00 00 00 00	 call	 __CIatan2
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp

; 99   : 		y = atan2f(pMatrix->_31, pMatrix->_11);

  0008c	d9 5c 24 0c	 fstp	 DWORD PTR _y$[esp+24]
  00090	0f 57 c9	 xorps	 xmm1, xmm1

; 100  : 		z = 0.0f;
; 101  : 	}
; 102  : 	else

  00093	e9 93 00 00 00	 jmp	 $LN18@GetPivotAn
$LN4@GetPivotAn:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 649  :     return (float)atan2(_Y, _X);

  00098	0f 5a c0	 cvtps2pd xmm0, xmm0
  0009b	f2 0f 11 44 24
	10		 movsd	 QWORD PTR tv295[esp+24], xmm0
  000a1	dd 44 24 10	 fld	 QWORD PTR tv295[esp+24]
  000a5	0f 5a c1	 cvtps2pd xmm0, xmm1
  000a8	f2 0f 11 44 24
	10		 movsd	 QWORD PTR tv292[esp+24], xmm0
  000ae	dd 44 24 10	 fld	 QWORD PTR tv292[esp+24]
  000b2	e8 00 00 00 00	 call	 __CIatan2
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp

; 105  : 		y = atan2f(-pMatrix->_31, pMatrix->_33);

  000b7	f3 0f 10 46 20	 movss	 xmm0, DWORD PTR [esi+32]
  000bc	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 649  :     return (float)atan2(_Y, _X);

  000c3	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp

; 104  : 		x = atan2f(sx, cx);

  000c7	d9 5c 24 08	 fstp	 DWORD PTR _x$[esp+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 649  :     return (float)atan2(_Y, _X);

  000cb	f2 0f 11 44 24
	10		 movsd	 QWORD PTR tv284[esp+24], xmm0
  000d1	f3 0f 10 46 28	 movss	 xmm0, DWORD PTR [esi+40]
  000d6	dd 44 24 10	 fld	 QWORD PTR tv284[esp+24]
  000da	0f 5a c0	 cvtps2pd xmm0, xmm0
  000dd	f2 0f 11 44 24
	10		 movsd	 QWORD PTR tv281[esp+24], xmm0
  000e3	dd 44 24 10	 fld	 QWORD PTR tv281[esp+24]
  000e7	e8 00 00 00 00	 call	 __CIatan2
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp

; 106  : 		z = atan2f(-pMatrix->_12, pMatrix->_22);

  000ec	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]
  000f1	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 649  :     return (float)atan2(_Y, _X);

  000f8	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp

; 105  : 		y = atan2f(-pMatrix->_31, pMatrix->_33);

  000fc	d9 5c 24 0c	 fstp	 DWORD PTR _y$[esp+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 649  :     return (float)atan2(_Y, _X);

  00100	f2 0f 11 44 24
	10		 movsd	 QWORD PTR tv273[esp+24], xmm0
  00106	f3 0f 10 46 14	 movss	 xmm0, DWORD PTR [esi+20]
  0010b	dd 44 24 10	 fld	 QWORD PTR tv273[esp+24]
  0010f	0f 5a c0	 cvtps2pd xmm0, xmm0
  00112	f2 0f 11 44 24
	10		 movsd	 QWORD PTR tv270[esp+24], xmm0
  00118	dd 44 24 10	 fld	 QWORD PTR tv270[esp+24]
  0011c	e8 00 00 00 00	 call	 __CIatan2
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp

; 106  : 		z = atan2f(-pMatrix->_12, pMatrix->_22);

  00121	d9 5c 24 10	 fstp	 DWORD PTR _z$[esp+24]
  00125	f3 0f 10 4c 24
	10		 movss	 xmm1, DWORD PTR _z$[esp+24]
$LN18@GetPivotAn:

; 107  : 	}
; 108  : 
; 109  : 	pRotation->x = x;

  0012b	8b 45 10	 mov	 eax, DWORD PTR _pRotation$[ebp]
  0012e	f3 0f 10 44 24
	08		 movss	 xmm0, DWORD PTR _x$[esp+24]

; 110  : 	pRotation->y = y;
; 111  : 	pRotation->z = z;
; 112  : 
; 113  : 	pPivot->x = pMatrix->_41;

  00134	8b 4d 0c	 mov	 ecx, DWORD PTR _pPivot$[ebp]
  00137	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  0013b	f3 0f 10 44 24
	0c		 movss	 xmm0, DWORD PTR _y$[esp+24]
  00141	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00146	f3 0f 11 48 08	 movss	 DWORD PTR [eax+8], xmm1
  0014b	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0014e	89 01		 mov	 DWORD PTR [ecx], eax

; 114  : 	pPivot->y = pMatrix->_42;

  00150	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00153	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 115  : 	pPivot->z = pMatrix->_43;

  00156	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00159	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 116  : }

  0015c	5e		 pop	 esi
  0015d	8b e5		 mov	 esp, ebp
  0015f	5d		 pop	 ebp
  00160	c3		 ret	 0
?GetPivotAndRotationFromMatrix@@YAXPAUD3DXMATRIX@@PAUD3DXVECTOR3@@1@Z ENDP ; GetPivotAndRotationFromMatrix
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
;	COMDAT ?GetRotationFromMatrix@@YAXPAUD3DXVECTOR3@@PBUD3DXMATRIX@@@Z
_TEXT	SEGMENT
tv254 = -8						; size = 8
tv251 = -8						; size = 8
tv242 = -8						; size = 8
tv239 = -8						; size = 8
tv231 = -8						; size = 8
tv228 = -8						; size = 8
tv216 = -8						; size = 8
tv212 = -8						; size = 8
_pRotation$ = 8						; size = 4
_c_pMatrix$ = 12					; size = 4
?GetRotationFromMatrix@@YAXPAUD3DXVECTOR3@@PBUD3DXMATRIX@@@Z PROC ; GetRotationFromMatrix, COMDAT

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 65   : 	float sx = c_pMatrix->_32;
; 66   : 	float cx = sqrtf(1.0f - sx * sx);

  00006	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0000e	83 ec 08	 sub	 esp, 8
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	8b 7d 0c	 mov	 edi, DWORD PTR _c_pMatrix$[ebp]
  00016	f3 0f 10 4f 24	 movss	 xmm1, DWORD PTR [edi+36]
  0001b	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0001f	f3 0f 5c c1	 subss	 xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  00023	0f 5a c0	 cvtps2pd xmm0, xmm0
  00026	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp

; 70   : 		if (sx > 0)

  0002b	f3 0f 10 4f 24	 movss	 xmm1, DWORD PTR [edi+36]
  00030	0f 57 d2	 xorps	 xmm2, xmm2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  00033	f2 0f 5a d0	 cvtsd2ss xmm2, xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp

; 68   : 	if (cx < 0.00001f)

  00037	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3727c5ac
  0003f	0f 2f c2	 comiss	 xmm0, xmm2
  00042	76 51		 jbe	 SHORT $LN4@GetRotatio

; 71   : 			pRotation->x = D3DX_PI / 2;

  00044	8b 75 08	 mov	 esi, DWORD PTR _pRotation$[ebp]
  00047	0f 57 c0	 xorps	 xmm0, xmm0
  0004a	0f 2f c8	 comiss	 xmm1, xmm0
  0004d	76 08		 jbe	 SHORT $LN3@GetRotatio
  0004f	c7 06 db 0f c9
	3f		 mov	 DWORD PTR [esi], 1070141403 ; 3fc90fdbH

; 72   : 		else

  00055	eb 06		 jmp	 SHORT $LN2@GetRotatio
$LN3@GetRotatio:

; 73   : 			pRotation->x = -D3DX_PI / 2;

  00057	c7 06 db 0f c9
	bf		 mov	 DWORD PTR [esi], -1077342245 ; bfc90fdbH
$LN2@GetRotatio:
  0005d	f3 0f 10 47 20	 movss	 xmm0, DWORD PTR [edi+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 649  :     return (float)atan2(_Y, _X);

  00062	0f 5a c0	 cvtps2pd xmm0, xmm0
  00065	f2 0f 11 44 24
	08		 movsd	 QWORD PTR tv254[esp+16], xmm0
  0006b	f3 0f 10 07	 movss	 xmm0, DWORD PTR [edi]
  0006f	dd 44 24 08	 fld	 QWORD PTR tv254[esp+16]
  00073	0f 5a c0	 cvtps2pd xmm0, xmm0
  00076	f2 0f 11 44 24
	08		 movsd	 QWORD PTR tv251[esp+16], xmm0
  0007c	dd 44 24 08	 fld	 QWORD PTR tv251[esp+16]
  00080	e8 00 00 00 00	 call	 __CIatan2
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp

; 75   : 		pRotation->y = atan2f(c_pMatrix->_31, c_pMatrix->_11);

  00085	d9 5e 04	 fstp	 DWORD PTR [esi+4]

; 76   : 		pRotation->z = 0.0f;

  00088	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 84   : }

  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
$LN4@GetRotatio:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 649  :     return (float)atan2(_Y, _X);

  00095	0f 5a c1	 cvtps2pd xmm0, xmm1
  00098	f2 0f 11 44 24
	08		 movsd	 QWORD PTR tv242[esp+16], xmm0
  0009e	dd 44 24 08	 fld	 QWORD PTR tv242[esp+16]
  000a2	0f 5a c2	 cvtps2pd xmm0, xmm2
  000a5	f2 0f 11 44 24
	08		 movsd	 QWORD PTR tv239[esp+16], xmm0
  000ab	dd 44 24 08	 fld	 QWORD PTR tv239[esp+16]
  000af	e8 00 00 00 00	 call	 __CIatan2
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp

; 80   : 		pRotation->x = atan2f(sx, cx);

  000b4	8b 75 08	 mov	 esi, DWORD PTR _pRotation$[ebp]
  000b7	d9 1e		 fstp	 DWORD PTR [esi]

; 81   : 		pRotation->y = atan2f(-c_pMatrix->_31, c_pMatrix->_33);

  000b9	f3 0f 10 47 20	 movss	 xmm0, DWORD PTR [edi+32]
  000be	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 649  :     return (float)atan2(_Y, _X);

  000c5	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  000c9	f2 0f 11 44 24
	08		 movsd	 QWORD PTR tv231[esp+16], xmm0
  000cf	f3 0f 10 47 28	 movss	 xmm0, DWORD PTR [edi+40]
  000d4	dd 44 24 08	 fld	 QWORD PTR tv231[esp+16]
  000d8	0f 5a c0	 cvtps2pd xmm0, xmm0
  000db	f2 0f 11 44 24
	08		 movsd	 QWORD PTR tv228[esp+16], xmm0
  000e1	dd 44 24 08	 fld	 QWORD PTR tv228[esp+16]
  000e5	e8 00 00 00 00	 call	 __CIatan2
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp

; 81   : 		pRotation->y = atan2f(-c_pMatrix->_31, c_pMatrix->_33);

  000ea	d9 5e 04	 fstp	 DWORD PTR [esi+4]

; 82   : 		pRotation->z = atan2f(-c_pMatrix->_12, c_pMatrix->_22);

  000ed	f3 0f 10 47 04	 movss	 xmm0, DWORD PTR [edi+4]
  000f2	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 649  :     return (float)atan2(_Y, _X);

  000f9	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  000fd	f2 0f 11 44 24
	08		 movsd	 QWORD PTR tv216[esp+16], xmm0
  00103	f3 0f 10 47 14	 movss	 xmm0, DWORD PTR [edi+20]
  00108	dd 44 24 08	 fld	 QWORD PTR tv216[esp+16]
  0010c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0010f	f2 0f 11 44 24
	08		 movsd	 QWORD PTR tv212[esp+16], xmm0
  00115	dd 44 24 08	 fld	 QWORD PTR tv212[esp+16]
  00119	e8 00 00 00 00	 call	 __CIatan2
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp

; 84   : }

  0011e	5f		 pop	 edi
  0011f	d9 5e 08	 fstp	 DWORD PTR [esi+8]
  00122	5e		 pop	 esi
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c3		 ret	 0
?GetRotationFromMatrix@@YAXPAUD3DXVECTOR3@@PBUD3DXMATRIX@@@Z ENDP ; GetRotationFromMatrix
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
;	COMDAT ?D3DXVec3Rotation@@YAPAUD3DXVECTOR3@@PAU1@PBU1@PBUD3DXQUATERNION@@@Z
_TEXT	SEGMENT
_qtSrc$ = -32						; size = 16
_qtRet$ = -16						; size = 16
_pvtOut$ = 8						; size = 4
_c_pvtSrc$ = 12						; size = 4
_c_pqtRot$ = 16						; size = 4
?D3DXVec3Rotation@@YAPAUD3DXVECTOR3@@PAU1@PBU1@PBUD3DXQUATERNION@@@Z PROC ; D3DXVec3Rotation, COMDAT

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 667  :     x = fx;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _c_pvtSrc$[ebp]

; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;
; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;
; 1265 : }
; 1266 : 
; 1267 : D3DXINLINE D3DXVECTOR3* D3DXVec3Cross
; 1268 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1269 : {
; 1270 :     D3DXVECTOR3 v;
; 1271 : 
; 1272 : #ifdef D3DX_DEBUG
; 1273 :     if(!pOut || !pV1 || !pV2)
; 1274 :         return NULL;
; 1275 : #endif
; 1276 : 
; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;
; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;
; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;
; 1280 : 
; 1281 :     *pOut = v;
; 1282 :     return pOut;
; 1283 : }
; 1284 : 
; 1285 : D3DXINLINE D3DXVECTOR3* D3DXVec3Add
; 1286 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1287 : {
; 1288 : #ifdef D3DX_DEBUG
; 1289 :     if(!pOut || !pV1 || !pV2)
; 1290 :         return NULL;
; 1291 : #endif
; 1292 : 
; 1293 :     pOut->x = pV1->x + pV2->x;
; 1294 :     pOut->y = pV1->y + pV2->y;
; 1295 :     pOut->z = pV1->z + pV2->z;
; 1296 :     return pOut;
; 1297 : }
; 1298 : 
; 1299 : D3DXINLINE D3DXVECTOR3* D3DXVec3Subtract
; 1300 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1301 : {
; 1302 : #ifdef D3DX_DEBUG
; 1303 :     if(!pOut || !pV1 || !pV2)
; 1304 :         return NULL;
; 1305 : #endif
; 1306 : 
; 1307 :     pOut->x = pV1->x - pV2->x;
; 1308 :     pOut->y = pV1->y - pV2->y;
; 1309 :     pOut->z = pV1->z - pV2->z;
; 1310 :     return pOut;
; 1311 : }
; 1312 : 
; 1313 : D3DXINLINE D3DXVECTOR3* D3DXVec3Minimize
; 1314 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1315 : {
; 1316 : #ifdef D3DX_DEBUG
; 1317 :     if(!pOut || !pV1 || !pV2)
; 1318 :         return NULL;
; 1319 : #endif
; 1320 : 
; 1321 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1322 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1323 :     pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
; 1324 :     return pOut;
; 1325 : }
; 1326 : 
; 1327 : D3DXINLINE D3DXVECTOR3* D3DXVec3Maximize
; 1328 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1329 : {
; 1330 : #ifdef D3DX_DEBUG
; 1331 :     if(!pOut || !pV1 || !pV2)
; 1332 :         return NULL;
; 1333 : #endif
; 1334 : 
; 1335 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1336 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1337 :     pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
; 1338 :     return pOut;
; 1339 : }
; 1340 : 
; 1341 : D3DXINLINE D3DXVECTOR3* D3DXVec3Scale
; 1342 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, FLOAT s)
; 1343 : {
; 1344 : #ifdef D3DX_DEBUG
; 1345 :     if(!pOut || !pV)
; 1346 :         return NULL;
; 1347 : #endif
; 1348 : 
; 1349 :     pOut->x = pV->x * s;
; 1350 :     pOut->y = pV->y * s;
; 1351 :     pOut->z = pV->z * s;
; 1352 :     return pOut;
; 1353 : }
; 1354 : 
; 1355 : D3DXINLINE D3DXVECTOR3* D3DXVec3Lerp
; 1356 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
; 1357 :       FLOAT s )
; 1358 : {
; 1359 : #ifdef D3DX_DEBUG
; 1360 :     if(!pOut || !pV1 || !pV2)
; 1361 :         return NULL;
; 1362 : #endif
; 1363 : 
; 1364 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1365 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1366 :     pOut->z = pV1->z + s * (pV2->z - pV1->z);
; 1367 :     return pOut;
; 1368 : }
; 1369 : 
; 1370 : 
; 1371 : //--------------------------
; 1372 : // 4D Vector
; 1373 : //--------------------------
; 1374 : 
; 1375 : D3DXINLINE FLOAT D3DXVec4Length
; 1376 :     ( CONST D3DXVECTOR4 *pV )
; 1377 : {
; 1378 : #ifdef D3DX_DEBUG
; 1379 :     if(!pV)
; 1380 :         return 0.0f;
; 1381 : #endif
; 1382 : 
; 1383 : #ifdef __cplusplus
; 1384 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w);
; 1385 : #else
; 1386 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w);
; 1387 : #endif
; 1388 : }
; 1389 : 
; 1390 : D3DXINLINE FLOAT D3DXVec4LengthSq
; 1391 :     ( CONST D3DXVECTOR4 *pV )
; 1392 : {
; 1393 : #ifdef D3DX_DEBUG
; 1394 :     if(!pV)
; 1395 :         return 0.0f;
; 1396 : #endif
; 1397 : 
; 1398 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w;
; 1399 : }
; 1400 : 
; 1401 : D3DXINLINE FLOAT D3DXVec4Dot
; 1402 :     ( CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2 )
; 1403 : {
; 1404 : #ifdef D3DX_DEBUG
; 1405 :     if(!pV1 || !pV2)
; 1406 :         return 0.0f;
; 1407 : #endif
; 1408 : 
; 1409 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z + pV1->w * pV2->w;
; 1410 : }
; 1411 : 
; 1412 : D3DXINLINE D3DXVECTOR4* D3DXVec4Add
; 1413 :     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
; 1414 : {
; 1415 : #ifdef D3DX_DEBUG
; 1416 :     if(!pOut || !pV1 || !pV2)
; 1417 :         return NULL;
; 1418 : #endif
; 1419 : 
; 1420 :     pOut->x = pV1->x + pV2->x;
; 1421 :     pOut->y = pV1->y + pV2->y;
; 1422 :     pOut->z = pV1->z + pV2->z;
; 1423 :     pOut->w = pV1->w + pV2->w;
; 1424 :     return pOut;
; 1425 : }
; 1426 : 
; 1427 : D3DXINLINE D3DXVECTOR4* D3DXVec4Subtract
; 1428 :     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
; 1429 : {
; 1430 : #ifdef D3DX_DEBUG
; 1431 :     if(!pOut || !pV1 || !pV2)
; 1432 :         return NULL;
; 1433 : #endif
; 1434 : 
; 1435 :     pOut->x = pV1->x - pV2->x;
; 1436 :     pOut->y = pV1->y - pV2->y;
; 1437 :     pOut->z = pV1->z - pV2->z;
; 1438 :     pOut->w = pV1->w - pV2->w;
; 1439 :     return pOut;
; 1440 : }
; 1441 : 
; 1442 : D3DXINLINE D3DXVECTOR4* D3DXVec4Minimize
; 1443 :     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
; 1444 : {
; 1445 : #ifdef D3DX_DEBUG
; 1446 :     if(!pOut || !pV1 || !pV2)
; 1447 :         return NULL;
; 1448 : #endif
; 1449 : 
; 1450 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1451 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1452 :     pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
; 1453 :     pOut->w = pV1->w < pV2->w ? pV1->w : pV2->w;
; 1454 :     return pOut;
; 1455 : }
; 1456 : 
; 1457 : D3DXINLINE D3DXVECTOR4* D3DXVec4Maximize
; 1458 :     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
; 1459 : {
; 1460 : #ifdef D3DX_DEBUG
; 1461 :     if(!pOut || !pV1 || !pV2)
; 1462 :         return NULL;
; 1463 : #endif
; 1464 : 
; 1465 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1466 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1467 :     pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
; 1468 :     pOut->w = pV1->w > pV2->w ? pV1->w : pV2->w;
; 1469 :     return pOut;
; 1470 : }
; 1471 : 
; 1472 : D3DXINLINE D3DXVECTOR4* D3DXVec4Scale
; 1473 :     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV, FLOAT s)
; 1474 : {
; 1475 : #ifdef D3DX_DEBUG
; 1476 :     if(!pOut || !pV)
; 1477 :         return NULL;
; 1478 : #endif
; 1479 : 
; 1480 :     pOut->x = pV->x * s;
; 1481 :     pOut->y = pV->y * s;
; 1482 :     pOut->z = pV->z * s;
; 1483 :     pOut->w = pV->w * s;
; 1484 :     return pOut;
; 1485 : }
; 1486 : 
; 1487 : D3DXINLINE D3DXVECTOR4* D3DXVec4Lerp
; 1488 :     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
; 1489 :       FLOAT s )
; 1490 : {
; 1491 : #ifdef D3DX_DEBUG
; 1492 :     if(!pOut || !pV1 || !pV2)
; 1493 :         return NULL;
; 1494 : #endif
; 1495 : 
; 1496 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1497 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1498 :     pOut->z = pV1->z + s * (pV2->z - pV1->z);
; 1499 :     pOut->w = pV1->w + s * (pV2->w - pV1->w);
; 1500 :     return pOut;
; 1501 : }
; 1502 : 
; 1503 : 
; 1504 : //--------------------------
; 1505 : // 4D Matrix
; 1506 : //--------------------------
; 1507 : 
; 1508 : D3DXINLINE D3DXMATRIX* D3DXMatrixIdentity
; 1509 :     ( D3DXMATRIX *pOut )
; 1510 : {
; 1511 : #ifdef D3DX_DEBUG
; 1512 :     if(!pOut)
; 1513 :         return NULL;
; 1514 : #endif
; 1515 : 
; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =
; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;
; 1522 :     return pOut;
; 1523 : }
; 1524 : 
; 1525 : 
; 1526 : D3DXINLINE BOOL D3DXMatrixIsIdentity
; 1527 :     ( CONST D3DXMATRIX *pM )
; 1528 : {
; 1529 : #ifdef D3DX_DEBUG
; 1530 :     if(!pM)
; 1531 :         return FALSE;
; 1532 : #endif
; 1533 : 
; 1534 :     return pM->m[0][0] == 1.0f && pM->m[0][1] == 0.0f && pM->m[0][2] == 0.0f && pM->m[0][3] == 0.0f &&
; 1535 :            pM->m[1][0] == 0.0f && pM->m[1][1] == 1.0f && pM->m[1][2] == 0.0f && pM->m[1][3] == 0.0f &&
; 1536 :            pM->m[2][0] == 0.0f && pM->m[2][1] == 0.0f && pM->m[2][2] == 1.0f && pM->m[2][3] == 0.0f &&
; 1537 :            pM->m[3][0] == 0.0f && pM->m[3][1] == 0.0f && pM->m[3][2] == 0.0f && pM->m[3][3] == 1.0f;
; 1538 : }
; 1539 : 
; 1540 : 
; 1541 : //--------------------------
; 1542 : // Quaternion
; 1543 : //--------------------------
; 1544 : 
; 1545 : D3DXINLINE FLOAT D3DXQuaternionLength
; 1546 :     ( CONST D3DXQUATERNION *pQ )
; 1547 : {
; 1548 : #ifdef D3DX_DEBUG
; 1549 :     if(!pQ)
; 1550 :         return 0.0f;
; 1551 : #endif
; 1552 : 
; 1553 : #ifdef __cplusplus
; 1554 :     return sqrtf(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w);
; 1555 : #else
; 1556 :     return (FLOAT) sqrt(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w);
; 1557 : #endif
; 1558 : }
; 1559 : 
; 1560 : D3DXINLINE FLOAT D3DXQuaternionLengthSq
; 1561 :     ( CONST D3DXQUATERNION *pQ )
; 1562 : {
; 1563 : #ifdef D3DX_DEBUG
; 1564 :     if(!pQ)
; 1565 :         return 0.0f;
; 1566 : #endif
; 1567 : 
; 1568 :     return pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w;
; 1569 : }
; 1570 : 
; 1571 : D3DXINLINE FLOAT D3DXQuaternionDot
; 1572 :     ( CONST D3DXQUATERNION *pQ1, CONST D3DXQUATERNION *pQ2 )
; 1573 : {
; 1574 : #ifdef D3DX_DEBUG
; 1575 :     if(!pQ1 || !pQ2)
; 1576 :         return 0.0f;
; 1577 : #endif
; 1578 : 
; 1579 :     return pQ1->x * pQ2->x + pQ1->y * pQ2->y + pQ1->z * pQ2->z + pQ1->w * pQ2->w;
; 1580 : }
; 1581 : 
; 1582 : 
; 1583 : D3DXINLINE D3DXQUATERNION* D3DXQuaternionIdentity
; 1584 :     ( D3DXQUATERNION *pOut )
; 1585 : {
; 1586 : #ifdef D3DX_DEBUG
; 1587 :     if(!pOut)
; 1588 :         return NULL;
; 1589 : #endif
; 1590 : 
; 1591 :     pOut->x = pOut->y = pOut->z = 0.0f;
; 1592 :     pOut->w = 1.0f;
; 1593 :     return pOut;
; 1594 : }
; 1595 : 
; 1596 : D3DXINLINE BOOL D3DXQuaternionIsIdentity
; 1597 :     ( CONST D3DXQUATERNION *pQ )
; 1598 : {
; 1599 : #ifdef D3DX_DEBUG
; 1600 :     if(!pQ)
; 1601 :         return FALSE;
; 1602 : #endif
; 1603 : 
; 1604 :     return pQ->x == 0.0f && pQ->y == 0.0f && pQ->z == 0.0f && pQ->w == 1.0f;
; 1605 : }
; 1606 : 
; 1607 : 
; 1608 : D3DXINLINE D3DXQUATERNION* D3DXQuaternionConjugate
; 1609 :     ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ )
; 1610 : {
; 1611 : #ifdef D3DX_DEBUG
; 1612 :     if(!pOut || !pQ)
; 1613 :         return NULL;
; 1614 : #endif
; 1615 : 
; 1616 :     pOut->x = -pQ->x;

  00009	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
  00011	56		 push	 esi
  00012	8b 75 10	 mov	 esi, DWORD PTR _c_pqtRot$[ebp]

; 667  :     x = fx;

  00015	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00019	f3 0f 11 45 e0	 movss	 DWORD PTR _qtSrc$[ebp], xmm0

; 668  :     y = fy;

  0001e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00023	f3 0f 11 45 e4	 movss	 DWORD PTR _qtSrc$[ebp+4], xmm0

; 669  :     z = fz;

  00028	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp

; 51   : 	D3DXQuaternionMultiply(&qtRet, &qtSrc, &qtRet);

  0002d	8d 45 f0	 lea	 eax, DWORD PTR _qtRet$[ebp]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 669  :     z = fz;

  00030	f3 0f 11 45 e8	 movss	 DWORD PTR _qtSrc$[ebp+8], xmm0

; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;
; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;
; 1265 : }
; 1266 : 
; 1267 : D3DXINLINE D3DXVECTOR3* D3DXVec3Cross
; 1268 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1269 : {
; 1270 :     D3DXVECTOR3 v;
; 1271 : 
; 1272 : #ifdef D3DX_DEBUG
; 1273 :     if(!pOut || !pV1 || !pV2)
; 1274 :         return NULL;
; 1275 : #endif
; 1276 : 
; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;
; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;
; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;
; 1280 : 
; 1281 :     *pOut = v;
; 1282 :     return pOut;
; 1283 : }
; 1284 : 
; 1285 : D3DXINLINE D3DXVECTOR3* D3DXVec3Add
; 1286 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1287 : {
; 1288 : #ifdef D3DX_DEBUG
; 1289 :     if(!pOut || !pV1 || !pV2)
; 1290 :         return NULL;
; 1291 : #endif
; 1292 : 
; 1293 :     pOut->x = pV1->x + pV2->x;
; 1294 :     pOut->y = pV1->y + pV2->y;
; 1295 :     pOut->z = pV1->z + pV2->z;
; 1296 :     return pOut;
; 1297 : }
; 1298 : 
; 1299 : D3DXINLINE D3DXVECTOR3* D3DXVec3Subtract
; 1300 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1301 : {
; 1302 : #ifdef D3DX_DEBUG
; 1303 :     if(!pOut || !pV1 || !pV2)
; 1304 :         return NULL;
; 1305 : #endif
; 1306 : 
; 1307 :     pOut->x = pV1->x - pV2->x;
; 1308 :     pOut->y = pV1->y - pV2->y;
; 1309 :     pOut->z = pV1->z - pV2->z;
; 1310 :     return pOut;
; 1311 : }
; 1312 : 
; 1313 : D3DXINLINE D3DXVECTOR3* D3DXVec3Minimize
; 1314 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1315 : {
; 1316 : #ifdef D3DX_DEBUG
; 1317 :     if(!pOut || !pV1 || !pV2)
; 1318 :         return NULL;
; 1319 : #endif
; 1320 : 
; 1321 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1322 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1323 :     pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
; 1324 :     return pOut;
; 1325 : }
; 1326 : 
; 1327 : D3DXINLINE D3DXVECTOR3* D3DXVec3Maximize
; 1328 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1329 : {
; 1330 : #ifdef D3DX_DEBUG
; 1331 :     if(!pOut || !pV1 || !pV2)
; 1332 :         return NULL;
; 1333 : #endif
; 1334 : 
; 1335 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1336 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1337 :     pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
; 1338 :     return pOut;
; 1339 : }
; 1340 : 
; 1341 : D3DXINLINE D3DXVECTOR3* D3DXVec3Scale
; 1342 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, FLOAT s)
; 1343 : {
; 1344 : #ifdef D3DX_DEBUG
; 1345 :     if(!pOut || !pV)
; 1346 :         return NULL;
; 1347 : #endif
; 1348 : 
; 1349 :     pOut->x = pV->x * s;
; 1350 :     pOut->y = pV->y * s;
; 1351 :     pOut->z = pV->z * s;
; 1352 :     return pOut;
; 1353 : }
; 1354 : 
; 1355 : D3DXINLINE D3DXVECTOR3* D3DXVec3Lerp
; 1356 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
; 1357 :       FLOAT s )
; 1358 : {
; 1359 : #ifdef D3DX_DEBUG
; 1360 :     if(!pOut || !pV1 || !pV2)
; 1361 :         return NULL;
; 1362 : #endif
; 1363 : 
; 1364 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1365 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1366 :     pOut->z = pV1->z + s * (pV2->z - pV1->z);
; 1367 :     return pOut;
; 1368 : }
; 1369 : 
; 1370 : 
; 1371 : //--------------------------
; 1372 : // 4D Vector
; 1373 : //--------------------------
; 1374 : 
; 1375 : D3DXINLINE FLOAT D3DXVec4Length
; 1376 :     ( CONST D3DXVECTOR4 *pV )
; 1377 : {
; 1378 : #ifdef D3DX_DEBUG
; 1379 :     if(!pV)
; 1380 :         return 0.0f;
; 1381 : #endif
; 1382 : 
; 1383 : #ifdef __cplusplus
; 1384 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w);
; 1385 : #else
; 1386 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w);
; 1387 : #endif
; 1388 : }
; 1389 : 
; 1390 : D3DXINLINE FLOAT D3DXVec4LengthSq
; 1391 :     ( CONST D3DXVECTOR4 *pV )
; 1392 : {
; 1393 : #ifdef D3DX_DEBUG
; 1394 :     if(!pV)
; 1395 :         return 0.0f;
; 1396 : #endif
; 1397 : 
; 1398 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w;
; 1399 : }
; 1400 : 
; 1401 : D3DXINLINE FLOAT D3DXVec4Dot
; 1402 :     ( CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2 )
; 1403 : {
; 1404 : #ifdef D3DX_DEBUG
; 1405 :     if(!pV1 || !pV2)
; 1406 :         return 0.0f;
; 1407 : #endif
; 1408 : 
; 1409 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z + pV1->w * pV2->w;
; 1410 : }
; 1411 : 
; 1412 : D3DXINLINE D3DXVECTOR4* D3DXVec4Add
; 1413 :     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
; 1414 : {
; 1415 : #ifdef D3DX_DEBUG
; 1416 :     if(!pOut || !pV1 || !pV2)
; 1417 :         return NULL;
; 1418 : #endif
; 1419 : 
; 1420 :     pOut->x = pV1->x + pV2->x;
; 1421 :     pOut->y = pV1->y + pV2->y;
; 1422 :     pOut->z = pV1->z + pV2->z;
; 1423 :     pOut->w = pV1->w + pV2->w;
; 1424 :     return pOut;
; 1425 : }
; 1426 : 
; 1427 : D3DXINLINE D3DXVECTOR4* D3DXVec4Subtract
; 1428 :     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
; 1429 : {
; 1430 : #ifdef D3DX_DEBUG
; 1431 :     if(!pOut || !pV1 || !pV2)
; 1432 :         return NULL;
; 1433 : #endif
; 1434 : 
; 1435 :     pOut->x = pV1->x - pV2->x;
; 1436 :     pOut->y = pV1->y - pV2->y;
; 1437 :     pOut->z = pV1->z - pV2->z;
; 1438 :     pOut->w = pV1->w - pV2->w;
; 1439 :     return pOut;
; 1440 : }
; 1441 : 
; 1442 : D3DXINLINE D3DXVECTOR4* D3DXVec4Minimize
; 1443 :     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
; 1444 : {
; 1445 : #ifdef D3DX_DEBUG
; 1446 :     if(!pOut || !pV1 || !pV2)
; 1447 :         return NULL;
; 1448 : #endif
; 1449 : 
; 1450 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1451 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1452 :     pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
; 1453 :     pOut->w = pV1->w < pV2->w ? pV1->w : pV2->w;
; 1454 :     return pOut;
; 1455 : }
; 1456 : 
; 1457 : D3DXINLINE D3DXVECTOR4* D3DXVec4Maximize
; 1458 :     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
; 1459 : {
; 1460 : #ifdef D3DX_DEBUG
; 1461 :     if(!pOut || !pV1 || !pV2)
; 1462 :         return NULL;
; 1463 : #endif
; 1464 : 
; 1465 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1466 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1467 :     pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
; 1468 :     pOut->w = pV1->w > pV2->w ? pV1->w : pV2->w;
; 1469 :     return pOut;
; 1470 : }
; 1471 : 
; 1472 : D3DXINLINE D3DXVECTOR4* D3DXVec4Scale
; 1473 :     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV, FLOAT s)
; 1474 : {
; 1475 : #ifdef D3DX_DEBUG
; 1476 :     if(!pOut || !pV)
; 1477 :         return NULL;
; 1478 : #endif
; 1479 : 
; 1480 :     pOut->x = pV->x * s;
; 1481 :     pOut->y = pV->y * s;
; 1482 :     pOut->z = pV->z * s;
; 1483 :     pOut->w = pV->w * s;
; 1484 :     return pOut;
; 1485 : }
; 1486 : 
; 1487 : D3DXINLINE D3DXVECTOR4* D3DXVec4Lerp
; 1488 :     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
; 1489 :       FLOAT s )
; 1490 : {
; 1491 : #ifdef D3DX_DEBUG
; 1492 :     if(!pOut || !pV1 || !pV2)
; 1493 :         return NULL;
; 1494 : #endif
; 1495 : 
; 1496 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1497 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1498 :     pOut->z = pV1->z + s * (pV2->z - pV1->z);
; 1499 :     pOut->w = pV1->w + s * (pV2->w - pV1->w);
; 1500 :     return pOut;
; 1501 : }
; 1502 : 
; 1503 : 
; 1504 : //--------------------------
; 1505 : // 4D Matrix
; 1506 : //--------------------------
; 1507 : 
; 1508 : D3DXINLINE D3DXMATRIX* D3DXMatrixIdentity
; 1509 :     ( D3DXMATRIX *pOut )
; 1510 : {
; 1511 : #ifdef D3DX_DEBUG
; 1512 :     if(!pOut)
; 1513 :         return NULL;
; 1514 : #endif
; 1515 : 
; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =
; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;
; 1522 :     return pOut;
; 1523 : }
; 1524 : 
; 1525 : 
; 1526 : D3DXINLINE BOOL D3DXMatrixIsIdentity
; 1527 :     ( CONST D3DXMATRIX *pM )
; 1528 : {
; 1529 : #ifdef D3DX_DEBUG
; 1530 :     if(!pM)
; 1531 :         return FALSE;
; 1532 : #endif
; 1533 : 
; 1534 :     return pM->m[0][0] == 1.0f && pM->m[0][1] == 0.0f && pM->m[0][2] == 0.0f && pM->m[0][3] == 0.0f &&
; 1535 :            pM->m[1][0] == 0.0f && pM->m[1][1] == 1.0f && pM->m[1][2] == 0.0f && pM->m[1][3] == 0.0f &&
; 1536 :            pM->m[2][0] == 0.0f && pM->m[2][1] == 0.0f && pM->m[2][2] == 1.0f && pM->m[2][3] == 0.0f &&
; 1537 :            pM->m[3][0] == 0.0f && pM->m[3][1] == 0.0f && pM->m[3][2] == 0.0f && pM->m[3][3] == 1.0f;
; 1538 : }
; 1539 : 
; 1540 : 
; 1541 : //--------------------------
; 1542 : // Quaternion
; 1543 : //--------------------------
; 1544 : 
; 1545 : D3DXINLINE FLOAT D3DXQuaternionLength
; 1546 :     ( CONST D3DXQUATERNION *pQ )
; 1547 : {
; 1548 : #ifdef D3DX_DEBUG
; 1549 :     if(!pQ)
; 1550 :         return 0.0f;
; 1551 : #endif
; 1552 : 
; 1553 : #ifdef __cplusplus
; 1554 :     return sqrtf(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w);
; 1555 : #else
; 1556 :     return (FLOAT) sqrt(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w);
; 1557 : #endif
; 1558 : }
; 1559 : 
; 1560 : D3DXINLINE FLOAT D3DXQuaternionLengthSq
; 1561 :     ( CONST D3DXQUATERNION *pQ )
; 1562 : {
; 1563 : #ifdef D3DX_DEBUG
; 1564 :     if(!pQ)
; 1565 :         return 0.0f;
; 1566 : #endif
; 1567 : 
; 1568 :     return pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w;
; 1569 : }
; 1570 : 
; 1571 : D3DXINLINE FLOAT D3DXQuaternionDot
; 1572 :     ( CONST D3DXQUATERNION *pQ1, CONST D3DXQUATERNION *pQ2 )
; 1573 : {
; 1574 : #ifdef D3DX_DEBUG
; 1575 :     if(!pQ1 || !pQ2)
; 1576 :         return 0.0f;
; 1577 : #endif
; 1578 : 
; 1579 :     return pQ1->x * pQ2->x + pQ1->y * pQ2->y + pQ1->z * pQ2->z + pQ1->w * pQ2->w;
; 1580 : }
; 1581 : 
; 1582 : 
; 1583 : D3DXINLINE D3DXQUATERNION* D3DXQuaternionIdentity
; 1584 :     ( D3DXQUATERNION *pOut )
; 1585 : {
; 1586 : #ifdef D3DX_DEBUG
; 1587 :     if(!pOut)
; 1588 :         return NULL;
; 1589 : #endif
; 1590 : 
; 1591 :     pOut->x = pOut->y = pOut->z = 0.0f;
; 1592 :     pOut->w = 1.0f;
; 1593 :     return pOut;
; 1594 : }
; 1595 : 
; 1596 : D3DXINLINE BOOL D3DXQuaternionIsIdentity
; 1597 :     ( CONST D3DXQUATERNION *pQ )
; 1598 : {
; 1599 : #ifdef D3DX_DEBUG
; 1600 :     if(!pQ)
; 1601 :         return FALSE;
; 1602 : #endif
; 1603 : 
; 1604 :     return pQ->x == 0.0f && pQ->y == 0.0f && pQ->z == 0.0f && pQ->w == 1.0f;
; 1605 : }
; 1606 : 
; 1607 : 
; 1608 : D3DXINLINE D3DXQUATERNION* D3DXQuaternionConjugate
; 1609 :     ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ )
; 1610 : {
; 1611 : #ifdef D3DX_DEBUG
; 1612 :     if(!pOut || !pQ)
; 1613 :         return NULL;
; 1614 : #endif
; 1615 : 
; 1616 :     pOut->x = -pQ->x;

  00035	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  00039	0f 57 c1	 xorps	 xmm0, xmm1

; 670  :     w = fw;

  0003c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _qtSrc$[ebp+12], 0

; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;
; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;
; 1265 : }
; 1266 : 
; 1267 : D3DXINLINE D3DXVECTOR3* D3DXVec3Cross
; 1268 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1269 : {
; 1270 :     D3DXVECTOR3 v;
; 1271 : 
; 1272 : #ifdef D3DX_DEBUG
; 1273 :     if(!pOut || !pV1 || !pV2)
; 1274 :         return NULL;
; 1275 : #endif
; 1276 : 
; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;
; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;
; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;
; 1280 : 
; 1281 :     *pOut = v;
; 1282 :     return pOut;
; 1283 : }
; 1284 : 
; 1285 : D3DXINLINE D3DXVECTOR3* D3DXVec3Add
; 1286 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1287 : {
; 1288 : #ifdef D3DX_DEBUG
; 1289 :     if(!pOut || !pV1 || !pV2)
; 1290 :         return NULL;
; 1291 : #endif
; 1292 : 
; 1293 :     pOut->x = pV1->x + pV2->x;
; 1294 :     pOut->y = pV1->y + pV2->y;
; 1295 :     pOut->z = pV1->z + pV2->z;
; 1296 :     return pOut;
; 1297 : }
; 1298 : 
; 1299 : D3DXINLINE D3DXVECTOR3* D3DXVec3Subtract
; 1300 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1301 : {
; 1302 : #ifdef D3DX_DEBUG
; 1303 :     if(!pOut || !pV1 || !pV2)
; 1304 :         return NULL;
; 1305 : #endif
; 1306 : 
; 1307 :     pOut->x = pV1->x - pV2->x;
; 1308 :     pOut->y = pV1->y - pV2->y;
; 1309 :     pOut->z = pV1->z - pV2->z;
; 1310 :     return pOut;
; 1311 : }
; 1312 : 
; 1313 : D3DXINLINE D3DXVECTOR3* D3DXVec3Minimize
; 1314 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1315 : {
; 1316 : #ifdef D3DX_DEBUG
; 1317 :     if(!pOut || !pV1 || !pV2)
; 1318 :         return NULL;
; 1319 : #endif
; 1320 : 
; 1321 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1322 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1323 :     pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
; 1324 :     return pOut;
; 1325 : }
; 1326 : 
; 1327 : D3DXINLINE D3DXVECTOR3* D3DXVec3Maximize
; 1328 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1329 : {
; 1330 : #ifdef D3DX_DEBUG
; 1331 :     if(!pOut || !pV1 || !pV2)
; 1332 :         return NULL;
; 1333 : #endif
; 1334 : 
; 1335 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1336 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1337 :     pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
; 1338 :     return pOut;
; 1339 : }
; 1340 : 
; 1341 : D3DXINLINE D3DXVECTOR3* D3DXVec3Scale
; 1342 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, FLOAT s)
; 1343 : {
; 1344 : #ifdef D3DX_DEBUG
; 1345 :     if(!pOut || !pV)
; 1346 :         return NULL;
; 1347 : #endif
; 1348 : 
; 1349 :     pOut->x = pV->x * s;
; 1350 :     pOut->y = pV->y * s;
; 1351 :     pOut->z = pV->z * s;
; 1352 :     return pOut;
; 1353 : }
; 1354 : 
; 1355 : D3DXINLINE D3DXVECTOR3* D3DXVec3Lerp
; 1356 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
; 1357 :       FLOAT s )
; 1358 : {
; 1359 : #ifdef D3DX_DEBUG
; 1360 :     if(!pOut || !pV1 || !pV2)
; 1361 :         return NULL;
; 1362 : #endif
; 1363 : 
; 1364 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1365 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1366 :     pOut->z = pV1->z + s * (pV2->z - pV1->z);
; 1367 :     return pOut;
; 1368 : }
; 1369 : 
; 1370 : 
; 1371 : //--------------------------
; 1372 : // 4D Vector
; 1373 : //--------------------------
; 1374 : 
; 1375 : D3DXINLINE FLOAT D3DXVec4Length
; 1376 :     ( CONST D3DXVECTOR4 *pV )
; 1377 : {
; 1378 : #ifdef D3DX_DEBUG
; 1379 :     if(!pV)
; 1380 :         return 0.0f;
; 1381 : #endif
; 1382 : 
; 1383 : #ifdef __cplusplus
; 1384 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w);
; 1385 : #else
; 1386 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w);
; 1387 : #endif
; 1388 : }
; 1389 : 
; 1390 : D3DXINLINE FLOAT D3DXVec4LengthSq
; 1391 :     ( CONST D3DXVECTOR4 *pV )
; 1392 : {
; 1393 : #ifdef D3DX_DEBUG
; 1394 :     if(!pV)
; 1395 :         return 0.0f;
; 1396 : #endif
; 1397 : 
; 1398 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w;
; 1399 : }
; 1400 : 
; 1401 : D3DXINLINE FLOAT D3DXVec4Dot
; 1402 :     ( CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2 )
; 1403 : {
; 1404 : #ifdef D3DX_DEBUG
; 1405 :     if(!pV1 || !pV2)
; 1406 :         return 0.0f;
; 1407 : #endif
; 1408 : 
; 1409 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z + pV1->w * pV2->w;
; 1410 : }
; 1411 : 
; 1412 : D3DXINLINE D3DXVECTOR4* D3DXVec4Add
; 1413 :     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
; 1414 : {
; 1415 : #ifdef D3DX_DEBUG
; 1416 :     if(!pOut || !pV1 || !pV2)
; 1417 :         return NULL;
; 1418 : #endif
; 1419 : 
; 1420 :     pOut->x = pV1->x + pV2->x;
; 1421 :     pOut->y = pV1->y + pV2->y;
; 1422 :     pOut->z = pV1->z + pV2->z;
; 1423 :     pOut->w = pV1->w + pV2->w;
; 1424 :     return pOut;
; 1425 : }
; 1426 : 
; 1427 : D3DXINLINE D3DXVECTOR4* D3DXVec4Subtract
; 1428 :     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
; 1429 : {
; 1430 : #ifdef D3DX_DEBUG
; 1431 :     if(!pOut || !pV1 || !pV2)
; 1432 :         return NULL;
; 1433 : #endif
; 1434 : 
; 1435 :     pOut->x = pV1->x - pV2->x;
; 1436 :     pOut->y = pV1->y - pV2->y;
; 1437 :     pOut->z = pV1->z - pV2->z;
; 1438 :     pOut->w = pV1->w - pV2->w;
; 1439 :     return pOut;
; 1440 : }
; 1441 : 
; 1442 : D3DXINLINE D3DXVECTOR4* D3DXVec4Minimize
; 1443 :     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
; 1444 : {
; 1445 : #ifdef D3DX_DEBUG
; 1446 :     if(!pOut || !pV1 || !pV2)
; 1447 :         return NULL;
; 1448 : #endif
; 1449 : 
; 1450 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1451 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1452 :     pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
; 1453 :     pOut->w = pV1->w < pV2->w ? pV1->w : pV2->w;
; 1454 :     return pOut;
; 1455 : }
; 1456 : 
; 1457 : D3DXINLINE D3DXVECTOR4* D3DXVec4Maximize
; 1458 :     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
; 1459 : {
; 1460 : #ifdef D3DX_DEBUG
; 1461 :     if(!pOut || !pV1 || !pV2)
; 1462 :         return NULL;
; 1463 : #endif
; 1464 : 
; 1465 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1466 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1467 :     pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
; 1468 :     pOut->w = pV1->w > pV2->w ? pV1->w : pV2->w;
; 1469 :     return pOut;
; 1470 : }
; 1471 : 
; 1472 : D3DXINLINE D3DXVECTOR4* D3DXVec4Scale
; 1473 :     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV, FLOAT s)
; 1474 : {
; 1475 : #ifdef D3DX_DEBUG
; 1476 :     if(!pOut || !pV)
; 1477 :         return NULL;
; 1478 : #endif
; 1479 : 
; 1480 :     pOut->x = pV->x * s;
; 1481 :     pOut->y = pV->y * s;
; 1482 :     pOut->z = pV->z * s;
; 1483 :     pOut->w = pV->w * s;
; 1484 :     return pOut;
; 1485 : }
; 1486 : 
; 1487 : D3DXINLINE D3DXVECTOR4* D3DXVec4Lerp
; 1488 :     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
; 1489 :       FLOAT s )
; 1490 : {
; 1491 : #ifdef D3DX_DEBUG
; 1492 :     if(!pOut || !pV1 || !pV2)
; 1493 :         return NULL;
; 1494 : #endif
; 1495 : 
; 1496 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1497 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1498 :     pOut->z = pV1->z + s * (pV2->z - pV1->z);
; 1499 :     pOut->w = pV1->w + s * (pV2->w - pV1->w);
; 1500 :     return pOut;
; 1501 : }
; 1502 : 
; 1503 : 
; 1504 : //--------------------------
; 1505 : // 4D Matrix
; 1506 : //--------------------------
; 1507 : 
; 1508 : D3DXINLINE D3DXMATRIX* D3DXMatrixIdentity
; 1509 :     ( D3DXMATRIX *pOut )
; 1510 : {
; 1511 : #ifdef D3DX_DEBUG
; 1512 :     if(!pOut)
; 1513 :         return NULL;
; 1514 : #endif
; 1515 : 
; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =
; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;
; 1522 :     return pOut;
; 1523 : }
; 1524 : 
; 1525 : 
; 1526 : D3DXINLINE BOOL D3DXMatrixIsIdentity
; 1527 :     ( CONST D3DXMATRIX *pM )
; 1528 : {
; 1529 : #ifdef D3DX_DEBUG
; 1530 :     if(!pM)
; 1531 :         return FALSE;
; 1532 : #endif
; 1533 : 
; 1534 :     return pM->m[0][0] == 1.0f && pM->m[0][1] == 0.0f && pM->m[0][2] == 0.0f && pM->m[0][3] == 0.0f &&
; 1535 :            pM->m[1][0] == 0.0f && pM->m[1][1] == 1.0f && pM->m[1][2] == 0.0f && pM->m[1][3] == 0.0f &&
; 1536 :            pM->m[2][0] == 0.0f && pM->m[2][1] == 0.0f && pM->m[2][2] == 1.0f && pM->m[2][3] == 0.0f &&
; 1537 :            pM->m[3][0] == 0.0f && pM->m[3][1] == 0.0f && pM->m[3][2] == 0.0f && pM->m[3][3] == 1.0f;
; 1538 : }
; 1539 : 
; 1540 : 
; 1541 : //--------------------------
; 1542 : // Quaternion
; 1543 : //--------------------------
; 1544 : 
; 1545 : D3DXINLINE FLOAT D3DXQuaternionLength
; 1546 :     ( CONST D3DXQUATERNION *pQ )
; 1547 : {
; 1548 : #ifdef D3DX_DEBUG
; 1549 :     if(!pQ)
; 1550 :         return 0.0f;
; 1551 : #endif
; 1552 : 
; 1553 : #ifdef __cplusplus
; 1554 :     return sqrtf(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w);
; 1555 : #else
; 1556 :     return (FLOAT) sqrt(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w);
; 1557 : #endif
; 1558 : }
; 1559 : 
; 1560 : D3DXINLINE FLOAT D3DXQuaternionLengthSq
; 1561 :     ( CONST D3DXQUATERNION *pQ )
; 1562 : {
; 1563 : #ifdef D3DX_DEBUG
; 1564 :     if(!pQ)
; 1565 :         return 0.0f;
; 1566 : #endif
; 1567 : 
; 1568 :     return pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w;
; 1569 : }
; 1570 : 
; 1571 : D3DXINLINE FLOAT D3DXQuaternionDot
; 1572 :     ( CONST D3DXQUATERNION *pQ1, CONST D3DXQUATERNION *pQ2 )
; 1573 : {
; 1574 : #ifdef D3DX_DEBUG
; 1575 :     if(!pQ1 || !pQ2)
; 1576 :         return 0.0f;
; 1577 : #endif
; 1578 : 
; 1579 :     return pQ1->x * pQ2->x + pQ1->y * pQ2->y + pQ1->z * pQ2->z + pQ1->w * pQ2->w;
; 1580 : }
; 1581 : 
; 1582 : 
; 1583 : D3DXINLINE D3DXQUATERNION* D3DXQuaternionIdentity
; 1584 :     ( D3DXQUATERNION *pOut )
; 1585 : {
; 1586 : #ifdef D3DX_DEBUG
; 1587 :     if(!pOut)
; 1588 :         return NULL;
; 1589 : #endif
; 1590 : 
; 1591 :     pOut->x = pOut->y = pOut->z = 0.0f;
; 1592 :     pOut->w = 1.0f;
; 1593 :     return pOut;
; 1594 : }
; 1595 : 
; 1596 : D3DXINLINE BOOL D3DXQuaternionIsIdentity
; 1597 :     ( CONST D3DXQUATERNION *pQ )
; 1598 : {
; 1599 : #ifdef D3DX_DEBUG
; 1600 :     if(!pQ)
; 1601 :         return FALSE;
; 1602 : #endif
; 1603 : 
; 1604 :     return pQ->x == 0.0f && pQ->y == 0.0f && pQ->z == 0.0f && pQ->w == 1.0f;
; 1605 : }
; 1606 : 
; 1607 : 
; 1608 : D3DXINLINE D3DXQUATERNION* D3DXQuaternionConjugate
; 1609 :     ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ )
; 1610 : {
; 1611 : #ifdef D3DX_DEBUG
; 1612 :     if(!pOut || !pQ)
; 1613 :         return NULL;
; 1614 : #endif
; 1615 : 
; 1616 :     pOut->x = -pQ->x;

  00043	f3 0f 11 45 f0	 movss	 DWORD PTR _qtRet$[ebp], xmm0

; 1617 :     pOut->y = -pQ->y;

  00048	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]
  0004d	0f 57 c1	 xorps	 xmm0, xmm1
  00050	f3 0f 11 45 f4	 movss	 DWORD PTR _qtRet$[ebp+4], xmm0

; 1618 :     pOut->z = -pQ->z;

  00055	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp

; 51   : 	D3DXQuaternionMultiply(&qtRet, &qtSrc, &qtRet);

  0005a	50		 push	 eax
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1618 :     pOut->z = -pQ->z;

  0005b	0f 57 c1	 xorps	 xmm0, xmm1
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp

; 51   : 	D3DXQuaternionMultiply(&qtRet, &qtSrc, &qtRet);

  0005e	8d 45 e0	 lea	 eax, DWORD PTR _qtSrc$[ebp]
  00061	50		 push	 eax
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1618 :     pOut->z = -pQ->z;

  00062	f3 0f 11 45 f8	 movss	 DWORD PTR _qtRet$[ebp+8], xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp

; 51   : 	D3DXQuaternionMultiply(&qtRet, &qtSrc, &qtRet);

  00067	8d 45 f0	 lea	 eax, DWORD PTR _qtRet$[ebp]
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1619 :     pOut->w =  pQ->w;

  0006a	f3 0f 10 46 0c	 movss	 xmm0, DWORD PTR [esi+12]
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp

; 51   : 	D3DXQuaternionMultiply(&qtRet, &qtSrc, &qtRet);

  0006f	50		 push	 eax
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl

; 1619 :     pOut->w =  pQ->w;

  00070	f3 0f 11 45 fc	 movss	 DWORD PTR _qtRet$[ebp+12], xmm0
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp

; 51   : 	D3DXQuaternionMultiply(&qtRet, &qtSrc, &qtRet);

  00075	e8 00 00 00 00	 call	 _D3DXQuaternionMultiply@12

; 52   : 	D3DXQuaternionMultiply(&qtRet, c_pqtRot, &qtRet);

  0007a	8d 45 f0	 lea	 eax, DWORD PTR _qtRet$[ebp]
  0007d	50		 push	 eax
  0007e	56		 push	 esi
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 _D3DXQuaternionMultiply@12

; 53   : 
; 54   : 	pvtOut->x=qtRet.x;

  00085	8b 45 08	 mov	 eax, DWORD PTR _pvtOut$[ebp]
  00088	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _qtRet$[ebp]
  0008d	5e		 pop	 esi
  0008e	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 55   : 	pvtOut->y=qtRet.y;

  00092	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _qtRet$[ebp+4]
  00097	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 56   : 	pvtOut->z=qtRet.z;

  0009c	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _qtRet$[ebp+8]
  000a1	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 57   : 
; 58   : 	return pvtOut;
; 59   : }

  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
?D3DXVec3Rotation@@YAPAUD3DXVECTOR3@@PAU1@PBU1@PBUD3DXQUATERNION@@@Z ENDP ; D3DXVec3Rotation
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
;	COMDAT ?IsInTriangle2D@@YA_NMMMMMMMM@Z
_TEXT	SEGMENT
_c3$ = -12						; size = 4
_c1$ = -8						; size = 4
_c2$ = -4						; size = 4
_ax$ = 8						; size = 4
_ay$ = 12						; size = 4
_bx$ = 16						; size = 4
_by$ = 20						; size = 4
_cx$ = 24						; size = 4
_cy$ = 28						; size = 4
_tx$ = 32						; size = 4
_ty$ = 36						; size = 4
?IsInTriangle2D@@YA_NMMMMMMMM@Z PROC			; IsInTriangle2D, COMDAT

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 11   : 	float c1 = CrossProduct2D(bx-ax, by-ay, tx-ax, ty-ay);

  00006	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _ty$[ebp]
  0000b	83 ec 10	 sub	 esp, 16			; 00000010H
  0000e	f3 0f 5c 45 0c	 subss	 xmm0, DWORD PTR _ay$[ebp]
  00013	f3 0f 10 55 14	 movss	 xmm2, DWORD PTR _by$[ebp]
  00018	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  0001e	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _tx$[ebp]
  00023	f3 0f 5c 45 08	 subss	 xmm0, DWORD PTR _ax$[ebp]
  00028	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0002e	0f 28 c2	 movaps	 xmm0, xmm2
  00031	f3 0f 5c 45 0c	 subss	 xmm0, DWORD PTR _ay$[ebp]
  00036	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0003c	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _bx$[ebp]
  00041	f3 0f 5c 45 08	 subss	 xmm0, DWORD PTR _ax$[ebp]
  00046	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004b	e8 00 00 00 00	 call	 ?CrossProduct2D@@YAMMMMM@Z ; CrossProduct2D

; 12   : 	float c2 = CrossProduct2D(cx-bx, cy-by, tx-bx, ty-by);

  00050	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _ty$[ebp]
  00055	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR _by$[ebp]
  0005a	f3 0f 10 5d 18	 movss	 xmm3, DWORD PTR _cx$[ebp]
  0005f	d9 5d f8	 fstp	 DWORD PTR _c1$[ebp]
  00062	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  00068	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _tx$[ebp]
  0006d	f3 0f 5c 45 10	 subss	 xmm0, DWORD PTR _bx$[ebp]
  00072	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00078	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _cy$[ebp]
  0007d	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR _by$[ebp]
  00082	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00088	0f 28 c3	 movaps	 xmm0, xmm3
  0008b	f3 0f 5c 45 10	 subss	 xmm0, DWORD PTR _bx$[ebp]
  00090	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00095	e8 00 00 00 00	 call	 ?CrossProduct2D@@YAMMMMM@Z ; CrossProduct2D

; 13   : 	float c3 = CrossProduct2D(ax-cx, ay-cy, tx-cx, ty-cy);

  0009a	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _ty$[ebp]
  0009f	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR _cy$[ebp]
  000a4	d9 5d fc	 fstp	 DWORD PTR _c2$[ebp]
  000a7	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  000ad	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _tx$[ebp]
  000b2	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR _cx$[ebp]
  000b7	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  000bd	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _ay$[ebp]
  000c2	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR _cy$[ebp]
  000c7	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000cd	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _ax$[ebp]
  000d2	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR _cx$[ebp]
  000d7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000dc	e8 00 00 00 00	 call	 ?CrossProduct2D@@YAMMMMM@Z ; CrossProduct2D

; 14   : 	
; 15   : 	if (c1 * c2 > 0.0f && c1 * c3 > 0.0f)

  000e1	f3 0f 10 4d fc	 movss	 xmm1, DWORD PTR _c2$[ebp]
  000e6	0f 57 d2	 xorps	 xmm2, xmm2
  000e9	f3 0f 10 65 f8	 movss	 xmm4, DWORD PTR _c1$[ebp]
  000ee	83 c4 10	 add	 esp, 16			; 00000010H
  000f1	f3 0f 59 cc	 mulss	 xmm1, xmm4
  000f5	d9 5d f4	 fstp	 DWORD PTR _c3$[ebp]
  000f8	f3 0f 10 5d f4	 movss	 xmm3, DWORD PTR _c3$[ebp]
  000fd	0f 2f ca	 comiss	 xmm1, xmm2
  00100	76 12		 jbe	 SHORT $LN14@IsInTriang
  00102	0f 28 c3	 movaps	 xmm0, xmm3
  00105	f3 0f 59 c4	 mulss	 xmm0, xmm4
  00109	0f 2f c2	 comiss	 xmm0, xmm2
  0010c	76 06		 jbe	 SHORT $LN14@IsInTriang
$LN1@IsInTriang:

; 16   : 		return true;

  0010e	b0 01		 mov	 al, 1

; 44   : }

  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c3		 ret	 0
$LN14@IsInTriang:

; 17   : 
; 18   : 	if (c1 * c2 * c3 == 0.0f)

  00114	f3 0f 59 cb	 mulss	 xmm1, xmm3
  00118	0f 2e ca	 ucomiss xmm1, xmm2
  0011b	9f		 lahf
  0011c	f6 c4 44	 test	 ah, 68			; 00000044H
  0011f	7a 64		 jp	 SHORT $LN13@IsInTriang

; 19   : 	{
; 20   : 		if (tx < ax)

  00121	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _tx$[ebp]
  00126	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _ax$[ebp]
  0012b	0f 2f c8	 comiss	 xmm1, xmm0

; 21   : 			if (tx < bx)

  0012e	f3 0f 10 55 10	 movss	 xmm2, DWORD PTR _bx$[ebp]

; 22   : 				if (tx < cx)

  00133	f3 0f 10 5d 18	 movss	 xmm3, DWORD PTR _cx$[ebp]
  00138	76 0a		 jbe	 SHORT $LN10@IsInTriang

; 21   : 			if (tx < bx)

  0013a	0f 2f d0	 comiss	 xmm2, xmm0
  0013d	76 05		 jbe	 SHORT $LN10@IsInTriang

; 22   : 				if (tx < cx)

  0013f	0f 2f d8	 comiss	 xmm3, xmm0
  00142	77 41		 ja	 SHORT $LN13@IsInTriang
$LN10@IsInTriang:

; 23   : 					return false;
; 24   : 
; 25   : 		if (tx > ax)

  00144	0f 2f c1	 comiss	 xmm0, xmm1
  00147	76 0a		 jbe	 SHORT $LN7@IsInTriang

; 26   : 			if (tx > bx)

  00149	0f 2f c2	 comiss	 xmm0, xmm2
  0014c	76 05		 jbe	 SHORT $LN7@IsInTriang

; 27   : 				if (tx > cx)

  0014e	0f 2f c3	 comiss	 xmm0, xmm3
  00151	77 32		 ja	 SHORT $LN13@IsInTriang
$LN7@IsInTriang:

; 28   : 					return false;
; 29   : 
; 30   : 		if (ty < ay)

  00153	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _ty$[ebp]
  00158	f3 0f 10 5d 0c	 movss	 xmm3, DWORD PTR _ay$[ebp]
  0015d	0f 2f d8	 comiss	 xmm3, xmm0

; 31   : 			if (ty < by)

  00160	f3 0f 10 55 14	 movss	 xmm2, DWORD PTR _by$[ebp]

; 32   : 				if (ty < cy)

  00165	f3 0f 10 4d 1c	 movss	 xmm1, DWORD PTR _cy$[ebp]
  0016a	76 0a		 jbe	 SHORT $LN4@IsInTriang

; 31   : 			if (ty < by)

  0016c	0f 2f d0	 comiss	 xmm2, xmm0
  0016f	76 05		 jbe	 SHORT $LN4@IsInTriang

; 32   : 				if (ty < cy)

  00171	0f 2f c8	 comiss	 xmm1, xmm0
  00174	77 0f		 ja	 SHORT $LN13@IsInTriang
$LN4@IsInTriang:

; 33   : 					return false;
; 34   : 
; 35   : 		if (ty > ay)

  00176	0f 2f c3	 comiss	 xmm0, xmm3
  00179	76 93		 jbe	 SHORT $LN1@IsInTriang

; 36   : 			if (ty > by)

  0017b	0f 2f c2	 comiss	 xmm0, xmm2
  0017e	76 8e		 jbe	 SHORT $LN1@IsInTriang

; 37   : 				if (ty > cy)

  00180	0f 2f c1	 comiss	 xmm0, xmm1
  00183	76 89		 jbe	 SHORT $LN1@IsInTriang
$LN13@IsInTriang:

; 38   : 					return false;
; 39   : 
; 40   : 		return true;
; 41   : 	}
; 42   : 
; 43   : 	return false;

  00185	32 c0		 xor	 al, al

; 44   : }

  00187	8b e5		 mov	 esp, ebp
  00189	5d		 pop	 ebp
  0018a	c3		 ret	 0
?IsInTriangle2D@@YA_NMMMMMMMM@Z ENDP			; IsInTriangle2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\eterlib\grpmath.cpp
;	COMDAT ?CrossProduct2D@@YAMMMMM@Z
_TEXT	SEGMENT
tv67 = 8						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
?CrossProduct2D@@YAMMMMM@Z PROC				; CrossProduct2D, COMDAT

; 5    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6    : 	return x1*y2-y1*x2;

  00003	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _x1$[ebp]
  00008	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _y1$[ebp]
  0000d	f3 0f 59 4d 14	 mulss	 xmm1, DWORD PTR _y2$[ebp]
  00012	f3 0f 59 45 10	 mulss	 xmm0, DWORD PTR _x2$[ebp]
  00017	f3 0f 5c c8	 subss	 xmm1, xmm0
  0001b	f3 0f 11 4d 08	 movss	 DWORD PTR tv67[ebp], xmm1
  00020	d9 45 08	 fld	 DWORD PTR tv67[ebp]

; 7    : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?CrossProduct2D@@YAMMMMM@Z ENDP				; CrossProduct2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
;	COMDAT ?D3DXQuaternionConjugate@@YAPAUD3DXQUATERNION@@PAU1@PBU1@@Z
_TEXT	SEGMENT
_pOut$ = 8						; size = 4
_pQ$ = 12						; size = 4
?D3DXQuaternionConjugate@@YAPAUD3DXQUATERNION@@PAU1@PBU1@@Z PROC ; D3DXQuaternionConjugate, COMDAT

; 1610 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1611 : #ifdef D3DX_DEBUG
; 1612 :     if(!pOut || !pQ)
; 1613 :         return NULL;
; 1614 : #endif
; 1615 : 
; 1616 :     pOut->x = -pQ->x;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _pQ$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _pOut$[ebp]
  00009	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
  00011	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00015	0f 57 c1	 xorps	 xmm0, xmm1
  00018	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 1617 :     pOut->y = -pQ->y;

  0001c	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00021	0f 57 c1	 xorps	 xmm0, xmm1
  00024	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 1618 :     pOut->z = -pQ->z;

  00029	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0002e	0f 57 c1	 xorps	 xmm0, xmm1
  00031	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 1619 :     pOut->w =  pQ->w;

  00036	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00039	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 1620 :     return pOut;
; 1621 : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?D3DXQuaternionConjugate@@YAPAUD3DXQUATERNION@@PAU1@PBU1@@Z ENDP ; D3DXQuaternionConjugate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
;	COMDAT ??0D3DXQUATERNION@@QAE@MMMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
_fw$ = 20						; size = 4
??0D3DXQUATERNION@@QAE@MMMM@Z PROC			; D3DXQUATERNION::D3DXQUATERNION, COMDAT
; _this$ = ecx

; 666  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 667  :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]

; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }

  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00022	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fw$[ebp]
  00027	f3 0f 11 41 0c	 movss	 DWORD PTR [ecx+12], xmm0
  0002c	5d		 pop	 ebp
  0002d	c2 10 00	 ret	 16			; 00000010H
??0D3DXQUATERNION@@QAE@MMMM@Z ENDP			; D3DXQUATERNION::D3DXQUATERNION
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.h
;	COMDAT ??0D3DXQUATERNION@@QAE@XZ
_TEXT	SEGMENT
??0D3DXQUATERNION@@QAE@XZ PROC				; D3DXQUATERNION::D3DXQUATERNION, COMDAT
; _this$ = ecx

; 332  :     D3DXQUATERNION() {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXQUATERNION@@QAE@XZ ENDP				; D3DXQUATERNION::D3DXQUATERNION
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.inl
;	COMDAT ??DD3DXMATRIX@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_mat$ = 12						; size = 4
??DD3DXMATRIX@@QBE?AU0@ABU0@@Z PROC			; D3DXMATRIX::operator*, COMDAT
; _this$ = ecx

; 578  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  00003	ff 75 0c	 push	 DWORD PTR _mat$[ebp]
  00006	51		 push	 ecx
  00007	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0000a	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 581  :     return matT;

  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 582  : }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??DD3DXMATRIX@@QBE?AU0@ABU0@@Z ENDP			; D3DXMATRIX::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.h
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
??0D3DXMATRIX@@QAE@XZ PROC				; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 177  :     D3DXMATRIX() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\gamepackages\client\tools\patcher2017\extern\include\d3dx8math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 89   :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv68 = -4						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 774  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 775  :     return (float)sqrt(_X);

  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00016	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0001a	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv68[esp+8], xmm0
  00020	d9 44 24 04	 fld	 DWORD PTR tv68[esp+8]

; 776  : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _atan2f
_TEXT	SEGMENT
tv75 = -8						; size = 8
tv70 = -8						; size = 8
tv81 = 8						; size = 4
__Y$ = 8						; size = 4
__X$ = 12						; size = 4
_atan2f	PROC						; COMDAT

; 648  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __Y$[ebp]

; 649  :     return (float)atan2(_Y, _X);

  0000b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0000e	f2 0f 11 45 f8	 movsd	 QWORD PTR tv70[ebp], xmm0
  00013	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR __X$[ebp]
  00018	dd 45 f8	 fld	 QWORD PTR tv70[ebp]
  0001b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0001e	f2 0f 11 45 f8	 movsd	 QWORD PTR tv75[ebp], xmm0
  00023	dd 45 f8	 fld	 QWORD PTR tv75[ebp]
  00026	e8 00 00 00 00	 call	 __CIatan2
  0002b	d9 5d 08	 fstp	 DWORD PTR tv81[ebp]
  0002e	d9 45 08	 fld	 DWORD PTR tv81[ebp]

; 650  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
_atan2f	ENDP
_TEXT	ENDS
END
